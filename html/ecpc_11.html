<div class="container">

<table style="width: 100%;"><tr>
<td>obtainHierarchy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>

Obtain hierarchy
</h2>

<h3>Description</h3>


<p>This function obtains the group set on group level that defines the hierarchy;
if a group of covariates g is a subset of group h, then group h is an ancestor of group g (higher up in the hierarchy).
This hierarchy is used in adaptively discretising continuous co-data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">obtainHierarchy(groupset, penalty = "LOG")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>groupset</code></td>
<td>


<p>Group set of groups of covariates with nested groups.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>


<p>Default: "LOG" for a latent overlapping group approach (currently the only option in ecpc)
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p>We use the latent overlapping group (LOG) lasso penalty to define the hierarchical constraints as described in (Yan, Bien et al. 2007);
for each group g of covariates, we make a group on group level with group number g and the group numbers of its ancestors in the hierarchical tree. 
This way, group g can be selected if and only if all its ancestors are selected.
This function assumes that if group g is a subset of group h, then group h is an ancestor of group g. 
Note that this assumption does not necessarily hold for all hierarchies. The group set on group level should then be coded manually.
</p>


<h3>Value</h3>






<p>A group set on group level defining the hierarchy.
</p>


<h3>References</h3>


<p>Yan, X., Bien, J. et al. (2017). Hierarchical sparse modeling: A choice of two group lasso formulations. Statistical Science 32 531-560.
</p>


<h3>See Also</h3>


<p><code>splitMedian</code> to obtain a group set of nested groups for continuous co-data.
</p>


<h3>Examples</h3>

<pre><code class="language-R">cont.codata &lt;- seq(0,1,length.out=20) #continuous co-data
#only split at lower continous co-data group
groupset &lt;- splitMedian(values=cont.codata,split="lower",minGroupSize=5) 
#obtain groups on group level defining the hierarchy
groupset.grouplvl &lt;- obtainHierarchy(groupset) 

</code></pre>


</div>