<div class="container">

<table style="width: 100%;"><tr>
<td>import_from</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>import objects</h2>

<h3>Description</h3>

<p>This is inspired by the python idiom <code style="white-space: pre;">⁠from module import object as new_name⁠</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">import_from(
  x,
  ...,
  .into = parent.frame(),
  .parent = .GlobalEnv,
  .overwrite = interactive(),
  .chdir = FALSE,
  .recursive = FALSE,
  .pos = 2L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a bare symbol name of a package, a character vector of filepaths, an
environment (which could be a python module), or any object with <code>names</code>
and <code>[[</code> methods defined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>objects to import from x into <code>.into</code>. if named, the name will be
the the new name after import. Alternatively, you can also supply the
wildcard string "*" or "**", along with some additional overrides. See
examples for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.into</code></td>
<td>
<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> environment, or something coercible to one by
<code>as.environment</code>, or a character string that is the name of a
(potentially new) attached environment. The default is the current frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parent, .chdir, .recursive</code></td>
<td>
<p>Only applicable if <code>x</code> is a character vector
of filepaths to R scripts, in which case these are passed on to include
(<code>chdir</code>, <code>recursive</code>) or new.env<code>(parent)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.overwrite</code></td>
<td>
<p>One of <code>"warn"</code>, <code>"error"</code> or <code>"ignore"</code>. Can also be a
boolean <code>TRUE</code> (same as <code>"ignore"</code>) or <code>FALSE</code> (same as <code>"error"</code>). What
should be done if the requested import operation would overwrite an
existing object. Character arguments can be abbreviated as partial matching
is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.pos</code></td>
<td>
<p>Only applicable if <code>.into</code> is a string that is the name of a new
environment that will be attached, in which case this will be the position
on new environment on the search path.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> environment or object that <code>x</code> resolved to, invisibly.
</p>


<h3>Note</h3>

<p>If <code>x</code> is a package name, then no check is performed to ensure the
object being imported is an exported function. As such, <code>import_from()</code> can
be used to access package internal objects, though doing so is usually bad
practice.
</p>


<h3>Examples</h3>

<pre><code class="language-R">show_whats_imported &lt;- function(...) {
  import_from(...)
  setdiff(names(environment()), "...")
}

## Importing from an R package
# import one object
show_whats_imported(envir, include)

# rename an object on import
show_whats_imported(envir, sys_source = include)

# import all NAMESPACE exports
show_whats_imported(envir, "*")
show_whats_imported(envir) # missing `...` is interpreted as "*"

# import all NAMESPACE exports, except for `include`
show_whats_imported(envir, "*", -include)

# import all NAMESPACE exports, except rename `include` to `sys_source`
show_whats_imported(envir, "*", sys_source = include)

# exclude more than one
show_whats_imported(envir, "*", -include, -attach_eval)
show_whats_imported(envir, "*", -c(include, attach_eval))

# import all NAMESPACE exports, also one internal function names `find_r_files`
show_whats_imported(envir, "*", find_r_files)

# import ALL package functions, including all internal functions
show_whats_imported(envir, "**")

# import ALL objects in the package NAMESPACE, including R's NAMESPACE machinery
show_whats_imported(envir, "***")


## Importing from R files
# setup
dir.create(tmpdir &lt;- tempfile())
owd &lt;- setwd(tmpdir)
writeLines(c("useful_function &lt;- function() 'I am useful'",
             ".less_useful_fn &lt;- function() 'less useful'"),
           "my_helpers.R")

# import one function by name
show_whats_imported("my_helpers.R", useful_function)

# import all objects whose names don't start with a "." or "_"
show_whats_imported("my_helpers.R", "*")

# import all objects
show_whats_imported("my_helpers.R", "**")

# if the filepath to your scripts is stored in a variable, supply it in a call
x &lt;- "my_helpers.R"
try(show_whats_imported(x)) # errors out, because no package 'x'
# to force the value to be used, just supply it as a call rather than a bare symbol.
# the simplest call can be just wrapping in () or {}
show_whats_imported({x})
show_whats_imported((x))
show_whats_imported(c(x))
show_whats_imported({{x}}) # tidyverse style unquoting

## Importing R objects

# if you have an actual R object that you want to import from, you will
# have to supply it in a call
x &lt;- list(obj1 = "one", obj2 = "two")
show_whats_imported({x})

## Not run: 
  # don't run this so we don't take a reticulate dependency
  import_from(reticulate, py_module = import) # rename object on import

  # import one object
  show_whats_imported(py_module("numpy"), random)

  # to prevent automatic conversion
  show_whats_imported(py_module("numpy", convert = FALSE), random)

  # import all objects that don't begin with a `_`
  # by default, other modules found in the module are also not imported
  show_whats_imported(py_module("glob"), "*")

  # to import EVERYTHING pass "**"
  # now includes modules that your modules imported, like `os`
  show_whats_imported(py_module("glob"), "**")

  rm(py_module) # clean up

## End(Not run)

# cleanup
setwd(owd)
unlink(tmpdir, recursive = TRUE)
rm(show_whats_imported, tmpdir, owd)
</code></pre>


</div>