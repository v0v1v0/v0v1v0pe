<div class="container">

<table style="width: 100%;"><tr>
<td>emoaIndEps</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>EMOA performance indicators</h2>

<h3>Description</h3>

<p>Functions for the computation of unary and binary measures which
are useful for the evaluation of the performace of EMOAs. See the references
section for literature on these indicators.
</p>
<p>Given a set of points <code>points</code>, <code>emoaIndEps</code> computes the
unary epsilon-indicator provided a set of reference points <code>ref.points</code>.
</p>
<p>The <code>emoaIndHV</code> function computes the hypervolume indicator
Hyp(X, R, r). Given a set of points X (<code>points</code>), another set of reference
points R (<code>ref.points</code>) (which maybe the true Pareto front) and a reference
point r (<code>ref.point</code>) it is defined as Hyp(X, R, r) = HV(R, r) - HV(X, r).
</p>
<p>Function <code>emoaIndR1</code>, <code>emoaIndR2</code> and <code>emoaIndR3</code> calculate the
R1, R2 and R3 indicator respectively.
</p>
<p>Function <code>emoaIndMD</code> computes the minimum distance indicator, i.e., the minimum
Euclidean distance between two points of the set <code>points</code> while function
<code>emoaIndM1</code> determines the mean Euclidean distance between <code>points</code>
and points from a reference set <code>ref.points</code>.
</p>
<p>Function <code>emoaIndC</code> calculates the coverage of the sets <code>points</code> (A) and
<code>ref.points</code> (B). This is the ratio of points in B which are dominated by
at least one solution in A.
</p>
<p><code>emoaIndONVG</code> calculates the “Overall Non-dominated Vector Generation”
indicator. Despite its complicated name it is just the number of non-dominated points
in <code>points</code>.
</p>
<p>Functions <code>emoaIndSP</code> and <code>emoaIndDelta</code> calculate spacing indicators.
The former was proposed by Schott: first calculate the sum of squared distances
between minimal distancesof points to all other points and the mean of these minimal
distance. Next, normalize by the number of points minus 1 and finally calculate the
square root. In contrast, Delta-indicator
</p>


<h3>Usage</h3>

<pre><code class="language-R">emoaIndEps(points, ref.points, ...)

emoaIndHV(points, ref.points, ref.point = NULL, ...)

emoaIndR1(
  points,
  ref.points,
  ideal.point = NULL,
  nadir.point = NULL,
  lambda = NULL,
  utility = "tschebycheff",
  ...
)

emoaIndR2(
  points,
  ref.points,
  ideal.point = NULL,
  nadir.point = NULL,
  lambda = NULL,
  utility = "tschebycheff",
  ...
)

emoaIndR3(
  points,
  ref.points,
  ideal.point = NULL,
  nadir.point = NULL,
  lambda = NULL,
  utility = "tschebycheff",
  ...
)

emoaIndMD(points, ...)

emoaIndC(points, ref.points, ...)

emoaIndM1(points, ref.points, ...)

emoaIndONVG(points, ...)

emoaIndGD(
  points,
  ref.points,
  p = 1,
  normalize = FALSE,
  dist.fun = computeEuclideanDistance,
  ...
)

emoaIndIGD(
  points,
  ref.points,
  p = 1,
  normalize = FALSE,
  dist.fun = computeEuclideanDistance,
  ...
)

emoaIndDeltap(
  points,
  ref.points,
  p = 1,
  normalize = FALSE,
  dist.fun = computeEuclideanDistance,
  ...
)

emoaIndSP(points, ...)

emoaIndDelta(points, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>
<p>[<code>matrix</code>]<br>
Matrix of points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref.points</code></td>
<td>
<p>[<code>matrix</code>]<br>
Set of reference points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>[any]<br>
Not used at the moment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref.point</code></td>
<td>
<p>[<code>numeric</code>]<br>
A single reference point used, e.g., for the computation of the hypervolume
indicator via <code>emoaIndHV</code>. If <code>NULL</code> the
nadir point of the union of the <code>points</code> and <code>ref.points</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ideal.point</code></td>
<td>
<p>[<code>numeric</code>]<br>
The utopia point of the true Pareto front, i.e., each component of the point
contains the best value if the other objectives are neglected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nadir.point</code></td>
<td>
<p>[<code>numeric</code>]<br>
Nadir point of the true Pareto front.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Number of weight vectors to use in estimating the utility function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>utility</code></td>
<td>
<p>[<code>character(1)</code>]<br>
Name of the utility function to use. Must be one of “weightedsum”,
“tschebycheff” or “augmented tschbycheff”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br>
Parameter p of the average Hausdoff metric.
Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>[<code>logical(1)</code>]<br>
Should the front be normalized on basis of <code>B</code>?
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.fun</code></td>
<td>
<p>[<code>matrix</code>]<br>
Distance function to compute distance between points x and y. Expects a single
numeric vector d with the coordinate-wise differences di = (xi - yi).
Default is <code>computeEuclideanDist</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>[<code>numeric(1)</code>] Epsilon indicator.
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code>approximateNadirPoint()</code>,
<code>approximateRefPoints()</code>,
<code>approximateRefSets()</code>,
<code>computeDominanceRanking()</code>,
<code>makeEMOAIndicator()</code>,
<code>niceCellFormater()</code>,
<code>normalize()</code>,
<code>plotDistribution()</code>,
<code>plotFront()</code>,
<code>plotScatter2d()</code>,
<code>plotScatter3d()</code>,
<code>toLatex()</code>
</p>


</div>