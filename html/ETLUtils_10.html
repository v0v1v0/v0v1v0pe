<div class="container">

<table style="width: 100%;"><tr>
<td>read.dbi.ffdf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Read data from a DBI connection into an ffdf.</h2>

<h3>Description</h3>

<p>Read data from a DBI connection into an <code>ffdf</code>. This can for example be used to import
large datasets from Oracle, SQLite, MySQL, PostgreSQL, Hive or other SQL databases into R. <br></p>


<h3>Usage</h3>

<pre><code class="language-R">read.dbi.ffdf(
  query = NULL,
  dbConnect.args = list(drv = NULL, dbname = NULL, username = "", password = ""),
  dbSendQuery.args = list(),
  dbFetch.args = list(),
  x = NULL,
  nrows = -1,
  first.rows = NULL,
  next.rows = NULL,
  levels = NULL,
  appendLevels = TRUE,
  asffdf_args = list(),
  BATCHBYTES = getOption("ffbatchbytes"),
  VERBOSE = FALSE,
  colClasses = NULL,
  transFUN = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>the SQL query to execute on the DBI connection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dbConnect.args</code></td>
<td>
<p>a list of arguments to pass to DBI's <code>dbConnect</code> (like drv, dbname, username, password). See the examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dbSendQuery.args</code></td>
<td>
<p>a list containing database-specific parameters which will be passed to to pass to <code>dbSendQuery</code>.
Defaults to an empty list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dbFetch.args</code></td>
<td>
<p>a list containing optional database-specific parameters which will be passed to to pass to <code>dbFetch</code>. 
Defaults to an empty list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>NULL or an optional ffdf object to which the read records are appended. 
See documentation in read.table.ffdf for more details and the example below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrows</code></td>
<td>
<p>Number of rows to read from the query resultset. Default value of -1 reads in all rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first.rows</code></td>
<td>
<p>chunk size (rows) to read for first chunk from the query resultset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>next.rows</code></td>
<td>
<p>chunk size (rows) to read sequentially for subsequent chunks from the query resultset. Currently, this must be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>optional specification of factor levels. A list with as names the names the columns of the data.frame 
fetched in the first.rows, containing levels of the factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>appendLevels</code></td>
<td>
<p>logical. A vector of permissions to expand levels for factor columns. See documentation in <code>read.table.ffdf</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asffdf_args</code></td>
<td>
<p>further arguments passed to <code>as.ffdf</code> (ignored if 'x' gives an ffdf object )</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BATCHBYTES</code></td>
<td>
<p>integer: bytes allowed for the size of the data.frame storing the result of reading one chunk. 
See documentation in <code>read.table.ffdf</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VERBOSE</code></td>
<td>
<p>logical: TRUE to verbose timings for each processed chunk (default FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colClasses</code></td>
<td>
<p>See documentation in <code>read.table.ffdf</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transFUN</code></td>
<td>
<p>function applied to the data frame after each chunk is retreived by <code>dbFetch</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional parameters passed on to transFUN</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Opens up the DBI connection using <code>DBI::dbConnect</code>, sends the query using <code>DBI::dbSendQuery</code> and <code>DBI::dbFetch</code>-es 
the results in batches of next.rows rows. Heavily borrowed from <code>read.table.ffdf</code>
</p>


<h3>Value</h3>

<p>An ffdf object unless the query returns zero records in which case the function will return the data.frame
returned by <code>dbFetch</code> and possibly transFUN.
</p>


<h3>See Also</h3>

<p><code>read.table.ffdf, read.odbc.ffdf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(ff)

##
## Example query using data in sqlite
##
require(RSQLite)
dbfile &lt;- system.file("smalldb.sqlite3", package="ETLUtils")
drv &lt;- dbDriver("SQLite")
query &lt;- "select * from testdata limit 10000"
x &lt;- read.dbi.ffdf(query = query, dbConnect.args = list(drv = drv, dbname = dbfile), 
first.rows = 100, next.rows = 1000, VERBOSE=TRUE)
class(x)
x[1:10, ]

## show it is the same as getting the data directly using RSQLite 
## apart from characters which are factors in ffdf objects
directly &lt;- dbGetQuery(dbConnect(drv = drv, dbname = dbfile), query)
directly &lt;- as.data.frame(as.list(directly), stringsAsFactors=TRUE)
all.equal(x[,], directly)

## show how to use the transFUN argument to transform the data before saving into the ffdf
## and shows the use of the levels argument
query &lt;- "select * from testdata limit 10"
x &lt;- read.dbi.ffdf(query = query, dbConnect.args = list(drv = drv, dbname = dbfile), 
first.rows = 100, next.rows = 1000, VERBOSE=TRUE, levels = list(a = rev(LETTERS)),
transFUN = function(x, subtractdays){
	x$b &lt;- as.Date(x$b)
	x$b.subtractdaysago &lt;- x$b - subtractdays
	x
}, subtractdays=7)
class(x)
x[1:10, ]
## remark that the levels of column a are reversed due to specifying the levels argument correctly
levels(x$a)

## show how to append data to an existing ffdf object 
transformexample &lt;- function(x, subtractdays){
	x$b &lt;- as.Date(x$b)
	x$b.subtractdaysago &lt;- x$b - subtractdays
	x
}
dim(x)
x[,]
combined &lt;- read.dbi.ffdf(query = query, 
 dbConnect.args = list(drv = drv, dbname = dbfile), 
 first.rows = 100, next.rows = 1000, x = x, VERBOSE=TRUE, 
 transFUN = transformexample, subtractdays=1000)
dim(combined)
combined[,]

##
## Example query using ROracle. Do try this at home with some larger data :)
##
## Not run: 
require(ROracle)
query &lt;- "select OWNER, TABLE_NAME, TABLESPACE_NAME, NUM_ROWS, LAST_ANALYZED from all_all_tables" 
x &lt;- read.dbi.ffdf(query=query,
dbConnect.args = list(drv = dbDriver("Oracle"), 
user = "YourUser", password = "YourPassword", dbname = "Mydatabase"),
first.rows = 100, next.rows = 50000, nrows = -1, VERBOSE=TRUE)

## End(Not run)
</code></pre>


</div>