<div class="container">

<table style="width: 100%;"><tr>
<td>CATESurface</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate CATE on a surface in the covariate space</h2>

<h3>Description</h3>

<p>Calculates CATE estimates from a causal forest object on a specified surface
within the covariate space.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CATESurface(
  forest,
  continuous_covariates,
  discrete_covariates,
  estimate_variance = TRUE,
  grid = 100,
  fixed_covariate_fct = median,
  other_discrete = NULL,
  max_predict_size = 1e+05,
  num_threads = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>forest</code></td>
<td>
<p>An object of class <code>causal_forest</code>, as returned by
causal_forest(). Alternatively, and object of class
<code>regression_forest</code>, as returned by regression_forest().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>continuous_covariates</code></td>
<td>
<p>character, continuous covariates to use for the
surface. Must match names in <code>forest$X.orig</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete_covariates</code></td>
<td>
<p>character, discrete covariates to use for the
surface. Note that discrete covariates are currently assumed to be one-hot
encoded with columns named <code style="white-space: pre;">⁠{fct_nm}_{lvl_nm}⁠</code>. Names supplied to
discrete_covariates should match <code>fct_nm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate_variance</code></td>
<td>
<p>boolean, If <code>TRUE</code>, the variance of CATE estimates
is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>list, points in which to predict CATE along continuous
covariates. Index i in the list should contain a numeric vectors with
either a single integer, specifying the number of equally spaced points
within the range of the i'th continuous covariate in which to calculate the
CATE, or a numeric vector with manually specified points in which to
calculate the CATE along the i'th continuous covariate. If all elements of
grid specify a number of points, this can be supplied using a numeric
vector. If the list is named, the names must match the continuous
covariates. grid will be reordered to match the order of
continuous_covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_covariate_fct</code></td>
<td>
<p>Function applied to covariates not in the
sub-surface which returns the fixed value of the covariate used to
calculate the CATE. Must be specified in one of the following ways:
</p>

<ul>
<li>
<p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li>
<p> An anonymous function, e.g. <code>\(x) x + 1</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li>
<p> A formula, e.g. <code>~ .x + 1</code>. You must use <code>.x</code> to refer to the
first argument. Only recommended if you require backward compatibility with
older versions of R.
</p>
</li>
<li>
<p> A string, integer, or list, e.g. <code>"idx"</code>, <code>1</code>, or <code>list("idx", 1)</code> which
are shorthand for <code>\(x) purrr::pluck(x, "idx")</code>, <code>\(x)
  purrr::pluck(x, 1)</code>, and <code>\(x) purrr::pluck(x, "idx", 1)</code>
respectively. Optionally supply <code>.default</code> to set a default value if the
indexed element is <code>NULL</code> or does not exist.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>other_discrete</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or
a lazy data frame (e.g. from dbplyr or dtplyr) with columns <code>covs</code> and
<code>lvl</code>. Used to specify the level of each discrete covariate to use when
calculating the CATE. assumes the use of one-hot encoding. <code>covs</code> must
contain the name of discrete covariates, and <code>lvl</code> the level to use. Set to
<code>NULL</code> if none of the fixed covariates are discrete using one-hot-encoding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_predict_size</code></td>
<td>
<p>integer, maximum number of examples to predict at a
time. If the surface has more points than max_predict_size, the prediction
is split up into an appropriate number of chunks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_threads</code></td>
<td>
<p>Number of threads used in training. If set to <code>NULL</code>, the
software automatically selects an appropriate amount.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Tibble with the predicted CATE's on the specified surface in the
covariate space. The tibble has columns for each covariate used to train
the input forest, as well as columns output from
predict.causal_forest().
</p>


<h3>Author(s)</h3>

<p>KIJA
</p>


<h3>Examples</h3>

<pre><code class="language-R">
n &lt;- 1000
p &lt;- 3
X &lt;- matrix(rnorm(n * p), n, p) |&gt; as.data.frame()
X_d &lt;- data.frame(
  X_d1 = factor(sample(1:3, n, replace = TRUE)),
  X_d2 = factor(sample(1:3, n, replace = TRUE))
)
X_d &lt;- DiscreteCovariatesToOneHot(X_d)
X &lt;- cbind(X, X_d)
W &lt;- rbinom(n, 1, 0.5)
event_prob &lt;- 1 / (1 + exp(2 * (pmax(2 * X[, 1], 0) * W - X[, 2])))
Y &lt;- rbinom(n, 1, event_prob)
cf &lt;- grf::causal_forest(X, Y, W)
cate_surface &lt;- CATESurface(
  cf,
  continuous_covariates = paste0("V", 1:2),
  discrete_covariates = "X_d1",
  grid = list(
    V1 = 10,
    V2 = -5:5
  ),
  other_discrete = data.frame(
    covs = "X_d2",
    lvl = "4"
  )
)


</code></pre>


</div>