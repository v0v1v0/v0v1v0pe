<div class="container">

<table style="width: 100%;"><tr>
<td>ELHMC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Empirical Likelihood Hamiltonian Monte Carlo Sampling</h2>

<h3>Description</h3>

<p>This function draws samples from a Empirical Likelihood Bayesian posterior
distribution of parameters using Hamiltonian Monte Carlo.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ELHMC(
  initial,
  data,
  fun,
  dfun,
  prior,
  dprior,
  n.samples = 100,
  lf.steps = 10,
  epsilon = 0.05,
  p.variance = 1,
  tol = 10^-5,
  detailed = FALSE,
  print.interval = 1000,
  plot.interval = 0,
  which.plot = NULL,
  FUN,
  DFUN
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>a vector containing the initial values of the parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix containing the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>the estimating function <code class="reqn">g</code>. It takes in a parameter vector
<code>params</code> as the first argument and a data point vector <code>x</code> as the
second parameter. This function returns a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfun</code></td>
<td>
<p>a function that calculates the gradient of the estimating function
<code class="reqn">g</code>. It takes in a parameter vector <code>params</code> as the first argument
and a data point vector <code>x</code> as the second argument. This function
returns a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>a function with one argument <code>x</code> that returns the prior
densities of the parameters of interest</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dprior</code></td>
<td>
<p>a function with one argument <code>x</code> that returns
the gradients of the log densities of the parameters of interest</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.samples</code></td>
<td>
<p>number of samples to draw</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lf.steps</code></td>
<td>
<p>number of leap frog steps in each Hamiltonian Monte Carlo
update</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>the leap frog step size(s). This has to be a single numeric
value or a vector of the same length as <code>initial</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.variance</code></td>
<td>
<p>the covariance matrix of a multivariate normal distribution
used to generate the initial values of momentum <code class="reqn">p</code> in
Hamiltonian Monte Carlo. This can also be a single numeric value or
a vector. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>EL tolerance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detailed</code></td>
<td>
<p>If this is set to <code>TRUE</code>, the function will return a list
with extra information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.interval</code></td>
<td>
<p>the frequency at which the results would be printed on the terminal. Defaults to 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.interval</code></td>
<td>
<p>the frequency at which the drawn samples would be plotted. The last half of the samples drawn are plotted after 
each plot.interval steps.  The acceptance rate is also plotted. Defaults to 0, which means no plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.plot</code></td>
<td>
<p>the vector of parameters to be plotted after each plot.interval. Defaults to NULL, which means no plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>the same as <code>fun</code> but takes in a matrix <code>X</code> instead of
a vector <code>x</code> and returns a matrix so that <code>FUN(params, X)[i, ]</code> is
the same as <code>fun(params, X[i, ])</code>. Only one of <code>FUN</code> and
<code>fun</code> should be provided. If both are then <code>fun</code> is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DFUN</code></td>
<td>
<p>the same as <code>dfun</code> but takes in a matrix <code>X</code> instead of
a vector <code>x</code> and returns an array so that <code>DFUN(params, X)[, , i]</code>
is the same as <code>dfun(params, X[i, ])</code>. Only one of <code>DFUN</code> and
<code>dfun</code> should be provided. If both are then <code>dfun</code> is ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Suppose there are data <code class="reqn">x = (x_1, x_2, ..., x_n)</code> where <code class="reqn">x_i</code>
takes values in <code class="reqn">R^p</code> and follow probability distribution <code class="reqn">F</code>.
Also, <code class="reqn">F</code> comes from a family of distributions that depends on
a parameter <code class="reqn">\theta = (\theta_1, ..., \theta_d)</code> and there is
a smooth function
<code class="reqn">g(x_i, \theta) = (g_1(x_i, \theta), ...,g_q(x_i, \theta))^T</code> that
satisfies <code class="reqn">E_F[g(x_i, \theta)] = 0</code> for <code class="reqn">i = 1, ...,n</code>.
</p>
<p><code>ELHMC</code> draws samples from a Empirical Likelihood Bayesian
posterior distribution of the parameter <code class="reqn">\theta</code>, given the data <code class="reqn">x</code>
as <code>data</code>, the smoothing function <code class="reqn">g</code> as <code>fun</code>,
and the gradient of <code class="reqn">g</code> as <code>dfun</code> or <code class="reqn">G(X) =
 (g(x_1), g(x_2), ..., g(x_n))^T</code> as <code>FUN</code> and the gradient of <code class="reqn">G</code>
as <code>DFUN</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>samples</code></td>
<td>
<p>A matrix containing the parameter samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance.rate</code></td>
<td>
<p>The acceptance rate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call</p>
</td>
</tr>
</table>
<p>If <code>detailed = TRUE</code>, the list contains these extra elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>proposed</code></td>
<td>
<p>A matrix containing the proposed values at
<code>n.samaples - 1</code> Hamiltonian Monte Carlo updates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance</code></td>
<td>
<p>A vector of <code>TRUE</code>/<code>FALSE</code> values
indicates whether each proposed value is accepted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trajectory</code></td>
<td>
<p>A list with 2 elements <code>trajectory.q</code> and
<code>trajectory.p</code>. These are lists of matrices contraining position and
momentum values along trajectory in each Hamiltonian Monte Carlo update.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Chaudhuri, S., Mondal, D. and Yin, T. (2017)
Hamiltonian Monte Carlo sampling in Bayesian empirical likelihood
computation.
<em>Journal of the Royal Statistical Society: Series B</em>.
</p>
<p>Neal, R. (2011) MCMC for using Hamiltonian dynamics.
<em>Handbook of Markov Chain Monte Carlo</em>
(eds S. Brooks, A.Gelman, G. L.Jones and X.-L. Meng), pp. 113-162.
New York: Taylor and Francis.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Suppose there are four data points (1, 1), (1, -1), (-1, -1), (-1, 1)
x = rbind(c(1, 1), c(1, -1), c(-1, -1), c(-1, 1))
## If the parameter of interest is the mean, the smoothing function and
## its gradient would be
f &lt;- function(params, x) {
 x - params
}
df &lt;- function(params, x) {
 rbind(c(-1, 0), c(0, -1))
}
## Draw 50 samples from the Empirical Likelihood Bayesian posterior distribution
## of the mean, using initial values (0.96, 0.97) and standard normal distributions
## as priors:
normal_prior &lt;- function(x) {
   exp(-0.5 * x[1] ^ 2) / sqrt(2 * pi) * exp(-0.5 * x[2] ^ 2) / sqrt(2 * pi)
}
normal_prior_log_gradient &lt;- function(x) {
   -x
}
set.seed(1234)
mean.samples &lt;- ELHMC(initial = c(0.96, 0.97), data = x, fun = f, dfun = df,
                     n.samples = 50, prior = normal_prior,
                     dprior = normal_prior_log_gradient)
plot(mean.samples$samples, type = "l", xlab = "", ylab = "")

## End(Not run)
</code></pre>


</div>