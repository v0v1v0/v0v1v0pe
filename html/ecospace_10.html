<div class="container">

<table style="width: 100%;"><tr>
<td>rbind_listdf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Combine Large Lists of Data Frames.</h2>

<h3>Description</h3>

<p>Quickly combine large lists of dataframes into a single data frame by
combining them first into smaller data frames. This is only time- and
memory-efficient when dealing with large (&gt;100) lists of data frames.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rbind_listdf(lists = NULL, seq.by = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lists</code></td>
<td>
<p>List in which each component is a data frame. Each data frame
must have the same number and types of columns, although the data frames
can have different numbers of rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seq.by</code></td>
<td>
<p>Length of small data frames to work with at a time. Default is
100, which timing tests confirm is generally most efficient.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Rather than combine all list data frames into a single data frame,
this function builds smaller subsets of data frames, and then combines them
together at the end. This process is more time- and memory-efficient.
Timing tests confirm that seq.by = 100 is the optimal break-point size. See
examples for confirmation. Function can break large lists into up to
456,976 data frame subparts, giving a warning if requires more subparts.
Only time- and memory-efficient when dealing with large (&gt;100) lists of
data frames.
</p>


<h3>Value</h3>

<p>Single data frame with number of rows equal to the sum of all data
frames in the list, and columns the same as those of individual list data
frames.
</p>


<h3>Note</h3>

<p>When called within <code>lapply</code>, the simulation functions
<code>neutral</code>, <code>redundancy</code>, <code>partitioning</code>, <code>expansion</code>,
and <code>calc_metrics</code>, which calculates common ecological disparity
(functional diversity) statistics on simulated biotas, produce lists of
data frames. This function is useful for combining these separate lists
into a single data frame for subsequent analyses. This is especially useful
when using the functions within a high-performance computing environment
when submitted as 'embarrassingly parallel' implementations.
<code>rbindlist</code> is a more efficient version of this
function.
</p>


<h3>See Also</h3>

<p><code>neutral</code>, <code>redundancy</code>,
<code>partitioning</code>, <code>expansion</code>,
<code>calc_metrics</code>, and <code>rbindlist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">nl &lt;- 500     # List length
lists &lt;- vector("list", length = nl)
for(i in 1:nl) lists[[i]] &lt;- list(x = rnorm(100), y = rnorm(100))
str(lists)
object.size(lists)
all &lt;- rbind_listdf(lists)
str(all)
object.size(all)       # Also smaller object size

# Build blank ecospace framework to use in simulations
ecospace &lt;- create_ecospace(nchar = 15, char.state = rep(3, 15),
                            char.type = rep("numeric", 15))

# Build 5 samples for neutral model:
nreps &lt;- 1:5
Smax &lt;- 10
n.samples &lt;- lapply(X = nreps, FUN = neutral, Sseed = 3, Smax = Smax, ecospace)

# Calculate functional diversity metrics for simulated samples
n.metrics &lt;- lapply(X = nreps, FUN = calc_metrics, samples = n.samples,
                    Model = "neutral", Param = "NA")
alarm()
str(n.metrics)

# rbind lists together into a single dataframe
all &lt;- rbind_listdf(n.metrics)

# Calculate mean dynamics
means &lt;- n.metrics[[1]]
for(n in 1:Smax) means[n,4:11] &lt;- apply(all[which(all$S == means$S[n]),4:11],
                                        2, mean, na.rm = TRUE)
means

# Plot statistics as function of species richness, overlaying mean dynamics
op &lt;- par()
par(mfrow = c(2,4), mar = c(4, 4, 1, .3))
attach(all)

plot(S, H, type = "p", cex = .75, col = "gray")
lines(means$S, means$H, type = "l", lwd = 2)
plot(S, D, type = "p", cex = .75, col = "gray")
lines(means$S, means$D, type = "l", lwd = 2)
plot(S, M, type = "p", cex = .75, col = "gray")
lines(means$S, means$M, type = "l", lwd = 2)
plot(S, V, type = "p", cex = .75, col = "gray")
lines(means$S, means$V, type = "l", lwd = 2)
plot(S, FRic, type = "p", cex = .75, col = "gray")
lines(means$S, means$FRic, type = "l", lwd = 2)
plot(S, FEve, type = "p", cex = .75, col = "gray")
lines(means$S, means$FEve, type = "l", lwd = 2)
plot(S, FDiv, type = "p", cex = .75, col = "gray")
lines(means$S, means$FDiv, type = "l", lwd = 2)
plot(S, FDis, type = "p", cex = .75, col = "gray")
lines(means$S, means$FDis, type = "l", lwd = 2)

par(op)

## Not run: 
# Note each of following can take a few seconds to run
# Compare timings:
t0 &lt;- Sys.time()
all &lt;- rbind_listdf(lists)
(Sys.time() - t0)

t0 &lt;- Sys.time()
all &lt;- rbind_listdf(lists, seq.by = 20)
(Sys.time() - t0)

t0 &lt;- Sys.time()
all &lt;- rbind_listdf(lists, seq.by = 500)
(Sys.time() - t0)

# Compare to non-function version
all2 &lt;- data.frame()
t0 &lt;- Sys.time()
for(i in 1:nl) all2 &lt;- rbind(all2, lists[[i]])
(Sys.time() - t0)

## End(Not run)

# Compare to data.table's 'rbindlist' version
library(data.table)
t0 &lt;- Sys.time()
all &lt;- rbindlist(lists)
(Sys.time() - t0)

</code></pre>


</div>