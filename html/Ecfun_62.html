<div class="container">

<table style="width: 100%;"><tr>
<td>qqnorm2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Normal Probability Plot with Multiple Symbols
</h2>

<h3>Description</h3>

<p>Create a normal probability plot with one 
line and different symbols for the values of 
another variable, <code>z</code>.  
</p>
<p><code>qqnorm2</code> produces an object of class 
<code>qqnorm2</code>, whose plot method produces 
the plot.
</p>
<p>To create a normal normal probability plots 
with multiple lines, see <code>qqnorm2t</code> 
or <code>qqnorm2s:x</code>.  
</p>

<ul>
<li> <p><code>qqnorm2s</code> produces a plot 
with multiple lines specified either by 
different names in a character vector 
<code>y</code> or by different 
<code>data.frame</code>s in a list 
<code>data.</code>, with different points labeled 
according to the different levels of <code>z</code>.  
</p>
</li>
<li> <p><code>qqnorm2t</code> produces a plot 
with multiple lines with <code>y</code> split on 
different levels of <code>x</code>, optionally 
with different points labeled according to 
different levels of <code>z</code>.  
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">qqnorm2(y, z, plot.it=TRUE, datax=TRUE, pch=NULL, 
        ...)
## S3 method for class 'qqnorm2'
plot(x, y, ...)
## S3 method for class 'qqnorm2'
lines(x, ...)
## S3 method for class 'qqnorm2'
points(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>For <code>qnorm2</code>, <code>y</code> is a numeric 
vector for which a normal probability plot is 
desired.
</p>
<p>For <code>plot.qqnorm2</code>, <code>y</code> is ignored;  
it is included, because the generic 
<code>plot</code> function requires it.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>

<p>A variable to indicate different plotting 
symbols.
</p>
<p>NOTE:  <code>is.logical(z)</code> is replaced by 
<code>z &lt;- as.character(z)</code>. 
</p>
<p>Otherwise, <code>pch[z]</code> would delete symbols 
in <code>pch</code> for which <code>z</code> is 
<code>FALSE</code> and would recycle the remaining 
symbols.  That would rarely be what we want.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.it</code></td>
<td>

<p>logical:  Should the result be plotted?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>datax</code></td>
<td>

<p>The <code>datax</code> argument of 
<code>qqnorm</code>:  If <code>TRUE</code>, the
data are displayed on the horizontal rather 
than the vertical axis.  (The default value 
for <code>datax</code> is the opposite of that for
<code>qqnorm</code>.)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>an object of class <code>qqnorm2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch</code></td>
<td>

<p>a named vector of the plotting symbols to 
be used with names corresponding to the 
levels of z.  If <code>pch</code> is provided, 
it must either have names corresponding to 
levels of <code>z</code>, or <code>z</code> must be 
integers between 1 and <code>length(pch)</code>.
</p>
<p>Otherwise, if <code>z</code> takes levels 
<code>FALSE</code> and <code>TRUE</code> (or 0 and 1), 
<code>pch=c(4, 1)</code> to plot an "x" for 
<code>FALSE</code> and "o" for <code>TRUE</code>.
</p>
<p>Or if <code>z</code> assumes integer values 
between 0 and 255, by default, the symbols 
are chosen as described with 
<code>points</code>.
</p>
<p>NOTE:  *** <code>points.qqnorm2</code> may not 
work properly for <code>z</code> being integer 
between 0 and 255.  <code>lines.qqnorm2</code> 
is more likely to work in such 
cases.  *** No time to fix this as of 
2018-01-20.  
</p>
<p>Otherwise, by default, <code>z</code> is 
coerced to <code>character</code>, and 
the result is plotted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Optional arguments.
</p>
<p>For <code>plot.qqnorm2</code>, they are passed 
to <code>plot</code>.
</p>
<p>For <code>qqnorm2</code>, they are passed to 
<code>qqnorm</code> and to 
<code>plot.qqnorm2</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code>qqnorm2</code>:
</p>
<p><code>qq1.  q2 &lt;- qqnorm(y, datax=datax, ...)</code>
</p>
<p><code>qq2.  q2[["z"]] &lt;- z</code>
</p>
<p><code>qq3.  q2[["pch"]]</code> gets whatever 
<code>pch</code> decodes to.
</p>
<p><code>qq4</code>.  Silently 
<code>return(list(x, y, z, pch, ...))</code>, where 
<code>x</code> and <code>y</code> are as returned by 
<code>qqnorm</code> in step 1 above.  If 
<code>pch</code> is not provided and <code>z</code> is not 
logical or positive integers, then <code>z</code> 
itself will be plotted and <code>pch</code> will not be
in the returned list.  
</p>
<p>For <code>plot.qqnorm2</code>:  
</p>
<p><code>plot1.  plot(x\$x, x\$y, type="n", ...)</code> 
with <code>...</code> taking precedence over <code>x</code>, 
where the same plot argument appears in both.  
</p>
<p><code>plot2.  if(type %in% 
  c('l', 'b', 'c', 'o'))
  lines(x\$x, x\$y, ...)</code>
</p>
<p><code>plot3.  if(type %in% c('p', 'b', 'o')): 
  if(is.null(x\$z))points(x\$x, x\$y, ...)
  else if(is.logical(x\$z))
         points(x\$x, x\$y, pch=x\$pch[x\$z], ...)
  else if(is.numeric(x\$z) &amp;&amp; 
     (min(z0 &lt;- round(x\$z))&gt;0) &amp;&amp; 
     (max(abs(x\$z-z0))&lt;10*.Machine\$double.eps))
  points(x\$x, x\$y, pch=x\$pch[x\$z], ...)
  else text(x\$x, x\$y, x\$z, ...)</code>
</p>
<p>For <code>lines.qqnorm2</code>
<code>lines1.  
  if(type != 'p')lines(x$x, x$y, ...)</code>;  
</p>
<p><code>lines2.  if(type %in% 
        c('p', 'b', 'o'))
  if(is.null(pch))text(x\$x, x\$y, x\$z, ...)
  else if(is.character(pch))
      text(x\$x, x\$y, x\$pch[x\$z], ...) 
  else points(x\$x, x\$y, pch=x\$pch[x\$z], ...)</code>
</p>
<p>For <code>points.qqnorm2</code>
<code>points1.  
  if(type %in% c('p', 'b', 'o'))
  if(is.null(pch))text(x\$x, x\$y, x\$z, ...)
  else if(is.character(pch))
        text(x\$x, x\$y, x\$pch[x\$z], ...) 
  else points(x\$x, x\$y, pch=x\$pch[x\$z], ...)</code>
</p>
<p><code>points2.  if(!(type %in% c('p', 'n')))
  lines(x$x, x$y, ...)</code>
</p>


<h3>Value</h3>

<p><code>qqnorm2</code> returns a list with 
components, <code>x, y, z</code>, and <code>pch</code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code>qqnorm</code>, <code>qqnorm2s</code>, 
<code>qqnorm2t</code>
<code>plot</code>
<code>points</code>
<code>lines</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##
## a simple test data.frame to illustrate the plot
## but too small to illustrate qqnorm concepts
##
tstDF &lt;- data.frame(y=1:3, z1=1:3, z2=c(TRUE, TRUE, FALSE),
                    z3=c('tell', 'me', 'why'), z4=c(1, 2.4, 3.69) )
# plotting symbols circle, triangle, and "+"
qn1 &lt;- with(tstDF, qqnorm2(y, z1))

# plotting symbols "x" and "o"
qn2 &lt;- with(tstDF, qqnorm2(y, z2))

# plotting with "-" and "+"
qn. &lt;- with(tstDF, qqnorm2(y, z2, pch=c('FALSE'='-', 'TRUE'='+')))

# plotting with "tell", "me", "why"
qn3 &lt;- with(tstDF, qqnorm2(y, z3))

# plotting with the numeric values
qn4 &lt;- with(tstDF, qqnorm2(y, z4))

##
## test plot, lines, points
##
plot(qn4, type='n') # establish the scales
lines(qn4)          # add a line
points(qn4)         # add points

##
## Check the objects created above
##
# check qn1
qn1. &lt;- qqnorm(1:3, datax=TRUE, plot.it=FALSE)
qn1.$xlab &lt;- 'y'
qn1.$ylab &lt;- 'Normal scores'
qn1.$z &lt;- tstDF$z1
qn1.$pch &lt;- 1:3
names(qn1.$pch) &lt;- 1:3
qn11 &lt;- qn1.[c(3:4, 1:2, 5:6)]
class(qn11) &lt;- 'qqnorm2'

all.equal(qn1, qn11)


# check qn2
qn2. &lt;- qqnorm(1:3, datax=TRUE, plot.it=FALSE)
qn2.$xlab &lt;- 'y'
qn2.$ylab &lt;- 'Normal scores'
qn2.$z &lt;- tstDF$z2
qn2.$pch &lt;- c('FALSE'=4, 'TRUE'=1)
qn22 &lt;- qn2.[c(3:4, 1:2, 5:6)]
class(qn22) &lt;- 'qqnorm2'

all.equal(qn2, qn22)


# check qn.
qn.. &lt;- qqnorm(1:3, datax=TRUE, plot.it=FALSE)
qn..$xlab &lt;- 'y'
qn..$ylab &lt;- 'Normal scores'
qn..$z &lt;- tstDF$z2
qn..$pch &lt;- c('FALSE'='-', 'TRUE'='+')
qn.2 &lt;- qn..[c(3:4, 1:2, 5:6)]
class(qn.2) &lt;- 'qqnorm2'

all.equal(qn., qn.2)


# check qn3
qn3. &lt;- qqnorm(1:3, datax=TRUE, plot.it=FALSE)
qn3.$xlab &lt;- 'y'
qn3.$ylab &lt;- 'Normal scores'
qn3.$z &lt;- as.character(tstDF$z3)
qn3.$pch &lt;- as.character(tstDF$z3)
names(qn3.$pch) &lt;- qn3.$pch
qn33 &lt;- qn3.[c(3:4, 1:2, 5:6)]
class(qn33) &lt;- 'qqnorm2'

all.equal(qn3, qn33)


# check qn4
qn4. &lt;- qqnorm(1:3, datax=TRUE, plot.it=FALSE)
qn4.$xlab &lt;- 'y'
qn4.$ylab &lt;- 'Normal scores'
qn4.$z &lt;- tstDF$z4
qn44 &lt;- qn4.[c(3:4, 1:2, 5)]
qn44$pch &lt;- NULL
class(qn44) &lt;- 'qqnorm2'

all.equal(qn4, qn44)


##
## Test lines(qn4) without z
##
#  just as a test, so this code can be used 
#  in other contexts
qn4. &lt;- qn4
qn4.$z &lt;- NULL
plot(qn4.)


</code></pre>


</div>