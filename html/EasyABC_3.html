<div class="container">

<table style="width: 100%;"><tr>
<td>ABC_mcmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Coupled to MCMC schemes for ABC
</h2>

<h3>Description</h3>

<p>This function implements three different algorithms to perform coupled to MCMC ABC.
</p>


<h3>Usage</h3>

<pre><code class="language-R">	ABC_mcmc(method, model, prior, summary_stat_target, prior_test=NULL, n_rec=100,
	n_between_sampling=10,	n_cluster = 1, use_seed = FALSE, verbose = FALSE,
	dist_weights=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>a character string indicating the ABC-MCMC algorithm to be used. Possible values are <code>"Marjoram_original"</code>, <code>"Marjoram"</code> and <code>"Wegmann"</code>.
Note that the method <code>"Marjoram_original"</code> cannot be used with multiple cores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>a <code>R</code> function implementing the model to be simulated. It must take as arguments a vector of model parameter values and it must return a vector of summary statistics. When using the option <code>use_seed=TRUE</code>, <code>model</code> must take as arguments a vector containing a seed value and the model parameter values.
A tutorial is provided in the package's vignette to dynamically link a binary code to a <code>R</code> function.  Users may alternatively wish to wrap their binary executables using the provided functions <code>binary_model</code> and <code>binary_model_cluster</code>. The use of these functions is associated with slightly different constraints on the design of the binary code (see <code>binary_model</code> and <code>binary_model_cluster</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>

<p>a list of prior information. Each element of the list corresponds to a model parameter. The list element must be a vector whose first argument determines the type of prior distribution: possible values are <code>"unif"</code> for a uniform distribution on a segment, <code>"normal"</code> for a normal distribution, <code>"lognormal"</code> for a lognormal distribution or <code>"exponential"</code> for an exponential distribution.
The following arguments of the list elements contain the characteritiscs of the prior distribution chosen: for <code>"unif"</code>, two numbers must be given: the minimum and maximum values of the uniform distribution; for <code>"normal"</code>, two numbers must be given: the mean and standard deviation of the normal distribution; for <code>"lognormal"</code>, two numbers must be given: the mean and standard deviation on the log scale of the lognormal distribution; for <code>"exponential"</code>, one number must be given: the rate of the exponential distribution. User-defined prior distributions can also be provided. See the vignette for additional information on this topic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary_stat_target</code></td>
<td>

<p>a vector containing the targeted (observed) summary statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior_test</code></td>
<td>

<p>a string expressing the constraints between model parameters.
This expression will be evaluated as a logical expression, you can use all the logical operators including <code>"&lt;"</code>, <code>"&gt;"</code>, ...
Each parameter should be designated with <code>"X1"</code>, <code>"X2"</code>, ... in the same order as in the prior definition.
If not provided, no constraint will be applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_rec</code></td>
<td>

<p>a positive integer equal to the desired number of sampled points along the MCMC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_between_sampling</code></td>
<td>

<p>a positive integer equal to the desired spacing between sampled points along the MCMC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cluster</code></td>
<td>

<p>a positive integer. If larger than 1 (the default value), <code>ABC_mcmc</code> will launch <code>model</code> simulations in parallel on <code>n_cluster</code> cores of the computer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_seed</code></td>
<td>

<p>logical. If <code>FALSE</code> (default), <code>ABC_mcmc</code> provides as input to the function <code>model</code> a vector containing the model parameters used for the simulation.
If <code>TRUE</code>, <code>ABC_mcmc</code> provides as input to the function <code>model</code> a vector containing an integer seed value and the model parameters used for the simulation.
In this last case, the seed value should be used by <code>model</code> to initialize its pseudo-random number generators (if <code>model</code> is stochastic).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>logical. <code>FALSE</code> by default. If <code>TRUE</code>, <code>ABC_mcmc</code> writes in the current directory intermediary results at the end of each step of the algorithm in the file "output_mcmc".
These outputs have a matrix format, in wich each raw is a different simulation, the first columns are the parameters used for this simulation, the following columns are the summary statistics of this simulation, and the last column is the distance between the simulation and the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist_weights</code></td>
<td>

<p>a vector containing the weights to apply to the distance between the computed and the targeted statistics.
These weights can be used to give more importance to a summary statistisc for example. The weights will
be normalized before applying them. If not provided, no weights will be applied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments can be passed depending on the choosen method (see below)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See the package's vignette for details on ABC-MCMC.
</p>


<h3>Value</h3>

<p>The returned value is a list containing the following components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>

<p>The model parameters used in the <code>model</code> simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stats</code></td>
<td>

<p>The summary statistics obtained at the end of the <code>model</code> simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>

<p>The distance of the simulations to the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stats_normalization</code></td>
<td>

<p>The standard deviation of the summary statistics across the <code>model</code> simulations of the initial step.
These values are used to normalize the summary statistics before the computation of the Euclidean distance between simulations and data.
If <code>method</code> is <code>"Marjoram_original"</code>, this is equal to <code>tab_normalization</code>.
If <code>method</code> is <code>"Wegmann"</code>, this is not provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>

<p>The final maximal distance between simulations and data in the retained sample of particles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>

<p>The number of <code>model</code> simulations performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_between_sampling</code></td>
<td>

<p>The spacing between two sampled points in the MCMC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>computime</code></td>
<td>

<p>The computing time to perform the simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_stats</code></td>
<td>

<p>The minimal values of each summary statistics during the calibration step, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_stats</code></td>
<td>

<p>The maximal values of each summary statistics during the calibration step, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>The lambda values of the Box-Cox transformation, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geometric_mean</code></td>
<td>

<p>The geometric means, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boxcox_mean</code></td>
<td>

<p>The means of Box-Cox transforms, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boxcox_sd</code></td>
<td>

<p>The standard deviations of Box-Cox transforms, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pls_transform</code></td>
<td>

<p>The matrix of PLS transformation, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numcomp</code></td>
<td>

<p>The number of used components for the PLS transformation, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td>
</tr>
</table>
<h3>Additional parameters</h3>

<p>Depending on the choosen method, you can specify the following arguments:
</p>

<dl>
<dt>dist_max</dt>
<dd>
<p>a positive number, used when <code>method</code> is <code>"Marjoram_original"</code>.
This is the tolerance threshold used during the MCMC.
If not provided by the user, it is automatically computed as half the distance between the first simulation and the target summary statistics and a warning is printed.</p>
</dd>
<dt>tab_normalization</dt>
<dd>
<p>a vector of the same length as <code>summary_stat_target</code>, used when <code>method</code> is <code>"Marjoram_original"</code>.
Each element contains a positive number by which each summary statistics must be divided before the computation of the Euclidean distance between simulations and data.
If not provided by the user, the simulated summary statistics are divided by the target summary statistics and a warning is printed.</p>
</dd>
<dt>proposal_range</dt>
<dd>
<p>a vector of the same length as the number of model parameters, used when <code>method</code> is <code>"Marjoram_original"</code>.
Each element contains a positive number defining the range of MCMC jumps for each model parameter.
If not provided by the user, a default value is used for each parameter and a warning is printed. The default value is 1/50 of the prior range for uniform distributions, 1/20 of the standard deviation of the prior distribution for normal distributions, 1/20 * exp ( sigma * sigma </p>
</dd>
</dl>
<p> for lognormal distributions where sigma is the standard deviation of the prior distribution in the log scale, and 1/20 of the inverse of the rate for exponential distributions.
</p>
<dl>
<dt>n_calibration</dt>
<dd>
<p>a positive integer, used when <code>method</code> is <code>"Marjoram"</code> or <code>"Wegmann"</code>.
This is the number of simulations performed during the calibration step.
Default value is 10000.</p>
</dd>
<dt>tolerance_quantile</dt>
<dd>
<p>a positive number between 0 and 1 (strictly), used when <code>method</code> is <code>"Marjoram"</code> or <code>"Wegmann"</code>.
This is the percentage of simulations retained during the calibration step to determine the tolerance threshold to be used during the MCMC.
Default value is 0.01.</p>
</dd>
<dt>proposal_phi</dt>
<dd>
<p>a positive number, used when <code>method</code> is <code>"Marjoram"</code> or <code>"Wegmann"</code>.
This is a scaling factor defining the range of MCMC jumps.
Default value is 1.</p>
</dd>
<dt>numcomp</dt>
<dd>
<p>a positive integer, used when <code>method</code> is <code>"Wegmann"</code>.
This is the number of components to be used for PLS transformations.
Default value is 0 which encodes that this number is equal to the number of summary statistics.</p>
</dd>
<dt>seed_count</dt>
<dd>
<p>a positive integer, the initial seed value provided to the function <code>model</code> (if <code>use_seed=TRUE</code>). This value is incremented by 1 at each call of the function <code>model</code>.</p>
</dd>
<dt>progress_bar</dt>
<dd>
<p>logical, <code>FALSE</code> by default. If <code>TRUE</code>, <code>ABC_mcmc</code> will output a bar of progression with the estimated remaining computing time. Option not available with multiple cores.
</p>
</dd>
<dt>max_pick</dt>
<dd>
<p>a positive number, the max number of fails when moving particle inside the prior. Enabled only if inside_prior is to <code>TRUE</code>.
<code>10000</code> by default.
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Franck Jabot, Thierry Faure and Nicolas Dumoulin</p>


<h3>References</h3>

<p>Marjoram, P., Molitor, J., Plagnol, V. and Tavar\'e, S. (2003) Markov chain Monte Carlo without likelihoods. <em>PNAS</em>, <b>100</b>, 15324–15328.
</p>
<p>Wegmann, D., Leuenberger, C. and Excoffier, L. (2009) Efficient approximate Bayesian computation coupled with Markov chain Monte Carlo without likelihood. <em>Genetics</em>, <b>182</b>, 1207-1218.
</p>


<h3>See Also</h3>

<p><code>binary_model</code>, <code>binary_model_cluster</code>, <code>ABC_rejection</code>, <code>ABC_emulation</code>, <code>ABC_sequential</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"> ## Not run:  
    ##### EXAMPLE 1 #####
    #####################

    ## the model has two parameters and outputs two summary statistics.
    ## defining a simple toy model:
    toy_model&lt;-function(x){ c( x[1] + x[2] + rnorm(1,0,0.1) , x[1] * x[2] + rnorm(1,0,0.1) ) }

    ## define prior information
    toy_prior=list(c("unif",0,1),c("normal",1,2))
    # a uniform prior distribution between 0 and 1 for parameter 1, and a normal distribution
    # of mean 1 and standard deviation of 2 for parameter 2.

    ## define the targeted summary statistics
    sum_stat_obs=c(1.5,0.5)

    ## to perform the Marjoram et al. (2003)'s method:
    ##
    ABC_Marjoram_original&lt;-ABC_mcmc(method="Marjoram_original", model=toy_model, prior=toy_prior,
      summary_stat_target=sum_stat_obs)
    ABC_Marjoram_original

    ## artificial example to perform the Marjoram et al. (2003)'s method, with modifications
    # drawn from Wegmann et al. (2009) without Box-Cox and PLS transformations.
    ##
    ABC_Marjoram&lt;-ABC_mcmc(method="Marjoram", model=toy_model, prior=toy_prior,
      summary_stat_target=sum_stat_obs)
    ABC_Marjoram


    ## artificial example to perform the Wegmann et al. (2009)'s method.
    ##
    ABC_Wegmann&lt;-ABC_mcmc(method="Wegmann", model=toy_model, prior=toy_prior,
      summary_stat_target=sum_stat_obs)
    ABC_Wegmann


    ##### EXAMPLE 2 #####
    #####################

    ## this time, the model is a C++ function packed into a R function -- this time,
    # the option 'use_seed' must be turned to TRUE.

    ## define prior information
    trait_prior=list(c("unif",3,5),c("unif",-2.3,1.6),c("unif",-25,125),c("unif",-0.7,3.2))
    trait_prior

    ## define the targeted summary statistics
    sum_stat_obs=c(100,2.5,20,30000)


    ## artificial example to perform the Marjoram et al. (2003)'s method.
    ##
    n=10
    ABC_Marjoram_original&lt;-ABC_mcmc(method="Marjoram_original", model=trait_model,
    prior=trait_prior, summary_stat_target=sum_stat_obs, n_rec=n, use_seed=TRUE)
    ABC_Marjoram_original

    ## artificial example to perform the Marjoram et al. (2003)'s method, with modifications
    # drawn from Wegmann et al. (2009) without Box-Cox and PLS transformations.
    ##
    n=10
    n_calib=10
    tol_quant=0.2 
    ABC_Marjoram&lt;-ABC_mcmc(method="Marjoram", model=trait_model, prior=trait_prior,
      summary_stat_target=sum_stat_obs, n_rec=n, n_calibration=n_calib,
      tolerance_quantile=tol_quant, use_seed=TRUE)
    ABC_Marjoram


    ## artificial example to perform the Wegmann et al. (2009)'s method.
    ##
    n=10
    n_calib=10
    tol_quant=0.2 
    ABC_Wegmann&lt;-ABC_mcmc(method="Wegmann", model=trait_model, prior=trait_prior,
        summary_stat_target=sum_stat_obs, n_rec=n, n_calibration=n_calib,
        tolerance_quantile=tol_quant, use_seed=TRUE)
    ABC_Wegmann
 
## End(Not run)
</code></pre>


</div>