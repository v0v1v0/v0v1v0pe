<div class="container">

<table style="width: 100%;"><tr>
<td>contourmap.inla</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Contour maps and contour map quality measures for latent Gaussian models</h2>

<h3>Description</h3>

<p>An interface to the <code>contourmap</code> function for latent Gaussian models
calculated using the INLA method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">contourmap.inla(
  result.inla,
  stack,
  name = NULL,
  tag = NULL,
  method = "QC",
  n.levels,
  type = c("standard", "pretty", "equalarea"),
  compute = list(F = TRUE, measures = NULL),
  alpha,
  F.limit,
  n.iter = 10000,
  verbose = FALSE,
  max.threads = 0,
  compressed = TRUE,
  seed = NULL,
  ind,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>result.inla</code></td>
<td>
<p>Result object from INLA call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stack</code></td>
<td>
<p>The stack object used in the INLA call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>The name of the component for which to do the calculation. This
argument should only be used if a stack object is not provided, use the tag
argument otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tag</code></td>
<td>
<p>The tag of the component in the stack for which to do the
calculation. This argument should only be used if a stack object is provided,
use the name argument otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method for handeling the latent Gaussian structure. Currently
only Empirical Bayes (EB) and Quantile corrections (QC) are supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.levels</code></td>
<td>
<p>Number of levels in contour map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of contour map. One of:
</p>

<dl>
<dt>'standard' </dt>
<dd>
<p>Equidistant levels between smallest and largest value
of the posterior mean (default).</p>
</dd>
<dt>'pretty' </dt>
<dd>
<p>Equally spaced 'round' values which cover the range of
the values in the posterior mean.</p>
</dd>
<dt>'equalarea' </dt>
<dd>
<p>Levels such that different spatial regions are
approximately equal in size.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute</code></td>
<td>
<p>A list with quality indices to compute
</p>

<dl>
<dt>'F': </dt>
<dd>
<p>TRUE/FALSE indicating whether the contour map function
should be computed (default TRUE)</p>
</dd>
<dt>'measures': </dt>
<dd>
<p>A list with the quality measures to compute ("P0",
"P1", "P2") or corresponding bounds based only on the marginal
probabilities ("P0-bound", "P1-bound", "P2-bound")</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Maximal error probability in contour map function (default=1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>F.limit</code></td>
<td>
<p>The limit value for the computation of the F function. F is
set to NA for all nodes where F&lt;1-F.limit. Default is F.limit = <code>alpha</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>Number or iterations in the MC sampler that is used for
calculating the quantities in <code>compute</code>. The default value is 10000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.threads</code></td>
<td>
<p>Decides the number of threads the program can use. Set to
0 for using the maximum number of threads allowed by the system (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compressed</code></td>
<td>
<p>If INLA is run in compressed mode and a part of the linear
predictor is to be used, then only add the relevant part. Otherwise the
entire linear predictor is added internally (default TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random seed (optional).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind</code></td>
<td>
<p>If only a part of a component should be used in the calculations,
this argument specifies the indices for that part (optional).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to the contour map function. See the
documentation for <code>contourmap</code> for details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The INLA approximation of the quantity of interest is in general a weighted
sum of Gaussian distributions with different parameters. If
<code>method = 'EB'</code> is used, then the contour map is computed for the mean
of the component in the weighted sum that has parameters with the highest
likelihood. If on the other hand <code>method='QC'</code>, then the contour map is
computed for the posterior mean reported by INLA. If the EB method also is
used in INLA, then this reported posterior mean is equal to the mean of the
component with the highest likelihood. Therefore, <code>method='EB'</code> is
appropriate if the EB method also is used in INLA, but <code>method='QC'</code>
should be used in general.
</p>
<p>The <code>n.levels</code> contours in the contour map are are placed according
to the argument <code>type</code>. A number of quality measures can be computed
based based on the specified contour map and the distribution of the
component of interest. What should be computed is specified using the
<code>compute</code> argument. For details on these quanties, see the reference
below.
</p>


<h3>Value</h3>

<p><code>contourmap.inla</code> returns an object of class "excurobj" with the
same elements as returned by <code>contourmap</code>.
</p>


<h3>Note</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN
package.  See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy
installation instructions.
</p>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin, D. and Lindgren, F. (2017) <em>Quantifying the
uncertainty of contour maps</em>, Journal of Computational and Graphical
Statistics, 26:3, 513-524.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion
Sets and Related Quantities Using excursions</em>, Journal of Statistical
Software, vol 86, no 1, pp 1-20.
</p>


<h3>See Also</h3>

<p><code>contourmap</code>, <code>contourmap.mc</code>,
<code>contourmap.colors</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
if (require.nowarnings("INLA")) {
  # Generate mesh and SPDE model
  n.lattice &lt;- 10 # increase for more interesting, but slower, examples
  x &lt;- seq(from = 0, to = 10, length.out = n.lattice)
  lattice &lt;- fmesher::fm_lattice_2d(x = x, y = x)
  mesh &lt;- fmesher::fm_rcdt_2d_inla(lattice = lattice, extend = FALSE, refine = FALSE)
  spde &lt;- inla.spde2.matern(mesh, alpha = 2)

  # Generate an artificial sample
  sigma2.e &lt;- 0.01
  n.obs &lt;- 100
  obs.loc &lt;- cbind(
    runif(n.obs) * diff(range(x)) + min(x),
    runif(n.obs) * diff(range(x)) + min(x)
  )
  Q &lt;- inla.spde2.precision(spde, theta = c(log(sqrt(0.5)), log(sqrt(1))))
  x &lt;- inla.qsample(Q = Q)
  A &lt;- fmesher::fm_basis(mesh = mesh, loc = obs.loc)
  Y &lt;- as.vector(A %*% x + rnorm(n.obs) * sqrt(sigma2.e))

  ## Estimate the parameters using INLA
  mesh.index &lt;- inla.spde.make.index(name = "field", n.spde = spde$n.spde)
  ef &lt;- list(c(mesh.index, list(Intercept = 1)))

  s.obs &lt;- inla.stack(data = list(y = Y), A = list(A), effects = ef, tag = "obs")
  s.pre &lt;- inla.stack(data = list(y = NA), A = list(1), effects = ef, tag = "pred")
  stack &lt;- inla.stack(s.obs, s.pre)
  formula &lt;- y ~ -1 + Intercept + f(field, model = spde)
  result &lt;- inla(
    formula = formula, family = "normal", data = inla.stack.data(stack),
    control.predictor = list(
      A = inla.stack.A(stack),
      compute = TRUE
    ),
    control.compute = list(
      config = TRUE,
      return.marginals.predictor = TRUE
    ),
    num.threads = 1
  )

  ## Calculate contour map with two levels
  map &lt;- contourmap.inla(result,
    stack = stack, tag = "pred",
    n.levels = 2, alpha = 0.1, F.limit = 0.1,
    max.threads = 1
  )

  ## Plot the results
  cols &lt;- contourmap.colors(map,
    col = heat.colors(100, 1),
    credible.col = grey(0.5, 1)
  )
  image(matrix(map$M[mesh$idx$lattice], n.lattice, n.lattice), col = cols)
}

## End(Not run)
</code></pre>


</div>