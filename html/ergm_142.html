<div class="container">

<table style="width: 100%;"><tr>
<td>rlebdm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>RLE-Compressed Boolean Dyad Matrix</h2>

<h3>Description</h3>

<p>A simple class representing boolean (logical) square matrix
run-length encoded in a column-major order.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rlebdm(x, n)

as.rlebdm(x, ...)

## S3 method for class 'matrix'
as.rlebdm(x, ...)

## S3 method for class 'edgelist'
as.rlebdm(x, ...)

## S3 method for class 'network'
as.rlebdm(x, ...)

## S3 method for class 'rlebdm'
as.matrix(x, ...)

## S3 method for class 'rlebdm'
dim(x)

## S3 method for class 'rlebdm'
print(x, compact = TRUE, ...)

## S3 method for class 'rlebdm'
Ops(e1, e2)

## S3 method for class 'rlebdm'
Math(x, ...)

## S3 method for class 'rlebdm'
compress(x, ...)

## S3 method for class 'rlebdm'
as.edgelist(x, prototype = NULL, ..., output = c("matrix", "tibble"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>for <code>rlebdm()</code>, an <code>rle()</code> object or a vector that is converted to one; it will be coerced to <code>logical()</code> before processing; for <code>as.rlebdm.matrix()</code>, a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the dimensions of the square matrix represented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments, currently unused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compact</code></td>
<td>
<p>whether to print the matrix compactly (dots and stars) or to print it as a logical matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e1, e2</code></td>
<td>
<p>arguments to the unary (<code>e1</code>) or the binary (<code>e1</code> and <code>e2</code>) operators.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prototype</code></td>
<td>
<p>an optional network with network attributes that
are transferred to the edgelist and will filter it (e.g., if the
prototype network is given and does not allow self-loops, the
edgelist will not have self-loops either,e ven if the dyad matrix
has non-<code>FALSE</code> diagonal).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>a string specifying whether the result should be a
matrix or a <code>tibble</code>.</p>
</td>
</tr>
</table>
<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>compress(rlebdm)</code>: Compress the <code>rle</code> data structure in the
<code>rlebdm</code> by merging successive runs with identical values.
</p>
</li>
<li> <p><code>as.edgelist(rlebdm)</code>: Convert an <code>rlebdm</code> object to an <code>edgelist</code>: a two-column
integer matrix or <code>tibble</code> giving the cells with <code>TRUE</code> values.
</p>
</li>
</ul>
<h3>Functions</h3>


<ul>
<li> <p><code>as.rlebdm(matrix)</code>: Convert a square matrix of mode coercible to <code>logical</code> to an
<code>rlebdm</code>.
</p>
</li>
<li> <p><code>as.rlebdm(edgelist)</code>: Convert an object of class <code>edgelist</code> to an <code>rlebdm</code> object
whose cells in the edge list are set to <code>TRUE</code> and whose other
cells are set to <code>FALSE</code>.
</p>
</li>
<li> <p><code>as.rlebdm(network)</code>: Convert an object of class <code>network</code> to an <code>rlebdm</code> object
whose cells corresponding to extant edges are set to <code>TRUE</code> and
whose other cells are set to <code>FALSE</code>.
</p>
</li>
</ul>
<h3>Note</h3>

<p>The arithmetic operators are mathematical functions are
implemented for the <code>Ops</code> and the <code>Math</code> group generics and
therefore work for almost all of them automatically. To preserve
the integrity of the data structure, the results are cast to
logical before return.
</p>


<h3>See Also</h3>

<p><code>as.rlebdm.ergm_conlist()</code>
</p>
<p><code>as.edgelist()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># From a vector
rlebdm(rep(rep(c(0,1),each=3),14)[seq_len(81)], 9)

# From a constant
rlebdm(1, 3)

# Large matrix (overflowing .Machine$integer.max)
big &lt;- rlebdm(1, 50000)
unclass(big) # Represented as two runs
stopifnot(length(big)==50000^2)

</code></pre>


</div>