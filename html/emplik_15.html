<div class="container">

<table style="width: 100%;"><tr>
<td>el.test.wt2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Weighted Empirical Likelihood ratio for mean(s), uncensored data</h2>

<h3>Description</h3>

<p>This program is similar to <code>el.test( )</code> except it takes weights.
</p>
<p>The mean constraints are:
</p>
<p style="text-align: center;"><code class="reqn"> \sum_{i=1}^n  p_i x_i  = \mu . </code>
</p>

<p>Where <code class="reqn">p_i = \Delta F(x_i)</code> is a probability.
Plus the probability constraint: <code class="reqn"> \sum p_i =1</code>.
</p>
<p>The weighted log empirical likelihood been maximized is
</p>
<p style="text-align: center;"><code class="reqn"> \sum_{i=1}^n w_i \log p_i. </code>
</p>
 


<h3>Usage</h3>

<pre><code class="language-R">el.test.wt2(x, wt, mu, maxit = 25, gradtol = 1e-07, Hessian = FALSE, 
    svdtol = 1e-09, itertrace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix (of size nxp) or vector containing the observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt</code></td>
<td>
<p>a vector of length n, containing the weights. If weights are 
all 1, this is very simila to el.test. wt have to be positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a vector of length p, used in the constraint. weighted
mean value of <code class="reqn">f(X)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>an integer, the maximum number of iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradtol</code></td>
<td>
<p>a positive real number, the tolerance for a solution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hessian</code></td>
<td>
<p>logical. if the Hessian needs to be computed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>svdtol</code></td>
<td>
<p> tolerance in perform SVD of the Hessian matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itertrace</code></td>
<td>
<p>TRUE/FALSE, if the intermediate steps needs to be printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function used to be an internal function. 
It becomes external because others may find it useful.
</p>
<p>It is similar to the function <code>el.test( )</code> with the
following differences: 
</p>
<p>(1) The output lambda in el.test.wts, when divided by n
(the sample size or sum of all the weights) should be equal to the
output lambda in el.test.
</p>
<p>(2) The Newton step of iteration in el.test.wts is different from
those in el.test. (even when all the weights are one).
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the Lagrange multiplier. Solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt</code></td>
<td>
<p>the vector of weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grad</code></td>
<td>
<p>The gradian at the final solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nits</code></td>
<td>
<p>number of iterations performed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>The probabilities that maximized the weighted 
empirical likelihood under mean constraint.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Mai Zhou </p>


<h3>References</h3>

<p>Owen, A. (1990). Empirical likelihood ratio confidence regions. 
<em>Ann. Statist.</em> <b>18</b>, 90-120.
</p>
<p>Zhou, M. (2005). Empirical likelihood ratio with arbitrary censored/truncated data by EM algorithm. 
<em>Journal of Computational and Graphical Statistics</em>, 
<b>14</b>, 643-656. 
</p>
<p>Zhou, M. (2002). 
Computing censored empirical likelihood ratio 
by EM algorithm. 
<em>Tech Report, Univ. of Kentucky, Dept of Statistics</em>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## example with tied observations
x &lt;- c(1, 1.5, 2, 3, 4, 5, 6, 5, 4, 1, 2, 4.5)
d &lt;- c(1,   1, 0, 1, 0, 1, 1, 1, 1, 0, 0,   1)
el.cen.EM(x,d,mu=3.5)
## we should get "-2LLR" = 1.2466....
myfun5 &lt;- function(x, theta, eps) {
u &lt;- (x-theta)*sqrt(5)/eps 
INDE &lt;- (u &lt; sqrt(5)) &amp; (u &gt; -sqrt(5)) 
u[u &gt;= sqrt(5)] &lt;- 0 
u[u &lt;= -sqrt(5)] &lt;- 1 
y &lt;- 0.5 - (u - (u)^3/15)*3/(4*sqrt(5)) 
u[ INDE ] &lt;- y[ INDE ] 
return(u)
}
el.cen.EM(x, d, fun=myfun5, mu=0.5, theta=3.5, eps=0.1)
</code></pre>


</div>