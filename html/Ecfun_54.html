<div class="container">

<table style="width: 100%;"><tr>
<td>parseName</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Parse surname and given name
</h2>

<h3>Description</h3>

<p>Identify the presumed surname in a character 
string assumed to represent a name and return 
the result in a character matrix with 
<code>surname</code> followed by <code>givenName</code>.  
If only one name is provided (without 
punctuation), it is assumed to be the 
<code>givenName</code>;  see Wikipedia, 
<a href="https://en.wikipedia.org/wiki/Given_name">"Given name"</a> 
and <a href="https://en.wikipedia.org/wiki/Surname">"Surname"</a>.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">parseName(x, 
    surnameFirst=(median(regexpr(',', x))&gt;0),
    suffix=c('Jr.', 'I', 'II', 'III', 'IV', 
              'Sr.', 'Dr.', 'Jr', 'Sr'),
    fixNonStandard=subNonStandardNames, 
    removeSecondLine=TRUE, 
    namesNotFound="attr.replacement", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a character vector
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>surnameFirst</code></td>
<td>

<p>logical:  If TRUE, the surname comes first 
followed by a comma (","), then the given 
name.  If FALSE, parse the surname from a
standard Western "John Smith, Jr." format.  
If <code>missing(surnameFirst)</code>, use TRUE 
if half of the elements of <code>x</code> 
contain a comma.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>

<p>character vector of strings that are NOT 
a surname but might appear at the end 
without a comma that would otherwise 
identify it as a suffix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixNonStandard</code></td>
<td>

<p>function to look for and repair 
nonstandard names such as names 
containing characters with accent marks 
that are sometimes mangled
by different software.  Use 
<code>identity</code> if this is not
desired.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeSecondLine</code></td>
<td>

<p>logical:  If TRUE, delete anything 
following "\n" and return it as
an attribute <code>secondLine</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>namesNotFound</code></td>
<td>

<p>character vector passed to 
<code>subNonStandardNames</code> and used 
to compute any <code>namesNotFound</code> 
attribute of the object returned 
by <code>parseName</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> optional arguments 
passed to <code>fixNonStandard</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>surnameFirst</code> is <code>FALSE</code>:
</p>
<p>1.  If the last character is ")" and 
the matching "(" is 3 characters earlier, 
drop all that stuff.  Thus, "John Smith 
(AL)" becomes "John Smith".
</p>
<p>2.  Look for commas to identify a suffix 
like Jr. or III;  remove and call the 
rest x2.
</p>
<p>3.  <code>split &lt;- strsplit(x2, " ")</code>
</p>
<p>4.  Take the last as the surname.
</p>
<p>5.  If the "surname" found per 3 is in 
<code>suffix</code>, save to append it to the 
<code>givenName</code> and recurse to get the 
actual surname.
</p>
<p>NOTE:  This gives the wrong answer with 
double surnames written without a hyphen 
in the Spanish tradition, in which, e.g., 
"Anastasio Somoza Debayle", "Somoza Debayle" 
give the (first) surnames of Anastasio's 
father and mother, respectively:  The 
current algorithm would return "Debayle" 
as the surname, which is incorrect.
</p>
<p>6.  Recompose the rest with any suffix as 
the <code>givenName</code>.
</p>


<h3>Value</h3>

<p>a character matrix with two columns:  
surname and <code>givenName</code>.  
</p>
<p>This matrix also has a 
<code>namesNotFound</code> attribute if one is 
returned by <code>subNonStandardNames</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code>strsplit</code>
<code>identity</code>
<code>subNonStandardNames</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##
## 1.  Parse standard first-last name format
##
tstParse &lt;- c('Joe Smith (AL)', 'Teresa Angelica Sanchez de Gomez',
         'John Brown, Jr.', 'John Brown Jr.',
         'John W. Brown III', 'John Q. Brown,I',
         'Linda Rosa Smith-Johnson', 'Anastasio Somoza Debayle',
         'Ra_l Vel_zquez', 'Sting', 'Colette, ')

parsed &lt;- parseName(tstParse)

tstParse2 &lt;- matrix(c('Smith', 'Joe', 'Gomez', 'Teresa Angelica Sanchez de',
  'Brown', 'John, Jr.', 'Brown', 'John, Jr.',
  'Brown', 'John W., III', 'Brown', 'John Q., I',
  'Smith-Johnson', 'Linda Rosa', 'Debayle', 'Anastasio Somoza',
  'Velazquez', 'Raul', '', 'Sting', 'Colette', ''),
  ncol=2, byrow=TRUE)
# NOTE:  The 'Anastasio Somoza Debayle' is in the Spanish tradition
# and is handled incorrectly by the current algorithm.
# The correct answer should be "Somoza Debayle", "Anastasio".
# However, fixing that would complicate the algorithm excessively for now.
colnames(tstParse2) &lt;- c("surname", 'givenName')


all.equal(parsed, tstParse2)


##
## 2.  Parse "surname, given name" format
##
tst3 &lt;- c('Smith (AL),Joe', 'Sanchez de Gomez, Teresa Angelica',
     'Brown, John, Jr.', 'Brown, John W., III', 'Brown, John Q., I',
     'Smith-Johnson, Linda Rosa', 'Somoza Debayle, Anastasio',
     'Vel_zquez, Ra_l', ', Sting', 'Colette,')
tst4 &lt;- parseName(tst3)

tst5 &lt;- matrix(c('Smith', 'Joe', 'Sanchez de Gomez', 'Teresa Angelica',
  'Brown', 'John, Jr.', 'Brown', 'John W., III', 'Brown', 'John Q., I',
  'Smith-Johnson', 'Linda Rosa', 'Somoza Debayle', 'Anastasio',
  'Velazquez', 'Raul', '','Sting', 'Colette',''),
  ncol=2, byrow=TRUE)
colnames(tst5) &lt;- c("surname", 'givenName')


all.equal(tst4, tst5)


##
## 3.  secondLine 
##
L2 &lt;- parseName(c('Adam\n2nd line', 'Ed  \n --Vacancy', 'Frank'))

# check 
L2. &lt;- matrix(c('', 'Adam', '', 'Ed', '', 'Frank'), 
              ncol=2, byrow=TRUE)
colnames(L2.) &lt;- c('surname', 'givenName')
attr(L2., 'secondLine') &lt;- c('2nd line', ' --Vacancy', NA)

all.equal(L2, L2.)


##
## 4.  Force surnameFirst when in a minority 
##
snf &lt;- c('Sting', 'Madonna', 'Smith, Al')
SNF &lt;- parseName(snf, surnameFirst=TRUE)

# check 
SNF2 &lt;- matrix(c('', 'Sting', '', 'Madonna', 'Smith', 'Al'), 
               ncol=2, byrow=TRUE)
colnames(SNF2) &lt;- c('surname', 'givenName')               

all.equal(SNF, SNF2)


##
## 5.  nameNotFound
##
noSub &lt;- parseName('xx_x')

# check 
noSub. &lt;- matrix(c('', 'xx_x'), 1)
colnames(noSub.) &lt;- c('surname', 'givenName')               
attr(noSub., 'namesNotFound') &lt;- 'xx_x'

all.equal(noSub, noSub.)

</code></pre>


</div>