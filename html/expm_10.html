<div class="container">

<table style="width: 100%;"><tr>
<td>expmFrechet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Frechet Derivative of the Matrix Exponential</h2>

<h3>Description</h3>

<p>Compute the Frechet (actually ‘Fréchet’) derivative of the
matrix exponential operator.
</p>


<h3>Usage</h3>

<pre><code class="language-R">expmFrechet(A, E, method = c("SPS", "blockEnlarge"), expm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>square matrix (<code class="reqn">n \times n</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>the “small Error” matrix,
used in <code class="reqn">L(A,E) = f(A + E, A)</code></p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>string specifying the method / algorithm; the default
<code>"SPS"</code> is “Scaling + Pade + Squaring” as in the
algorithm 6.4 below; otherwise see the ‘Details’ section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expm</code></td>
<td>
<p>logical indicating if the matrix exponential itself, which
is computed anyway, should be returned as well.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculation of <code class="reqn">e^A</code> and the Exponential Frechet-Derivative
<code class="reqn">L(A,E)</code>.
</p>
<p>When <code>method = "SPS"</code> (by default), the
with the Scaling - Padé - Squaring Method is used, in
an R-Implementation of Al-Mohy and Higham (2009)'s Algorithm 6.4.
</p>

<dl>
<dt>Step 1:</dt>
<dd>
<p>Scaling (of A and E)</p>
</dd>
<dt>Step 2:</dt>
<dd>
<p>Padé-Approximation of <code class="reqn">e^A</code> and <code class="reqn">L(A,E)</code></p>
</dd>
<dt>Step 3:</dt>
<dd>
<p>Squaring (reversing step 1)</p>
</dd>
</dl>
<p><code>method = "blockEnlarge"</code> uses the matrix identity of

</p>
<p style="text-align: center;"><code class="reqn">f([A E ; 0 A ]) = [f(A) Df(A); 0 f(A)]</code>
</p>
<p> for the <code class="reqn">2n \times
    2n</code> block matrices where <code class="reqn">f(A) := expm(A)</code> and
<code class="reqn">Df(A) := L(A,E)</code>.  Note that <code>"blockEnlarge"</code> is much
simpler to implement but slower (CPU time is doubled for <code class="reqn">n = 100</code>).
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>expm</code></td>
<td>
<p>if <code>expm</code> is true, the matrix exponential
(<code class="reqn">n \times n</code> matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lexpm</code></td>
<td>
<p>the Exponential-Frechet-Derivative <code class="reqn">L(A,E)</code>, a matrix
of the same dimension.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Michael Stadelmann (final polish by Martin Maechler).</p>


<h3>References</h3>

<p>see <code>expmCond</code>.</p>


<h3>See Also</h3>

<p><code>expm.Higham08</code> for the matrix exponential.
<code>expmCond</code> for exponential condition number computations
which are based on <code>expmFrechet</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">(A &lt;- cbind(1, 2:3, 5:8, c(9,1,5,3)))
E &lt;- matrix(1e-3, 4,4)
(L.AE &lt;- expmFrechet(A, E))
all.equal(L.AE, expmFrechet(A, E, "block"), tolerance = 1e-14) ## TRUE
</code></pre>


</div>