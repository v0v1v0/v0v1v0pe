<div class="container">

<table style="width: 100%;"><tr>
<td>propTestPower</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute the Power of a One- or Two-Sample Proportion Test
</h2>

<h3>Description</h3>

<p>Compute the power of a one- or two-sample proportion test, given the sample size(s), 
true proportion(s), and significance level.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  propTestPower(n.or.n1, p.or.p1 = 0.5, n2 = n.or.n1, 
    p0.or.p2 = 0.5, alpha = 0.05, sample.type = "one.sample", 
    alternative = "two.sided", approx = TRUE, 
    correct = sample.type == "two.sample", warn = TRUE, 
    return.exact.list = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n.or.n1</code></td>
<td>

<p>numeric vector of sample sizes.  When <code>sample.type="one.sample"</code>, 
this argument denotes <code class="reqn">n</code>, the number of observations in the single sample.  
When <code>sample.type="two.sample"</code>, this argument denotes <code class="reqn">n_1</code>, 
the number of observations from group 1.  
Missing (<code>NA</code>), undefined (<code>NaN</code>), and infinite (<code>Inf</code>, <code>-Inf</code>) values are not allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.or.p1</code></td>
<td>

<p>numeric vector of proportions.  When <code>sample.type="one.sample"</code>, 
this argument denotes the true value of <code class="reqn">p</code>, the probability of “success”.  When <br><code>sample.type="two.sample"</code>, this argument denotes the value of <code class="reqn">p_1</code>, 
the probability of “success” in group 1.  The default value is <code>p.or.p1=0.5</code>.  
Missing (<code>NA</code>), undefined (<code>NaN</code>), and infinite (<code>Inf</code>, <code>-Inf</code>) values are not allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n2</code></td>
<td>

<p>numeric vector of sample sizes for group 2.  The default value is <code>n2=n.or.n1</code>.  
This argument is ignored when <code>sample.type="one.sample"</code>.  
Missing (<code>NA</code>), undefined (<code>NaN</code>), and infinite (<code>Inf</code>, <code>-Inf</code>) values are not allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p0.or.p2</code></td>
<td>

<p>numeric vector of proportions.  When <code>sample.type="one.sample"</code>, 
this argument denotes the hypothesized value of <code class="reqn">p</code>, the probability of “success”.  
When <code>sample.type="two.sample"</code>, this argument denotes the value of <code class="reqn">p_2</code>, 
the probability of “success” in group 2.  The default value is <br><code>p0.or.p2=0.5</code>.  Missing (<code>NA</code>), undefined (<code>NaN</code>), and infinite (<code>Inf</code>, <code>-Inf</code>) values are not allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>numeric vector of numbers between 0 and 1 indicating the Type I error level 
associated with the hypothesis test.  The default value is <code>alpha=0.05</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.type</code></td>
<td>

<p>character string indicating whether to compute power based on a one-sample or 
two-sample hypothesis test.  When <code>sample.type="one.sample"</code>, 
the computed power is based on a hypothesis test for a single proportion.  
When <br><code>sample.type="two.sample"</code>, the computed power is based on a 
hypothesis test for the difference between two proportions.  
The default value is <br><code>sample.type="one.sample"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>

<p>character string indicating the kind of alternative hypothesis.  
The possible values are <code>"two.sided"</code> (the default), <code>"less"</code>, and 
<code>"greater"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx</code></td>
<td>

<p>logical scalar indicating whether to compute the power based on the normal 
approximation to the binomial distribution.  The default value is <code>approx=TRUE</code>.  
Currently, the exact method (<code>approx=FALSE</code>) is only available for the 
one-sample case (i.e., <code>sample.type="one.sample"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correct</code></td>
<td>

<p>logical scalar indicating whether to use the continuity correction when <br><code>approx=TRUE</code>.  The default value is <code>approx=TRUE</code> when <br><code>sample.type="two.sample"</code> and <code>approx=FALSE</code> when <br><code>sample.type="one.sample"</code>.  This argument is ignored when <br><code>approx=FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>

<p>logical scalar indicating whether to issue a warning.  The default value is <br><code>warn=TRUE</code>.  When <code>approx=TRUE</code> (power based on the normal approximation) and 
<code>warn=TRUE</code>, a warning is issued for cases when the normal approximation to the 
binomial distribution probably is not accurate.  When <br><code>approx=FALSE</code> (power based on the exact test) and <code>warn=TRUE</code>, 
a warning is issued when the user-supplied sample size is too small to 
yield a significance level less than or equal to the user-supplied value of 
<code>alpha</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.exact.list</code></td>
<td>

<p>logical scalar relevant to the case when <code>approx=FALSE</code> 
(i.e., when the power is based on the exact test).  This argument indicates whether 
to return a list containing extra information about the exact test in addition to 
the power of the exact test.  By default, <code>propTestPower</code> returns only a vector 
containing the computed power(s) (see the VALUE section below).  When <br><code>return.exact.list=TRUE</code> (the default) and <code>approx=FALSE</code>, <br><code>propTestPower</code> returns a list with components indicating the power of the 
exact test, the true significance level associated with the exact test, and the 
critical values associated with the exact test (see the DETAILS section for more information).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the arguments <code>n.or.n1</code>, <code>p.or.p1</code>, <code>n2</code>, <code>p0.or.p2</code>, and 
<code>alpha</code> are not all the same length, they are replicated to be the same length 
as the length of the longest argument.
</p>
<p>The power is based on the difference <code>p.or.p1 - p0.or.p2</code>.
</p>
<p><strong>One-Sample Case (<code>sample.type="one.sample"</code>)</strong>.  
</p>

<dl>
<dt><code>approx=TRUE</code></dt>
<dd>
<p> When <code>sample.type="one.sample"</code> and <code>approx=TRUE</code>, 
power is computed based on the test that uses the normal approximation to the 
binomial distribution; see the help file for <code>prop.test</code>.  
The formula for this test and its associated power is presented in most standard statistics 
texts, including Zar (2010, pp. 534-537, 539-541).
</p>
</dd>
<dt><code>approx=FALSE</code></dt>
<dd>
<p> When <code>sample.type="one.sample"</code> and <code>approx=FALSE</code>, 
power is computed based on the exact binomial test; see the help file for <code>binom.test</code>.  
The formula for this test and its associated power is presented in most standard statistics 
texts, including Zar (2010, pp. 532-534, 539) and 
Millard and Neerchal (2001, pp. 385-386, 504-506).
</p>
</dd>
</dl>
<p><strong>Two-Sample Case (<code>sample.type="two.sample"</code>)</strong>. 
</p>
<p>When <code>sample.type="two.sample"</code>, power is computed based on the test that uses the 
normal approximation to the binomial distribution; 
see the help file for <code>prop.test</code>.  
The formula for this test and its associated power is presented in standard statistics texts, 
including Zar (2010, pp. 549-550, 552-553) and 
Millard and Neerchal (2001, pp. 443-445, 508-510).
</p>


<h3>Value</h3>

<p>By default, <code>propTestPower</code> returns a numeric vector of powers.  
For the one-sample proportion test (<code>sample.type="one.sample"</code>), 
when <code>approx=FALSE</code> and <br><code>return.exact.list=TRUE</code>, <code>propTestPower</code> 
returns a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p>numeric vector of powers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>numeric vector containing the true significance levels. 
Because of the discrete nature of the binomial distribution, the true significance 
levels usually do not equal the significance level supplied by the user in the 
argument <code>alpha</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q.critical.lower</code></td>
<td>
<p>numeric vector of lower critical values for rejecting the null 
hypothesis.  If the observed number of "successes" is <em>less than or equal to</em> these values, 
the null hypothesis is rejected. (Not present if <code>alternative="greater"</code>.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q.critical.upper</code></td>
<td>
<p>numeric vector of upper critical values for rejecting the null 
hypothesis.  If the observed number of "successes" is <em>greater than</em> these values, 
the null hypothesis is rejected. (Not present if <code>alternative="less"</code>.)</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The binomial distribution is used to model processes with binary (Yes-No, Success-Failure, 
Heads-Tails, etc.) outcomes.  It is assumed that the outcome of any one trial is independent 
of any other trial, and that the probability of “success”, <code class="reqn">p</code>, is the same on each trial.  
A binomial discrete random variable <code class="reqn">X</code> is the number of "successes" in <code class="reqn">n</code> independent 
trials.  A special case of the binomial distribution occurs when <code class="reqn">n=1</code>, in which case <code class="reqn">X</code> 
is also called a Bernoulli random variable.
</p>
<p>In the context of environmental statistics, the binomial distribution is sometimes used to model the 
proportion of times a chemical concentration exceeds a set standard in a given period of time 
(e.g., Gilbert, 1987, p.143), or to compare the proportion of detects in a compliance well vs. 
a background well (e.g., USEPA, 1989b, Chapter 8, p.3-7).
</p>
<p>In the course of designing a sampling program, an environmental scientist may wish to determine the 
relationship between sample size, power, significance level, and the difference between the 
hypothesized and true proportions if one of the objectives of the sampling program is to 
determine whether a proprtion differs from a specified level or two proportions differ from each other.  
The functions <code>propTestPower</code>, <code>propTestN</code>, <code>propTestMdd</code>, and 
<code>plotPropTestDesign</code> can be used to investigate these relationships for the case of 
binomial proportions.
</p>
<p>Studying the two-sample proportion test, Haseman (1978) found that the formulas used to estimate the 
power that do not incorporate the continuity correction tend to underestimate the power.  
Casagrande, Pike, and Smith (1978) found that the formulas that do incorporate the continuity 
correction provide an excellent approximation.
</p>


<h3>Author(s)</h3>

<p>Steven P. Millard (<a href="mailto:EnvStats@ProbStatInfo.com">EnvStats@ProbStatInfo.com</a>)
</p>


<h3>References</h3>

<p>Berthouex, P.M., and L.C. Brown. (1994). <em>Statistics for Environmental Engineers</em>. 
Lewis Publishers, Boca Raton, FL, Chapter 15.
</p>
<p>Casagrande, J.T., M.C. Pike, and P.G. Smith. (1978). 
An Improved Approximation Formula for Calculating Sample Sizes for Comparing Two Binomial Distributions. 
<em>Biometrics</em> <b>34</b>, 483-486.
</p>
<p>Fleiss, J. L. (1981). <em>Statistical Methods for Rates and Proportions</em>. Second Edition. 
John Wiley and Sons, New York, Chapters 1-2.
</p>
<p>Gilbert, R.O. (1987). <em>Statistical Methods for Environmental Pollution Monitoring</em>. 
Van Nostrand Reinhold, New York, NY.
</p>
<p>Haseman, J.K. (1978). Exact Sample Sizes for Use with the Fisher-Irwin Test for 2x2 Tables. 
<em>Biometrics</em> <b>34</b>, 106-109.
</p>
<p>Millard, S.P., and N. Neerchal. (2001). <em>Environmental Statistics with S-Plus</em>.  
CRC Press, Boca Raton, FL.
</p>
<p>Zar, J.H. (2010). <em>Biostatistical Analysis</em>. Fifth Edition. 
Prentice-Hall, Upper Saddle River, NJ. 
</p>


<h3>See Also</h3>

<p><code>propTestN</code>, <code>propTestMdd</code>, <code>plotPropTestDesign</code>, 
<code>prop.test</code>, <code>binom.test</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Look at how the power of the one-sample proportion test 
  # increases with increasing sample size:

  seq(20, 50, by=10) 
  #[1] 20 30 40 50 

  power &lt;- propTestPower(n.or.n1 = seq(20, 50, by=10), 
    p.or.p1 = 0.7, p0 = 0.5) 

  round(power, 2) 
  #[1] 0.43 0.60 0.73 0.83

  #----------

  # Repeat the last example, but compute the power based on 
  # the exact test instead of the approximation. 
  # Note that the significance level varies with sample size and 
  # never attains the requested level of 0.05.

  prop.test.list &lt;- propTestPower(n.or.n1 = seq(20, 50, by=10), 
    p.or.p1 = 0.7, p0 = 0.5, approx=FALSE) 

  lapply(prop.test.list, round, 2) 
  #$power: 
  #[1] 0.42 0.59 0.70 0.78 
  #
  #$alpha: 
  #[1] 0.04 0.04 0.04 0.03 
  #
  #$q.critical.lower: 
  #[1] 5 9 13 17 
  #
  #$q.critical.upper: 
  #[1] 14 20 26 32

  #==========

  # Look at how the power of the two-sample proportion test 
  # increases with increasing difference between the two 
  # population proportions:

  seq(0.5, 0.1, by=-0.1) 
  #[1] 0.5 0.4 0.3 0.2 0.1 

  power &lt;- propTestPower(30, sample.type = "two", 
    p.or.p1 = seq(0.5, 0.1, by=-0.1)) 
  #Warning message:
  #In propTestPower(30, sample.type = "two", p.or.p1 = seq(0.5, 0.1,  :
  #The sample sizes 'n1' and 'n2' are too small, relative to the given 
  # values of 'p1' and 'p2', for the normal approximation to work well 
  # for the following element indices:
  #         5 

  round(power, 2) 
  #[1] 0.05 0.08 0.26 0.59 0.90

  #----------

  # Look at how the power of the two-sample proportion test 
  # increases with increasing values of Type I error:

  power &lt;- propTestPower(30, sample.type = "two", 
    p.or.p1 = 0.7, 
    alpha = c(0.001, 0.01, 0.05, 0.1)) 

  round(power, 2) 
  #[1] 0.02 0.10 0.26 0.37

  #==========

  # Clean up
  #---------
  rm(power, prop.test.list)

  #==========

  # Modifying the example on pages 8-5 to 8-7 of USEPA (1989b), 
  # determine how adding another 20 observations to the background 
  # well to increase the sample size from 24 to 44 will affect the 
  # power of detecting a difference in the proportion of detects of 
  # cadmium between the background and compliance wells.  Set the 
  # compliance well to "group 1" and set the background well to 
  # "group 2".  Assume the true probability of a "detect" at the 
  # background well is 1/3, set the probability of a "detect" at the 
  # compliance well to 0.4, use a 5% significance level, and use the 
  # upper one-sided alternative (probability of a "detect" at the 
  # compliance well is greater than the probability of a "detect" at 
  # the background well). 
  # (The original data are stored in EPA.89b.cadmium.df.) 
  #
  # Note that the power does increase (from 9% to 12%), but is relatively 
  # very small.

  EPA.89b.cadmium.df
  #   Cadmium.orig Cadmium Censored  Well.type
  #1           0.1   0.100    FALSE Background
  #2          0.12   0.120    FALSE Background
  #3           BDL   0.000     TRUE Background
  # ..........................................
  #86          BDL   0.000     TRUE Compliance
  #87          BDL   0.000     TRUE Compliance
  #88          BDL   0.000     TRUE Compliance


  p.hat.back &lt;- with(EPA.89b.cadmium.df, 
    mean(!Censored[Well.type=="Background"])) 

  p.hat.back 
  #[1] 0.3333333 

  p.hat.comp &lt;- with(EPA.89b.cadmium.df, 
    mean(!Censored[Well.type=="Compliance"])) 

  p.hat.comp 
  #[1] 0.375 

  n.back &lt;- with(EPA.89b.cadmium.df, 
    sum(Well.type == "Background")) 

  n.back 
  #[1] 24 

  n.comp &lt;- with(EPA.89b.cadmium.df, 
    sum(Well.type == "Compliance")) 

  n.comp 
  #[1] 64 

  propTestPower(n.or.n1 = n.comp, 
    p.or.p1 = 0.4, 
    n2 = c(n.back, 44), p0.or.p2 = p.hat.back, 
    alt="greater", sample.type="two") 
  #[1] 0.08953013 0.12421135

  #----------

  # Clean up
  #---------
  rm(p.hat.back, p.hat.comp, n.back, n.comp)
</code></pre>


</div>