<div class="container">

<table style="width: 100%;"><tr>
<td>update.network</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Update the edges in a network based on a matrix</h2>

<h3>Description</h3>

<p>Replaces the edges in a <code>network</code> object with the edges corresponding
to the sociomatrix or edge list specified by <code>new</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'network'
update(object, ...)

update_network(object, new, ...)

## S3 method for class 'matrix_edgelist'
update_network(object, new, attrname = if (ncol(new) &gt; 2) names(new)[3], ...)

## S3 method for class 'data.frame'
update_network(object, new, attrname = if (ncol(new) &gt; 2) names(new)[3], ...)

## S3 method for class 'matrix'
update_network(object, new, matrix.type = NULL, attrname = NULL, ...)

## S3 method for class 'ergm_state'
update_network(object, new, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a <code>network</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments; currently unused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new</code></td>
<td>
<p>Either an adjacency matrix (a matrix of values
indicating the presence and/or the value of a tie from i to j) or
an edge list (a two-column matrix listing origin and destination
node numbers for each edge, with an optional third column for the
value of the edge).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attrname</code></td>
<td>
<p>For a network with edge weights gives the name of
the edge attribute whose names to set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrix.type</code></td>
<td>
<p>One of <code>"adjacency"</code> or <code>"edgelist"</code> telling
which type of matrix <code>new</code> is.  Default is to use the
<code>which.matrix.type()</code> function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A new <code>network</code> object with the edges specified by
<code>new</code> and network and vertex attributes copied from
the input network <code>object</code>. Input network is not modified.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>update_network()</code>: dispatcher for network update based on the type of updating information.
</p>
</li>
<li> <p><code>update_network(matrix_edgelist)</code>: a method for updating a network based on a matrix-form edgelist
</p>
</li>
<li> <p><code>update_network(data.frame)</code>: a method for updating a network based on an edgelist
</p>
</li>
<li> <p><code>update_network(matrix)</code>: a method for updating a network based on a matrix
</p>
</li>
<li> <p><code>update_network(ergm_state)</code>: a method for updating a network based on an <code>ergm_state</code> object.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>ergm()</code>, <code>network</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#
data(florentine)
#
# test the network.update function
#
# Create a Bernoulli network
rand.net &lt;- network(network.size(flomarriage))
# store the sociomatrix 
rand.mat &lt;- rand.net[,]
# Update the network
update(flomarriage, rand.mat, matrix.type="adjacency")
# Try this with an edgelist
rand.mat &lt;- as.matrix.network.edgelist(flomarriage)[1:5,]
update(flomarriage, rand.mat, matrix.type="edgelist")

</code></pre>


</div>