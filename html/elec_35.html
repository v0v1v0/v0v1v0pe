<div class="container">

<table style="width: 100%;"><tr>
<td>make.truth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make baseline truth for simulations</h2>

<h3>Description</h3>

<p>For simulations.  These methods, given an elec.data object, make a
“truth”—i.e. a different vote count—that meets the same precinct and
tot.votes structure, but has potentially different results and outcomes.
</p>
<p><code>make.truth.opt.bad</code> makes the “optimally worse truth”, where the
error needed to flip the winner and runner-up is packed into as a few
precincts as possible.
</p>
<p><code>make.ok.truth</code> makes the truth have the same outcome as the reported,
but some errors here and there.
</p>
<p>Warning: if bound is WPM this error is made by simply adding the max amount of error
to the first loser's total (so that total votes may in this case exceed the total votes
of the precinct)–this could potentially cause trouble.  Be careful!
</p>
<p>make bad truth as described in Stark's paper (assuming fixed precinct size)
</p>


<h3>Usage</h3>

<pre><code class="language-R">make.truth.ex.bad(Z)

make.truth.opt.bad(Z, strata = "strata", bound = c("margin", "WPM"), t = 0)

make.truth.opt.bad.strat(Z, strata = "strata", t = 3, shuffle.strata = FALSE)

make.ok.truth(Z, num.off = 8, amount.off = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>The elec.data to build from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strata</code></td>
<td>
<p>name of column holding strata, if any.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound</code></td>
<td>
<p>What sort of maximum error can be held in a precinct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>an allowed backgound level of error for all precincts</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuffle.strata</code></td>
<td>
<p>Should the error be randomly put in the strata?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.off</code></td>
<td>
<p>Number of precincts that should have small errors.  Direction
of errors split 50-50 positive and negative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amount.off</code></td>
<td>
<p>Size of the small errors that should be imposed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Another elec.data matrix with the same candidates and total ballot
counts as the passed frame, but with different candidate totals and
by-precinct votes.  Can be used to test the power or actual confidence of
the various auditing procedures.
</p>
<p>WARNING: make.ok.truth randomly adds votes and can thus sometimes exceed the
allowed ballot count for a precinct by small amounts.
</p>
<p>WARNING: If the desired bound is WPM, the error in make.opt.bad.truth is
made by simply adding the maximum allowed amount of error in votes to the
first loser's total (so that total votes may in this case exceed the total
votes of the precinct)–this could potentially cause trouble.  Be careful!
</p>
<p>WARNING: <code>make.truth.ex.bad</code> and <code>make.truth.opt.bad.strat</code> only
work in conjunction with the <code>make.cartoon</code> method.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p><code>elec.data</code> <code>make.sample</code>
<code>do.audit</code> <code>make.cartoon</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## First make a fake election.
Z = make.sample(0.08, 150, per.winner=0.4, R=2.2)
Z

## Now make a fake truth, which has a lot of small errors:
Zb = make.ok.truth(Z, num.off=150, amount.off=5)
Zb

## Finally, make the hardest to detect (via SRS) ``wrong'' election:
Zw = make.truth.opt.bad( Z, t=4 )
Zw 
</code></pre>


</div>