<div class="container">

<table style="width: 100%;"><tr>
<td>MCMCcopies</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulates iid copies of a MCMC algorithm</h2>

<h3>Description</h3>

<p>Simulates <code>nmc</code> iid copies of a MCMC algorithm <code>mcmc_algo</code>
for <code>n</code>
(time) iterations and returns an object of class <code>plMCMC</code> 
(for parallel MCMC) holding an array of the trajectories and running information.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMCcopies(mcmc_algo, n = 100, nmc = 10, Ptheta0, target, f_param, q_param, verb = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mcmc_algo</code></td>
<td>
<p>a list defining an MCMC algorithm in terms of the 
functions it uses, such as <code>RWHM</code>, see details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of (time) iterations of each single chain to run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmc</code></td>
<td>
<p>The number of iid copies of each single chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ptheta0</code></td>
<td>
<p>A (nmc x d) matrix, with the ith row giving a d-dimensional initial theta values for the ith chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>The target density for which the MCMC algorithm is defined; 
may be given only up to a multiplicative constant for most MCMC. 
Target must be a function such as the multidimensional gaussian
<code>target_norm(x,param)</code> with argument and parameters passed 
like in this example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_param</code></td>
<td>
<p>A list holding all the necessary target parameters, 
consistent with the target definition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q_param</code></td>
<td>
<p>A list holding all the necessary parameters 
for the proposal density of the MCMC algorithm <code>mcmc_algo</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p>Verbose mode for summarizing output during the simulation.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p><code>MCMCcopies</code> sequentially simulates <code>nmc</code> iid copies of the
MCMC algorithm passed in the list <code>mcmc_algo</code>, 
for <code>n</code> (time) iterations, and returns an object of class <code>plMCMC</code> holding an array of the trajectories and running information.
The list <code>mcmc_algo</code> must contain the named elements:
</p>

<ul>
<li> <p><code>name</code>, the name of the MCMC, such as "RWHM"
</p>
</li>
<li> <p><code>chain</code>, the function for simulation of n steps of a single chain
</p>
</li>
<li> <p><code>step</code>, the function for simulation of 1 step of that algorithm
</p>
</li>
<li> <p><code>q_pdf</code>, the density of the proposal
</p>
</li>
<li> <p><code>q_proposal</code>, the function that simulates a proposal
</p>
</li>
</ul>
<p>For examples, see the algorithms currently implemented:
<code>RWHM</code>, the Random Walk Hasting-Metropolis with gaussian proposal;
<code>HMIS_norm</code>, an Independence Sampler HM with gaussian proposal;
<code>AMHaario</code>, the Adaptive-Metropolis (AM) from Haario (2001); 
<code>IID_norm</code>, a gaussian iid sampler which is merely 
a "fake" MCMC for testing purposes. 
</p>


<h3>Value</h3>

<p><code>MCMCcopies</code> returns a list of class <code>plMCMC</code> with items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Ptheta</code></td>
<td>
<p>The <code>nmc</code> copies of chains in an array(n,d,nmc) 
of simulated values, where 1st value (1,d,nmc) is <code>Ptheta0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.accept</code></td>
<td>
<p>The estimated rate of acceptation over all simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algo</code></td>
<td>
<p>The MCMC algorithm name i.e. <code>mcmc_algo$name</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>The target density.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_param</code></td>
<td>
<p>The list holding all the target parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q_param</code></td>
<td>
<p>The list holding all the proposal density parameters.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Didier Chauveau.</p>


<h3>References</h3>


<ul>
<li>
<p> Chauveau, D. and Vandekerkhove, P. (2013), 
Smoothness of Metropolis-Hastings algorithm and application to entropy estimation.
<em>ESAIM: Probability and Statistics</em>,  <b>17</b>, 419–431.
DOI: <a href="http://dx.doi.org/10.1051/ps/2012004">http://dx.doi.org/10.1051/ps/2012004</a>
</p>
</li>
<li>
<p> Chauveau D. and Vandekerkhove, P. (2014),
Simulation Based Nearest Neighbor Entropy Estimation for (Adaptive) MCMC Evaluation,
In <em>JSM Proceedings, Statistical Computing Section</em>.
Alexandria, VA: American Statistical Association. 2816–2827.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Two multicore and cluster version 
<code>MCMCcopies.mc</code> and
<code>MCMCcopies.cl</code>,
and functions doing simulation and entropy and Kullback  estimation simultaneously:
<code>EntropyParallel</code> and <code>EntropyParallel.cl</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Toy example using the bivariate gaussian target
## with default parameters value, see target_norm_param
n = 150; nmc = 20; d=2 # bivariate example
varq=0.1 # variance of the proposal (chosen too small)
q_param=list(mean=rep(0,d),v=varq*diag(d))
## initial distribution, located in (2,2), "far" from target center (0,0)
Ptheta0 &lt;- DrawInit(nmc, d, initpdf = "rnorm", mean = 2, sd = 1) 
# simulation
s1 &lt;- MCMCcopies(RWHM, n, nmc, Ptheta0, target_norm,
                 target_norm_param, q_param, verb = FALSE)
summary(s1) # method for "plMCMC" object
par(mfrow=c(1,2))
plot(s1) # just a path of the iid chains, method for "plMCMC" object
hist(s1$Ptheta[,1,], col=8) # marginal 1
</code></pre>


</div>