<div class="container">

<table style="width: 100%;"><tr>
<td>grid_sample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatiotemporal grid sampling of observation data</h2>

<h3>Description</h3>

<p>Sample observation data on a spacetime grid to reduce spatiotemporal bias.
</p>


<h3>Usage</h3>

<pre><code class="language-R">grid_sample(
  x,
  coords = c("longitude", "latitude", "day_of_year"),
  is_lonlat = TRUE,
  res = c(3000, 3000, 7),
  jitter_grid = TRUE,
  sample_size_per_cell = 1,
  cell_sample_prop = 0.75,
  keep_cell_id = FALSE,
  grid_definition = NULL
)

grid_sample_stratified(
  x,
  coords = c("longitude", "latitude", "day_of_year"),
  is_lonlat = TRUE,
  unified_grid = FALSE,
  keep_cell_id = FALSE,
  by_year = TRUE,
  case_control = TRUE,
  obs_column = "obs",
  sample_by = NULL,
  min_detection_probability = 0,
  maximum_ss = NULL,
  jitter_columns = NULL,
  jitter_sd = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data frame; observations to sample, including at least the columns
defining the location in space and time. Additional columns can be included
such as features that will later be used in model training.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>character; names of the spatial and temporal coordinates. By
default the spatial spatial coordinates should be <code>longitude</code> and
<code>latitude</code>, and temporal coordinate should be <code>day_of_year</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_lonlat</code></td>
<td>
<p>logical; if the points are in unprojected, lon-lat
coordinates. In this case, the points will be projected to an equal area
Eckert IV CRS prior to grid assignment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res</code></td>
<td>
<p>numeric; resolution of the spatiotemporal grid in the x, y, and
time dimensions. Unprojected locations are projected to an equal area
coordinate system prior to sampling, and resolution should therefore be
provided in units of meters. The temporal resolution should be in the
native units of the time coordinate in the input data frame, typically it
will be a number of days.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter_grid</code></td>
<td>
<p>logical; whether to jitter the location of the origin of
the grid to introduce some randomness.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample_size_per_cell</code></td>
<td>
<p>integer; number of observations to sample from
each grid cell.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell_sample_prop</code></td>
<td>
<p>proportion <code style="white-space: pre;">⁠(0-1]⁠</code>; if less than 1, only this
proportion of cells will be randomly selected for sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_cell_id</code></td>
<td>
<p>logical; whether to retain a unique cell identifier,
stored in column named <code>.cell_id</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_definition</code></td>
<td>
<p>list defining the spatiotemporal sampling grid as
returned by <code>assign_to_grid()</code> in the form of an attribute of the returned
data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unified_grid</code></td>
<td>
<p>logical; whether a single, unified spatiotemporal
sampling grid should be defined and used for all observations in <code>x</code> or a
different grid should be used for each stratum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by_year</code></td>
<td>
<p>logical; whether the sampling should be done by year, i.e.
sampling N observations per grid cell per year, rather than across years,
i.e. N observations per grid cell regardless of year. If using sampling by
year, the input data frame <code>x</code> must have a <code>year</code> column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>case_control</code></td>
<td>
<p>logical; whether to apply case control sampling whereby
presence and absence are sampled independently.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs_column</code></td>
<td>
<p>character; if <code>case_control = TRUE</code>, this is the name of
the column in <code>x</code> that defines detection (<code>obs_column &gt; 0</code>) and
non-detection (<code>obs_column == 0</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample_by</code></td>
<td>
<p>character; additional columns in <code>x</code> to stratify sampling
by. For example, if a landscape has many small islands (defined by an
<code>island</code> variable) and we wish to sample from each independently, use
<code>sample_by = "island"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_detection_probability</code></td>
<td>
<p>proportion <code style="white-space: pre;">⁠[0-1)⁠</code>; the minimum detection
probability in the final dataset. If <code>case_control = TRUE</code>, and the
proportion of detections in the grid sampled dataset is below this level,
then additional detections will be added via grid sampling the detections
from the input dataset until at least this proportion of detections appears
in the final dataset. This will typically result in duplication of some
observations in the final dataset. To turn this off this feature use
<code>min_detection_probability = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximum_ss</code></td>
<td>
<p>integer; the maximum sample size in the final dataset. If
the grid sampling yields more than this number of observations,
<code>maximum_ss</code> observations will be selected randomly from the full set. Note
that this subsampling will be performed in such a way that all levels of
each strata will have at least one observation within the final dataset,
and therefore it is not truly randomly sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter_columns</code></td>
<td>
<p>character; if detections are oversampled to achieve the
minimum detection probability, some observations will be duplicated, and it
can be desirable to slightly "jitter" the values of model training features
for these duplicated observations. This argument defines the column names
in <code>x</code> that will be jittered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter_sd</code></td>
<td>
<p>numeric; strength of the jittering in units of standard
deviations, see <code>jitter_columns</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments defining the spatiotemporal grid; passed to
<code>grid_sample()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>grid_sample_stratified()</code> performs stratified case control sampling,
independently sampling from strata defined by, for example, year and
detection/non-detection. Within each stratum, <code>grid_sample()</code> is used to
sample the observations on a spatiotemporal grid. In addition, if case
control sampling is turned on, the detections are oversampled to increase the
frequecy of detections in the dataset.
</p>
<p>The sampling grid is defined, and assignment of locations to cells occurs, in
<code>assign_to_grid()</code>. Consult the help for that function for further details on
how the grid is generated and locations are assigned. Note that by providing
2-element vectors to both <code>coords</code> and <code>res</code> the time component of the grid
can be ignored and spatial-only subsampling is performed.
</p>


<h3>Value</h3>

<p>A data frame of the spatiotemporally sampled data.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)

# generate some example observations
n_obs &lt;- 10000
checklists &lt;- data.frame(longitude = rnorm(n_obs, sd = 0.1),
                         latitude = rnorm(n_obs, sd = 0.1),
                         day_of_year = sample.int(28, n_obs, replace = TRUE),
                         year = NA_integer_,
                         obs = rpois(n_obs, lambda = 0.1),
                         forest_cover = runif(n_obs),
                         island = as.integer(runif(n_obs) &gt; 0.95))
# add a year column, giving more data to recent years
checklists$year &lt;- sample(seq(2016, 2020), size = n_obs, replace = TRUE,
                          prob = seq(0.3, 0.7, length.out = 5))
# create several rare islands
checklists$island[sample.int(nrow(checklists), 9)] &lt;- 2:10

# basic spatiotemporal grid sampling
sampled &lt;- grid_sample(checklists)

# plot original data and grid sampled data
par(mar = c(0, 0, 0, 0))
plot(checklists[, c("longitude", "latitude")],
     pch = 19, cex = 0.3, col = "#00000033",
     axes = FALSE)
points(sampled[, c("longitude", "latitude")],
       pch = 19, cex = 0.3, col = "red")

# case control sampling stratified by year and island
# return a maximum of 1000 checklists
sampled_cc &lt;- grid_sample_stratified(checklists, sample_by = "island",
                                     maximum_ss = 1000)

# case control sampling increases the prevalence of detections
mean(checklists$obs &gt; 0)
mean(sampled$obs &gt; 0)
mean(sampled_cc$obs &gt; 0)

# stratifying by island ensures all levels are retained, even rare ones
table(checklists$island)
# normal grid sampling loses rare island levels
table(sampled$island)
# stratified grid sampling retain at least one observation from each level
table(sampled_cc$island)
</code></pre>


</div>