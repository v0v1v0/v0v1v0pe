<div class="container">

<table style="width: 100%;"><tr>
<td>e1e2e3</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate e1, e2, e3 from the invariants</h2>

<h3>Description</h3>

<p>Calculates <code class="reqn">e_1,e_2,e_3</code> from the invariants using
either <code>polyroot</code> or Cardano's method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">e1e2e3(g, use.laurent=TRUE, AnS=is.double(g), Omega=NULL, tol=1e-6)
eee.cardano(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>Two-element vector with <code>g=c(g2,g3)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.laurent</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning
to use <code>P.laurent()</code> to determine the correct ordering for the
<code class="reqn">e</code>: <code class="reqn">\wp(\omega_1)</code>, <code class="reqn">\wp(\omega_2)</code>,
<code class="reqn">\wp(\omega_3)</code>.  Setting to  <code>FALSE</code> means to
return the solutions of the cubic equation directly: this is much
faster, but is not guaranteed to find the <code class="reqn">e_i</code> in the
right order (the roots are found according to the vagaries of
<code>polyroot()</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AnS</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to define
<code class="reqn">\omega_3</code> as per ams-55, and <code>FALSE</code> meaning to
follow Whittaker and Watson, and define
<code class="reqn">\omega_1</code> and <code class="reqn">\omega_2</code> as the
primitive half periods, and
<code class="reqn">\omega_3=-\omega_1-\omega_2</code>.  This is
also consistent with Chandrasekharan except the factor of 2.
</p>
<p>Also note that setting <code>AnS</code> to <code>TRUE</code> forces the
<code class="reqn">e</code> to be real</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Omega</code></td>
<td>
<p>A pair of primitive half periods, if known.  If supplied, the
function uses them to calculate approximate values for the three
<code class="reqn">e</code>s (but supplies values calculated by <code>polyroot()</code>,
which are much more accurate).  The function needs the approximate
values to determine in which order the <code class="reqn">e</code>s should be, as
<code>polyroot()</code> returns roots in whichever order the polynomial
solver gives them in</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Real, relative tolerance criterion for terminating Laurent
summation</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a three-element vector.
</p>


<h3>Note</h3>

<p>Function <code>parameters()</code> calls <code>e1e2e3()</code>, so <strong>do not
use <code>parameters()</code> to determine argument <code>g</code>, because
doing so will result in a recursive loop.</strong>
</p>
<p>Just to be specific: <code>e1e2e3(g=parameters(...))</code> will fail.  It
would be pointless anyway, because <code>parameters()</code> returns
(inter alia) <code class="reqn">e_1, e_2, e_3</code>.
</p>
<p>There is considerable confusion about the order of <code class="reqn">e_1</code>,
<code class="reqn">e_2</code> and <code class="reqn">e_3</code>, essentially due to Abramowitz and
Stegun's definition of the half periods being inconsistent with that
of Chandrasekharan's, and Mathematica's.  It is not possible to
reconcile A and S's notation for theta functions with
Chandrasekharan's definition of a primitive pair.  Thus,
the convention adopted here is the rather strange-seeming choice of
<code class="reqn">e_1=\wp(\omega_1/2)</code>,
<code class="reqn">e_2=\wp(\omega_3/2)</code>,
<code class="reqn">e_3=\wp(\omega_2/2)</code>.  This has the advantage
of making equation 18.10.5 (p650, ams55), and equation
09.13.27.0011.01, return three identical values.
</p>
<p>The other scheme to rescue 18.10.5 would be to define
<code class="reqn">(\omega_1,\omega_3)</code> as a primitive pair, and
to require
<code class="reqn">\omega_2=-\omega_1-\omega_3</code>.  This is
the method adopted by Mathematica; it is no more inconsistent with
ams55 than the solution used in package <span class="pkg">elliptic</span>.  However,
this scheme suffers from the
disadvantage that the independent elements of <code>Omega</code> would
have to be supplied as <code>c(omega1,NA,omega3)</code>, and this is
inimical to the precepts of R.
</p>
<p>One can realize the above in practice by
considering what this package calls
“<code class="reqn">\omega_2</code>” to be <em>really</em>
<code class="reqn">\omega_3</code>, and what this package calls
“<code class="reqn">\omega_1+\omega_2</code>” to be
<em>really</em> <code class="reqn">\omega_2</code>.  Making function
<code>half.periods()</code> return a three element vector with names
<code>omega1</code>, <code>omega3</code>, <code>omega2</code> might work on some
levels, and indeed might be the correct solution for a user
somewhere; but it would be confusing.  This confusion would
dog my weary steps for ever more.    
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Mathematica</p>


<h3>Examples</h3>

<pre><code class="language-R"> sum(e1e2e3(g=c(1,2)))
</code></pre>


</div>