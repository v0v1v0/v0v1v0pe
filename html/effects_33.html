<div class="container">

<table style="width: 100%;"><tr>
<td>LegacyArguments</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Legacy Arguments for <code>plot</code> and <code>Effect</code> Methods</h2>

<h3>Description</h3>

<p>Prior to verson 4.0-0 of the <span class="pkg">effects</span> package, there were many (literally dozens) of
arguments to the <code>plot</code> methods for <code>"eff"</code> and <code>"effpoly"</code> objects. 
</p>
<p>In version 4.0-0 of the package, we have consolidated these arguments into a much smaller
number of arguments (e.g., <code>lines</code>, <code>points</code>, <code>axes</code>) that take lists of
specifications. We have similarly consolidated some of the arguments to <code>Effect</code> methods
into the <code>confint</code> and <code>fixed.predictors</code> arguments.
</p>
<p>For backwards compatibility, we have to the extent possible retained the
older arguments. If specified, these legacy arguments take precedence over the newer
list-style arguments
</p>


<h3>Details</h3>

<p>Here is the correspondence between the old and new arguments.
</p>
<p>For <code>plot</code> methods:
</p>

<dl>
<dt><code>multiline=TRUE/FALSE</code></dt>
<dd>
<p><code>lines=list(multiline=TRUE/FALSE)</code></p>
</dd>
<dt><code>type=c("rescale", "link", "response")</code></dt>
<dd>
<p>For models with a link function, <code>"link"</code> plots in linear predictor scale, <code>"response"</code> plots in the response scale, and the default <code>"rescale"</code> plots in linear predictor scale but labels tick-marks in response scale.</p>
</dd>
<dt><code>z.var=which.min(levels)</code></dt>
<dd>
<p><code>lines=list(z.var=which.min(levels))</code> relevant only when <code>lines=list(multiline=TRUE)</code></p>
</dd>
<dt><code>colors={vector of colors}</code></dt>
<dd>
<p><code>lines=list(col={vector of colors})</code></p>
</dd>
<dt><code>lty={vector of line types}</code></dt>
<dd>
<p><code>lines=list(lty={vector of line types})</code></p>
</dd>
<dt><code>lwd={vector of line widths}</code></dt>
<dd>
<p><code>lines=list(lwd={vector of line widths})</code></p>
</dd>
<dt><code>use.splines=TRUE/FALSE</code></dt>
<dd>
<p><code>lines=list(splines=TRUE/FALSE)</code></p>
</dd>
<dt><code>cex={number}</code></dt>
<dd>
<p><code>points=list(cex={number})</code></p>
</dd>
<dt><code>rug=TRUE/FALSE</code></dt>
<dd>
<p><code>axes=list(x=list(rug=TRUE/FALSE)</code></p>
</dd>
<dt><code>xlab={"axis title"}</code></dt>
<dd>
<p><code>axes=list(x=list(lab={"axis title"}))</code></p>
</dd>
<dt><code>xlim={c(min, max)}</code></dt>
<dd>
<p><code>axes=list(x=list(lim={c(min, max)}))</code></p>
</dd>
<dt><code>rotx={degrees}</code></dt>
<dd>
<p><code>axes=list(x=list(rot={degrees}))</code></p>
</dd>
<dt><code>ticks.x=list({tick specifications})</code></dt>
<dd>
<p><code>axes=list(x=list(ticks=list({tick specifications})))</code></p>
</dd>
<dt><code>transform.x=list(link={function}, inverse={function})</code></dt>
<dd>
<p><code>axes=list(x=list(transform=list({lists of transformations by predictors})))</code></p>
</dd>
<dt><code>ylab={"axis title"}</code></dt>
<dd>
<p><code>axes=list(y=list(lab={"axis title"}))</code></p>
</dd>
<dt><code>ylim={c(min, max)}</code></dt>
<dd>
<p><code>axes=list(y=list(lim={c(min, max)}))</code></p>
</dd>
<dt><code>roty={degrees}</code></dt>
<dd>
<p><code>axes=list(y=list(rot={degrees}))</code></p>
</dd>
<dt><code>ticks=list({tick specifications})</code></dt>
<dd>
<p><code>axes=list(y=list(ticks=list({tick specifications})))</code></p>
</dd>
<dt><code>alternating=TRUE/FALSE</code></dt>
<dd>
<p><code>axes=list(alternating=TRUE/FALSE)</code></p>
</dd>
<dt><code>grid=TRUE/FALSE</code></dt>
<dd>
<p><code>axes=list(grid=TRUE/FALSE)</code></p>
</dd>
<dt><code>ci.style="bands"/"lines"/"bars"/"none"</code></dt>
<dd>
<p><code>confint=list(style="bands"/"lines"/"bars"/"none"</code>)</p>
</dd>
<dt><code>band.transparency={number}</code></dt>
<dd>
<p><code>confint=list(alpha={number})</code></p>
</dd>
<dt><code>band.colors={vector of colors}</code></dt>
<dd>
<p><code>confint=list(col={vector of colors})</code></p>
</dd>
<dt><code>residuals.color={color}</code></dt>
<dd>
<p><code>partial.residuals=list(col={color})</code></p>
</dd>
<dt><code>residuals.pch={plotting character}</code></dt>
<dd>
<p><code>partial.residuals=list(pch={plotting character})</code></p>
</dd>
<dt><code>residuals.cex={number}</code></dt>
<dd>
<p><code>partial.residuals=list(cex={number})</code></p>
</dd>
<dt><code>smooth.residuals=TRUE/FALSE</code></dt>
<dd>
<p><code>partial.residuals=list(smooth=TRUE/FALSE)</code></p>
</dd>
<dt><code>residuals.smooth.color={color}</code></dt>
<dd>
<p><code>partial.residuals=list(smooth.col={color})</code></p>
</dd>
<dt><code>span={number}</code></dt>
<dd>
<p><code>partial.residuals=list(span={number})</code></p>
</dd>
<dt><code>show.fitted=TRUE/FALSE</code></dt>
<dd>
<p><code>partial.residuals=list(fitted=TRUE/FALSE)</code></p>
</dd>
<dt><code>factor.names=TRUE/FALSE</code></dt>
<dd>
<p><code>lattice=list(strip=list(factor.names=TRUE/FALSE))</code></p>
</dd>
<dt><code>show.strip.values=TRUE/FALSE</code></dt>
<dd>
<p><code>lattice=list(strip=list(values=TRUE/FALSE))</code></p>
</dd>
<dt><code>layout={lattice layout}</code></dt>
<dd>
<p><code>lattice=list(layout={lattice layout})</code></p>
</dd>
<dt><code>key.args={lattice key args}</code></dt>
<dd>
<p><code>lattice=list(key.args={lattice key args})</code></p>
</dd>
<dt><code>style="lines"/"stacked"</code></dt>
<dd>
<p>for <code>plot.effpoly</code>, <code>axes=list(y=list(style="lines"/"stacked"))</code></p>
</dd>
<dt><code>rescale.axis=TRUE/FALSE</code></dt>
<dd>
<p><code>type="rescale"/"response"/"link"</code></p>
</dd>
</dl>
<p>For <code>Effect</code> methods:
</p>

<dl>
<dt>
<code>confint=TRUE/FALSE</code> or a list</dt>
<dd>
<p>may be substituted for the <code>se</code> argument.</p>
</dd>
<dt><code>confidence.level={number}</code></dt>
<dd>
<p><code>se=list(level={number})</code></p>
</dd>
<dt><code>given.values={named vector}</code></dt>
<dd>
<p><code>fixed.predictors=list(given.values={named vector})</code></p>
</dd>
<dt><code>typical={function}</code></dt>
<dd>
<p><code>fixed.predictors=list(typical={function})</code></p>
</dd>
<dt><code>offset={function}</code></dt>
<dd>
<p><code>fixed.predictors=list(offset={function})</code></p>
</dd>
<dt><code>partial.residuals=TRUE/FALSE</code></dt>
<dd>
<p><code>residuals=TRUE/FALSE</code></p>
</dd>
<dt><code>transformation</code></dt>
<dd>
<p>This argument to <code>Effect</code> is not needed to compute effects.  It can now be set directly with the <code>plot</code> method with the argument <code>axes = list(y = list(transformation=specification))</code>.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code>Effect</code>, <code>plot.eff</code>, <code>plot.effpoly</code>
</p>


</div>