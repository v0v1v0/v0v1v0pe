<div class="container">

<table style="width: 100%;"><tr>
<td>pinferunemjmcmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A wrapper for running the GLMM, BLR, or DBRM based inference
and predictions in an expert but rather easy to use way</h2>

<h3>Description</h3>

<p>A wrapper for running the GLMM, BLR, or DBRM based inference
and predictions in an expert but rather easy to use way
</p>


<h3>Usage</h3>

<pre><code class="language-R">pinferunemjmcmc(
  n.cores = 4,
  mcgmj = mcgmjpse,
  report.level = 0.5,
  simplify = FALSE,
  num.mod.best = 1000,
  predict = FALSE,
  test.data = 1,
  link.function = function(z) z,
  runemjmcmc.params
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>the maximal number of cores (and (R)(G)MJMCMC threads) to
be addressed in the analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcgmj</code></td>
<td>
<p>an mclapply like function for performing for performing
parallel computing, do not change the default unless you are using Windows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>report.level</code></td>
<td>
<p>a numeric value in (0,1) specifying the threshold for
detections based on the marginal inclusion probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>a logical value specifying in simplification of the features
is to be done after the search is completed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.mod.best</code></td>
<td>
<p>the number of the best models in the thread to
calculate marginal inclusion probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict</code></td>
<td>
<p>a logical value specifying if predictions should be done by
the run of pinferunemjmcmc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.data</code></td>
<td>
<p>covariates data.frame to be used for predictions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link.function</code></td>
<td>
<p>the link functions to be used to make predictions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>runemjmcmc.params</code></td>
<td>
<p>a vector of parameters of runemjmcmc function,
see the help of runemjmcmc for details</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list of
</p>

<dl>
<dt>feat.stat</dt>
<dd>
<p>detected features or logical expressions and their
marginal inclusion probabilities</p>
</dd>
<dt>predictions</dt>
<dd>
<p>predicted values if they are required, NULL otherwise</p>
</dd>
<dt>allposteriors</dt>
<dd>
<p>all visited by (R)(G)MJMCMC features and logical
expressions and their marginal inclusion probabilities</p>
</dd>
<dt>threads.stats</dt>
<dd>
<p>a vector of detailed outputs of individual n.cores
threads of (R)(G)MJMCMC run</p>
</dd>
</dl>
<h3>See Also</h3>

<p>runemjmcmc LogrRegr DeepRegr LinRegr
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# inference

X &lt;- read.csv(system.file("extdata", "exa1.csv", package="EMJMCMC"))
data.example &lt;- as.data.frame(X)

# specify the initial formula
formula1 &lt;- as.formula(
  paste(colnames(X)[5], "~ 1 +", paste0(colnames(X)[-5], collapse = "+"))
)

# define the number or cpus
M &lt;- 1L
# define the size of the simulated samples
NM &lt;- 1000
# define \k_{max} + 1 from the paper
compmax &lt;- 16
# define treshold for preinclusion of the tree into the analysis
th &lt;- (10)^(-5)
# define a final treshold on the posterior marginal probability for reporting a
# tree
thf &lt;- 0.05
# specify tuning parameters of the algorithm for exploring DBRM of interest
# notice that allow_offsprings=3 corresponds to the GMJMCMC runs and
# allow_offsprings=4 -to the RGMJMCMC runs

  res1 &lt;- pinferunemjmcmc(
    n.cores = M, report.level = 0.5, num.mod.best = NM, simplify = TRUE,
    runemjmcmc.params = list(
      formula = formula1, data = data.example, estimator = estimate.gamma.cpen_2,
      estimator.args = list(data = data.example), recalc_margin = 249,
      save.beta = FALSE, interact = TRUE, outgraphs = FALSE,
      relations = c("to23", "expi", "logi", "to35", "sini", "troot", "sigmoid"),
      relations.prob = c(0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1),
      interact.param = list(allow_offsprings = 3, mutation_rate = 250,
      last.mutation = 10000, max.tree.size = 5, Nvars.max = 15,
      p.allow.replace = 0.9, p.allow.tree = 0.01, p.nor = 0.9, p.and = 0.9),
      n.models = 10000, unique = TRUE, max.cpu = M, max.cpu.glob = M,
      create.table = FALSE, create.hash = TRUE, pseudo.paral = TRUE,
      burn.in = 100, print.freq = 1000,
      advanced.param = list(
        max.N.glob = as.integer(10),
        min.N.glob = as.integer(5),
        max.N = as.integer(3),
        min.N = as.integer(1),
        printable = FALSE
      )
    )
  )
  print(res1$feat.stat)


# prediction

compmax &lt;- 21

# read in the train and test data sets
test &lt;- read.csv(
  system.file("extdata", "breast_cancer_test.csv", package="EMJMCMC"),
  header = TRUE, sep = ","
)[, -1]
train &lt;- read.csv(
  system.file("extdata", "breast_cancer_train.csv", package="EMJMCMC"),
  header = TRUE, sep = ","
)[, -1]

# transform the train data set to a data.example data.frame that EMJMCMC class
# will internally use
data.example &lt;- as.data.frame(train)

# specify the link function that will be used in the prediction phase
g &lt;- function(x) {
  return((x &lt;- 1 / (1 + exp(-x))))
}

formula1 &lt;- as.formula(
  paste(
    colnames(data.example)[31], "~ 1 +",
    paste0(colnames(data.example)[-31], collapse = "+")
  )
)


  # Defining a custom estimator function
  estimate.bas.glm.cpen &lt;- function(
    formula, data, family, prior, logn, r = 0.1, yid=1,
    relat =c("cosi","sigmoid","tanh","atan","erf","m(")
  ) {
    #only poisson and binomial families are currently adopted
    X &lt;- model.matrix(object = formula,data = data)
    capture.output({out &lt;- BAS::bayesglm.fit(x = X, y = data[,yid], family=family,coefprior=prior)})
    fmla.proc&lt;-as.character(formula)[2:3]
    fobserved &lt;- fmla.proc[1]
    fmla.proc[2]&lt;- stringi::stri_replace_all(str = fmla.proc[2],fixed = " ",replacement = "")
    fmla.proc[2]&lt;- stringi::stri_replace_all(str = fmla.proc[2],fixed = "\n",replacement = "")
    sj&lt;-2*(stringi::stri_count_fixed(str = fmla.proc[2], pattern = "*"))
    sj&lt;-sj+1*(stringi::stri_count_fixed(str = fmla.proc[2], pattern = "+"))
    for(rel in relat) {
      sj&lt;-sj+2*(stringi::stri_count_fixed(str = fmla.proc[2], pattern = rel))
    }
    mlik = ((-out$deviance +2*log(r)*sum(sj)))/2
    return(
      list(
        mlik = mlik, waic = -(out$deviance + 2*out$rank),
        dic = -(out$deviance + logn*out$rank),
        summary.fixed = list(mean = coefficients(out))
      )
    )
  }
  res &lt;- pinferunemjmcmc(
    n.cores = M, report.level = 0.5, num.mod.best = NM, simplify = TRUE,
    predict = TRUE, test.data = as.data.frame(test), link.function = g,
    runemjmcmc.params = list(
      formula = formula1, data = data.example, gen.prob = c(1, 1, 1, 1, 0),
      estimator = estimate.bas.glm.cpen,
      estimator.args = list(
        data = data.example, prior = BAS::aic.prior(), family = binomial(),
        yid = 31, logn = log(143), r = exp(-0.5)
      ), recalc_margin = 95, save.beta = TRUE, interact = TRUE,
      relations = c("gauss", "tanh", "atan", "sin"),
      relations.prob = c(0.1, 0.1, 0.1, 0.1),
      interact.param = list(
        allow_offsprings = 4, mutation_rate = 100, last.mutation = 1000,
        max.tree.size = 6, Nvars.max = 20, p.allow.replace = 0.5,
        p.allow.tree = 0.4, p.nor = 0.3, p.and = 0.9
      ), n.models = 7000, unique = TRUE, max.cpu = M, max.cpu.glob = M,
      create.table = FALSE, create.hash = TRUE, pseudo.paral = TRUE,
      burn.in = 100, print.freq = 1000,
      advanced.param = list(
        max.N.glob = as.integer(10), min.N.glob = as.integer(5),
        max.N = as.integer(3), min.N = as.integer(1), printable = FALSE
      )
    )
  )

  for (jjjj in 1:10)
  {
    resw &lt;- as.integer(res$predictions &gt;= 0.1 * jjjj)
    prec &lt;- (1 - sum(abs(resw - test$X), na.rm = TRUE) / length(resw))
    print(prec)
    # FNR
    ps &lt;- which(test$X == 1)
    fnr &lt;- sum(abs(resw[ps] - test$X[ps])) / (sum(abs(resw[ps] - test$X[ps])) + length(ps))

    # FPR
    ns &lt;- which(test$X == 0)
    fpr &lt;- sum(abs(resw[ns] - test$X[ns])) / (sum(abs(resw[ns] - test$X[ns])) + length(ns))
  }

</code></pre>


</div>