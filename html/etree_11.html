<div class="container">

<table style="width: 100%;"><tr>
<td>etree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Energy Tree</h2>

<h3>Description</h3>

<p>Fits an Energy Tree for classification or regression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">etree(
  response,
  covariates,
  weights = NULL,
  minbucket = 5,
  alpha = 0.05,
  R = 1000,
  split_type = "coeff",
  coeff_split_type = "test",
  p_adjust_method = "fdr",
  random_covs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>Response variable, an object of class either
<code>"factor"</code> or <code>"numeric"</code> (for classification and regression,
respectively).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>Set of covariates. Must be provided as a list, where
each element is a different variable. Currently available types and the
form they need to have to be correctly recognized are the following:
</p>

<ul>
<li>
<p> Numeric: numeric or integer vectors;
</p>
</li>
<li>
<p> Nominal: factors;
</p>
</li>
<li>
<p> Functions: objects of class <code>"fdata"</code>;
</p>
</li>
<li>
<p> Graphs: (lists of) objects of class <code>"igraph"</code>.
</p>
</li>
</ul>
<p>Each element (i.e., variable) in the covariates list must have the same
<code>length()</code>, which corresponds to the sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Optional vector of non-negative integer-valued weights to
be used in the fitting process. If not provided, all observations are
assumed to have weight equal to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minbucket</code></td>
<td>
<p>Positive integer specifying the minimum number of
observations that each terminal node must contain. Default is 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Nominal level controlling the probability of type I error in the
Energy tests of independence used for variable selection. Default is 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Number of replicates employed to approximate the sampling
distribution of the test statistic in every Energy test of independence.
Default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_type</code></td>
<td>
<p>Splitting method used when the selected covariate is
structured. It has two possible values: <code>"coeff"</code> for feature vector
extraction, and <code>"cluster"</code> for clustering. See Details for further
information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coeff_split_type</code></td>
<td>
<p>Method to select the split point for the chosen
component when the selected covariate is structured and <code>split_type =
  "coeff"</code>. It has two possible values: <code>"test"</code>, in which case Energy
tests of independence are used, and <code>"traditional"</code>, to employ
traditional methods (Gini index for classification and RSS for regression).
See Details for further information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_adjust_method</code></td>
<td>
<p>Multiple-testing adjustment method for P-values,
which can be set to any of the values provided by
<code>p.adjust.methods</code>. Default is <code>"fdr"</code> for False
Discovery Rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random_covs</code></td>
<td>
<p>Size of the random subset of covariates to choose from
at each split. If set to <code>NULL</code> (default), all the covariates are
considered each time.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>etree()</code> is the main function of the homonym package. It allows
implementing Energy Trees by simply specifying the response variable, the set
of covariates, and possibly some other parameters. The function is specified
in the same way regardless of the task type: the choice between
classification and regression is automatically made depending on the nature
of the response variable.
</p>
<p>Energy Trees (Giubilei et al., 2022) are a recursive partitioning tree-based
model built upon
Conditional Trees (Hothorn et al., 2006). At each step of Energy Trees'
iterative procedure, an Energy test of independence (Szekely et al., 2007) is
performed between the response variable and each of the J covariates. If the
test of global independence (defined as the intersection of the J tests of
partial independence) is not rejected at the significance level set by
<code>alpha</code>, the recursion is stopped; otherwise, the covariate most
associated with the response in terms of P-value is selected for splitting.
When the covariate is traditional (i.e, numeric or nominal), an Energy test
of independence is performed for each possible split point, and the one
yielding the strongest association with the response is chosen. When the
selected covariate is structured, the split procedure is defined by the value
of <code>split_type</code>, and possibly by that of <code>coeff_split_type</code>.
</p>
<p><code>split_type</code> specifies the splitting method for structured covariates.
It has two possible values:
</p>

<ul>
<li> <p><code>"coeff"</code>: in this case, feature vector extraction is used to
transform the structured selected covariate into a set of numeric components
using a representation that is specific to its type. Available
transformations of such a kind are cubic B-spline expansions for functional
data and shell distributions (Carmi et al., 2007) for graphs - obtained
through k-cores (Seidman, 1983), s-cores (Eidsaa and Almaas, 2013), and
d-cores (Giatsidis et al., 2013), for binary, weighted, and directed graphs,
respectively. Then, the component most associated with the response is
selected using Energy tests of independence (Szekely et al., 2007), and the
split point for that component is chosen using the method defined by
<code>coeff_split_type</code>;
</p>
</li>
<li> <p><code>"cluster"</code>: in this case, the observed values for the structured
selected covariate are used within a Partitioning Around Medoids (Kaufmann
and Rousseeuw, 1987) step to split observations into the two kid nodes.
Medoids calculation and units assignment are performed using
<code>pam()</code>. Distances are specific to each type of
variable (see <code>dist_comp()</code> for details).
</p>
</li>
</ul>
<p><code>coeff_split_type</code> defines the method to select the split point for the
chosen component of the selected structured covariate if and only if
<code>split_type = "coeff"</code>. It has two possible values:
</p>

<ul>
<li> <p><code>"test"</code>: an Energy test of independence (Szekely et al., 2007) is
performed for each possible split point of the chosen component, and the one
yielding the strongest association with the response is selected;
</p>
</li>
<li> <p><code>"traditional"</code>: the split point for the chosen component is
selected as the one minimizing the Gini index (for classification) or the RSS
(for regression) in the two kid nodes.
</p>
</li>
</ul>
<h3>Value</h3>

<p>An object of class <code>"etree"</code>, <code>"constparty"</code>, and <code>"party"</code>.
It stores all the information about the fitted tree. Its elements can be
individually accessed using the <code>$</code> operator. Their names and content
are the following:
</p>

<ul>
<li> <p><code>node</code>: a <code>partynode</code> object representing
the basic structure of the tree;
</p>
</li>
<li> <p><code>data</code>: a <code>list</code> containing the data used for the fitting
process. Traditional covariates are included in their original form, while
structured covariates are stored in the form of components if
<code>split_type = "coeff"</code> or as a <code>factor</code> whose levels go from 1 to
the total number of observations if <code>split_type = "cluster"</code>;
</p>
</li>
<li> <p><code>fitted</code>: a <code>data.frame</code> whose number of rows coincides with
the sample size. It includes the fitted terminal node identifiers (in
<code>"(fitted)"</code>) and the response values of all observations (in
<code>"(response)"</code>);
</p>
</li>
<li> <p><code>terms</code>: a <code>terms</code> object;
</p>
</li>
<li> <p><code>names</code> (optional): names of the nodes in the tree. They can be
set using a <code>character</code> vector: if its length is smaller than the number
of nodes, the remaining nodes have missing names; if its length is larger,
exceeding names are ignored.
</p>
</li>
</ul>
<h3>References</h3>

<p>R. Giubilei, T. Padellini, P. Brutti (2022). Energy Trees: Regression and
Classification With Structured and Mixed-Type Covariates. arXiv preprint.
https://arxiv.org/pdf/2207.04430.pdf.
</p>
<p>S. Carmi, S. Havlin, S. Kirkpatrick, Y. Shavitt, and E. Shir (2007). A model
of internet topology using k-shell decomposition. <em>Proceedings of the
National Academy of Sciences</em>, 104(27):11150-11154.
</p>
<p>M. Eidsaa and E. Almaas (2013). S-core network decomposition: A
generalization of k-core analysis to weighted networks. <em>Physical Review
E</em>, 88(6):062819.
</p>
<p>C. Giatsidis, D. M. Thilikos, and M. Vazirgiannis (2013). D-cores: measuring
collaboration of directed graphs based on degeneracy. <em>Knowledge and
information systems</em>, 35(2):311-343.
</p>
<p>T. Hothorn, K. Hornik, and A. Zeileis (2006). Unbiased recursive
partitioning: A conditional inference framework. <em>Journal of
Computational and Graphical Statistics</em>, 15(3):651-674.
</p>
<p>L. Kaufmann and P. Rousseeuw (1987). Clustering by means of medoids.
<em>Data Analysis based on the L1-Norm and Related Methods</em>, pages 405-416.
</p>
<p>S. B. Seidman (1983). Network structure and minimum degree. <em>Social
networks</em>, 5(3):269-287.
</p>
<p>G. J. Szekely, M. L. Rizzo, and N. K. Bakirov (2007). Measuring and testing
dependence by correlation of distances. <em>The Annals of Statistics</em>,
35(6):2769-2794.
</p>


<h3>See Also</h3>

<p><code>ctree()</code> for the <code>partykit</code> implementation of
Conditional Trees (Hothorn et al., 2006).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Covariates
nobs &lt;- 100
cov_num &lt;- rnorm(nobs)
cov_nom &lt;- factor(rbinom(nobs, size = 1, prob = 0.5))
cov_gph &lt;- lapply(1:nobs, function(j) igraph::sample_gnp(100, 0.2))
cov_fun &lt;- fda.usc::rproc2fdata(nobs, seq(0, 1, len = 100), sigma = 1)
cov_list &lt;- list(cov_num, cov_nom, cov_gph, cov_fun)

## Response variable(s)
resp_reg &lt;- cov_num ^ 2
y &lt;- round((cov_num - min(cov_num)) / (max(cov_num) - min(cov_num)), 0)
resp_cls &lt;- factor(y)

## Regression ##
etree_fit &lt;- etree(response = resp_reg, covariates = cov_list)
print(etree_fit)
plot(etree_fit)
mean((resp_reg - predict(etree_fit)) ^ 2)

## Classification ##
etree_fit &lt;- etree(response = resp_cls, covariates = cov_list)
print(etree_fit)
plot(etree_fit)
table(resp_cls, predict(etree_fit))


</code></pre>


</div>