<div class="container">

<table style="width: 100%;"><tr>
<td>endorse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fitting the Measurement Model of Political Support via Markov Chain
Monte Carlo
</h2>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of the
measurement model of political support. Individual-level covariates
may be included in the model. The details of the model are given under
‘Details’. See also Bullock et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class="language-R">endorse(Y, data, data.village = NA, village = NA, treat = NA,
        na.strings = 99, identical.lambda = TRUE,
        covariates = FALSE, formula.indiv = NA,
        hierarchical = FALSE, formula.village = NA, h = NULL,
        group = NULL, x.start = 0, s.start = 0,
        beta.start = 1, tau.start = NA, lambda.start = 0,
        omega2.start = .1, theta.start = 0, phi2.start = .1,
        kappa.start = 0, psi2.start = 1, delta.start = 0,
        zeta.start = 0, rho2.start = 1, mu.beta = 0, mu.x = 0,
        mu.theta = 0, mu.kappa = 0, mu.delta = 0, mu.zeta = 0,
        precision.beta = 0.04, precision.x = 1,
        precision.theta = 0.04, precision.kappa = 0.04,
        precision.delta = 0.04, precision.zeta = 0.04,
        s0.omega2= 1, nu0.omega2 = 10, s0.phi2 = 1,
        nu0.phi2 = 10, s0.psi2 = 1, nu0.psi2 = 10,
        s0.sig2 = 1, nu0.sig2 = 400, s0.rho2 = 1,
        nu0.rho2 = 10, MCMC = 20000, burn = 1000, thin = 1,
        mh = TRUE, prop = 0.001, x.sd = TRUE,
        tau.out = FALSE, s.out = FALSE, omega2.out = TRUE,
        phi2.out = TRUE, psi2.out = TRUE, verbose = TRUE,
        seed.store = FALSE, update = FALSE,
        update.start = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>a list of the variable names for the responses. It should
take the following form:
</p>
<p><code>list(Q1 = c("varnameQ1.1", "varnameQ1.2", ...),...)</code>.
</p>
<p>If <code>treat</code> is <code>NA</code>, the first
variable for each question should be the responses of the
control observations while each of the other variables should
correspond to each endorser. <code>treat</code> should be supplied if
only one variable name is provided for a question in this argument.
If auxiliary information is included, it is assumed that <code>Y</code> is 
coded such that higher values indicate more of the sensitive trait.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data frame containing the individual-level variables.
The cases must be complete, i.e., no <code>NA</code>'s are allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.village</code></td>
<td>
<p>data frame containing the village-level variables.
The cases must be complete, i.e., no <code>NA</code>'s are allowed. If 
auxiliary information is included, the data frame should include only
the unique group identifier and the unique identifier for the units at 
which prediction is desired. The package does not currently support 
the inclusion of covariates in models with auxiliary information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>village</code></td>
<td>
<p>character.  The variable name of the village indicator
in the individual-level data. If auxiliary information is included,
this should correspond to the variable name of the units at which
prediction is desired. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treat</code></td>
<td>
<p>An optional matrix of non negative integers indicating
the treatment
status of each observation and each question.
Rows are observations
and columns are questions. 0 represents the control status while
positive integers indicate treatment statuses.
If <code>treat</code> is set to <code>NA</code>, the function generates the    
treatment matrix using <code>Y</code>.
The default is <code>NA</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.strings</code></td>
<td>
<p>a scalar or a vector indicating the values of the
response variable that are to be interpreted as “Don't Know” or
“Refused to Answer.” The value should not be <code>NA</code> unless
<code>treat</code> is provided, because <code>NA</code>'s are interpreted as the
response to the question with another endorsement. Default is
<code>99</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>identical.lambda</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the model with a common
lambda across questions will be fitted.  The default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>logical. If <code>TRUE</code>, the model includes
individual-level covariates. The default is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula.indiv</code></td>
<td>
<p>a symbolic description specifying the individual level 
covariates for the support parameter and the ideal points. The formula
should be one-sided, e.g. <code> ~ Z1 + Z2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hierarchical</code></td>
<td>
<p>logical.  IF <code>TRUE</code>, the hierarchical model with
village level predictors will be fitted.  The default is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula.village</code></td>
<td>
<p>a symbolic description specifying the village level 
covariates for the support parameter and the ideal points. The formula
should be one-sided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Auxiliary data functionality. Optional named numeric vector with 
length equal to number of groups. Names correspond to group labels and 
values correspond to auxiliary moments (i.e. to the known share
of the sensitive trait at the group level).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Auxiliary data functionality. Optional character string.  
The variable name of the group indicator in the individual-level data 
(e.g. <code>group = "county"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.start</code></td>
<td>
<p>starting values for the ideal points vector <code class="reqn">x</code>. If
<code>x.start</code> is set to a scalar, the starting values for the ideal
points of all respondents will be set to the scalar. If
<code>x.start</code> is a vector of the same length as the number of
observations, then this vector will be used as the starting
values. The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.start</code></td>
<td>
<p>starting values for the support parameter, <code class="reqn">s_ijk</code>.
If <code>s.start</code> is set to a scalar, the starting values for the
support parameter of all respondents and all questions will be the
scalar.
If <code>s.start</code> is set to a matrix, it should have the same number
of rows as the number of observations and the same number of columns
as the number of questions. Also, the value should be zero for the
control condition.
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.start</code></td>
<td>
<p>starting values for the question related parameters,
<code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.
If <code>beta.start</code> is set to a scalar, the starting values for the
support parameter of all respondents and all questions will be the
scalar.
If <code>beta.start</code> is set to a matrix, the number
of rows should be the number of questions and the number of columns
should be 2.
The first column
will be the starting values for <code class="reqn">\alpha_j</code> and the second column
will be the starting values for <code class="reqn">\beta_j</code>.
Since the parameter values are constrained to be positive, the starting
values should be also positive.
The default is <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.start</code></td>
<td>
<p>starting values for the cut points in the response
model. If <code>NA</code>, the function generates the starting values
so that each interval between the cut points is 0.5.
If <code>tau.start</code> is set to a matrix, the number of rows should be
the same as the number of questions and the number of columns should
be the maximum value of the number of categories in the responses.
The first cut point for each question should be set to 0 while the
last one set to the previous cut point plus 1000.
The default is <code>NA</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.start</code></td>
<td>
<p>starting values for the coefficients in the
support parameter model, <code class="reqn">\lambda_jk</code>.
If <code>lambda.start</code> is set to a scalar, the starting values for
all coefficients will be the scalar.
If <code>lambda.start</code> is set to a matrix, the number of rows should
be the number of the individual level covariates (plus the number of villages, if the model
is hierarchical),
and the number of columns should be the number of
endorsers (times the number of questions, if the model is with varying lambdas).
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega2.start</code></td>
<td>
<p>starting values for the variance of the support
parameters, <code class="reqn">\omega_{jk}^{2}</code>.
If set to a scalar, the starting values for
<code class="reqn">omega_{jk}^{2}</code> will be the diagonal matrix with
the diagonal elements set to the scalar.
If <code>omega2.start</code> is set to a matrix, the number of rows should
be the number of questions, 
while the number of columns should be the same as the number of
endorsers.
The default is <code>.1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.start</code></td>
<td>
<p>starting values for the means of the
<code class="reqn">\lambda_{jk}</code> for each endorser.
If <code>theta.start</code> is set to a scalar, the starting values for
all parameters will be the scalar.
If <code>theta.start</code> is set to a matrix, the number of rows should
be the number of endorsers and the number of columns should be the
dimension of covariates.
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi2.start</code></td>
<td>
<p>starting values for the covariance matrices of the
coefficients
of the support parameters, <code class="reqn">\Phi_{k}</code>.
<code class="reqn">\Phi_{k}</code> is assumed to be a diagonal matrix.
If <code>phi2.start</code> is set to a scalar, the starting values for
all covariance matrices will be the same diagonal matrix with the
diagonal elements set to the scalar.
If <code>phi2.start</code> is set to a vector, the length should be the
number of endorsers times the dimension of covariates.
The default is <code>.1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa.start</code></td>
<td>
<p>starting values for the coefficients on village level covariates in the
support parameter model, <code class="reqn">\kappa_k</code>.
If <code>kappa.start</code> is set to a scalar, the starting values for
all coefficients will be the scalar.
If <code>kappa.start</code> is set to a matrix, the number of rows should
be the number of the village level covariates,
and the number of columns should be the number of
endorsers (times the number of questions, if the varying-lambda
model is fitted).
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi2.start</code></td>
<td>
<p>starting values for the variance of the village random intercepts in the support
parameter model, <code class="reqn">\psi_{k}^{2}</code>.
If <code>psi2.start</code> is set to a scalar, the starting values for
<code class="reqn">\psi_{k}^{2}</code> will be the diagonal matrix with
the diagonal elements set to the scalar.
If <code>psi2.start</code> is set to a vector, its length should
be the number of endorsers (times the number of questions, if the
varying-lambda model is fitted).
The default is <code>.1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.start</code></td>
<td>
<p>starting values for the coefficients on individual level covariates in the ideal
point model. Will be used only if <code>covariates = TRUE</code>.
If <code>delta.start</code> is set to a scalar, the starting values for
all coefficients will be the scalar.
If <code>delta.start</code> is set to a vector, the length should be the
dimension of covariates.
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeta.start</code></td>
<td>
<p>starting values for the coefficients on village level covariates in the ideal
point model. Will be used only if <code>covariates = TRUE</code>.
If <code>zeta.start</code> is set to a scalar, the starting values for
all coefficients will be the scalar.
If <code>zeta.start</code> is set to a vector, the length should be the
dimension of covariates.
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho2.start</code></td>
<td>
<p>numeric. starting values for the variance of the village random intercepts in the ideal point
model, <code class="reqn">\rho^{2}</code>. The default is <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.beta</code></td>
<td>
<p>the mean of the independent Normal prior on the
question related parameters. Can be either a scalar or a matrix of
dimension the number of questions times 2.
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.x</code></td>
<td>
<p>the mean of the independent Normal prior on the
question related parameters. Can be either a scalar or a vector of
the same length as the number of observations.
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.theta</code></td>
<td>
<p>the mean of the independent Normal prior on the
mean of the coefficients in the support parameter model.
Can be either a scalar or a vector of
the same length as the dimension of covariates.
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.kappa</code></td>
<td>
<p>the mean of the independent Normal prior on the
coefficients of village level covariates. Can be either a scalar or a matrix of
dimension the number of covariates times the number of endorsers.
If auxiliary information is included, the value of <code>mu.kappa</code> 
will be computed for each group such that the prior probability of
the support parameter taking a positive value is equal to the known
value of <code>h</code>.
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.delta</code></td>
<td>
<p>the mean of the independent Normal prior on the
the coefficients in the ideal point model.
Can be either a scalar or a vector of
the same length as the dimension of covariates.
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.zeta</code></td>
<td>
<p>the mean of the independent Normal prior on the
the coefficients of village level covariates in the ideal point model.
Can be either a scalar or a vector of
the same length as the dimension of covariates.
The default is <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision.beta</code></td>
<td>
<p>the precisions (inverse variances) of the
independent Normal prior on the
question related parameters. Can be either a scalar or
a 2 <code class="reqn">\times</code> 2 diagonal matrix.
The default is <code>0.04</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision.x</code></td>
<td>
<p>scalar. The known precision of the
independent Normal distribution on the
ideal points.
The default is <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision.theta</code></td>
<td>
<p>the precisions of the
independent Normal prior on the means of the coefficients
in the support parameter model. Can be either a scalar or
a vector of the same length as the dimension of covariates.
The default is <code>0.04</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision.kappa</code></td>
<td>
<p>the precisions of the
independent Normal prior on the coefficients of village level covariates
in the support parameter model. Can be either a scalar or
a vector of the same length as the dimension of covariates.
If auxiliary information is included, the value of <code>precision.kappa</code> 
will be fixed to <code>100000</code>.
The default is <code>0.04</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision.delta</code></td>
<td>
<p>the precisions of the
independent Normal prior on the the coefficients
in the ideal point model. Can be either a scalar or
a square matrix of the same dimension as the dimension of
covariates.
The default is <code>0.04</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision.zeta</code></td>
<td>
<p>the precisions of the
independent Normal prior on the the coefficients of village level covariates
in the ideal point model. Can be either a scalar or
a square matrix of the same dimension as the dimension of
covariates.
The default is <code>0.04</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s0.omega2</code></td>
<td>
<p>scalar. The scale of the independent scaled
inverse- chi-squared    
prior for the variance parameter in the support parameter model.
If auxiliary information is included, the value of <code>s0.omega2</code> 
will be fixed to the default.
The default is <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu0.omega2</code></td>
<td>
<p>scalar. The degrees of freedom of the independent
scaled inverse-chi-squared    
prior for the variance parameter in the support parameter model.
If auxiliary information is included, the value of <code>nu0.omega2</code> 
will be fixed to the default.
The default is <code>10</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s0.phi2</code></td>
<td>
<p>scalar. The scale of the independent
scaled inverse-chi-squared
prior for the variances of the coefficients in
the support parameter model.
The default is <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu0.phi2</code></td>
<td>
<p>scalar. The degrees of freedom of the independent
scaled
inverse-chi-squared
prior for the variances of the coefficients in
the support parameter model.
The default is <code>10</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s0.psi2</code></td>
<td>
<p>scalar. The scale of the independent
scaled inverse-chi-squared
prior for the variances of the village random intercepts in
the support parameter model.
The default is <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu0.psi2</code></td>
<td>
<p>scalar. The degrees of freedom of the independent
scaled
inverse-chi-squared
prior for the variances of the village random intercepts in
the support parameter model.
The default is <code>10</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s0.sig2</code></td>
<td>
<p>scalar. The scale of the independent
scaled inverse-chi-squared
prior for the variance parameter in
the ideal point model.
The default is <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu0.sig2</code></td>
<td>
<p>scalar. The degrees of freedom of the independent
scaled
inverse-chi-squared
prior for the variance parameter in the ideal point model.
The default is <code>400</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s0.rho2</code></td>
<td>
<p>scalar. The scale of the independent
scaled inverse-chi-squared
prior for the variances of the village random intercepts in
the ideal point model.
The default is <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu0.rho2</code></td>
<td>
<p>scalar. The degrees of freedom of the independent
scaled
inverse-chi-squared
prior for the variances of the village random intercepts in
the ideal point model.
The default is <code>10</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC</code></td>
<td>
<p>the number of iterations for the sampler. The default is
<code>20000</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>
<p>the number of burn-in iterations for the sampler. The
default is <code>1000</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>the thinning interval used in the simulation. The default
is <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mh</code></td>
<td>
<p>logical. If <code>TRUE</code>, the Metropolis-Hastings algorithm
is used to sample the cut points in the response model. The default is
<code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop</code></td>
<td>
<p>a positive number or a vector consisting of positive
numbers. The length of the vector should be the same as the number of
questions. This argument sets proposal variance for the
Metropolis-Hastings algorithm in sampling the cut points of the
response model. The default is <code>0.001</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.sd</code></td>
<td>
<p>logical. If <code>TRUE</code>, the standard deviation of the
ideal points in each draw will be stored. If <code>FALSE</code>, a sample of
the ideal points will be stored. <em>NOTE: Because storing a sample
takes an enormous amount of memory, this option should be
selected only if the chain is thinned heavily or the data have a small
number of observations.</em>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.out</code></td>
<td>
<p>logical. A switch that determines whether or not to
store the cut points in the response model. The default is
<code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.out</code></td>
<td>
<p>logical. If <code>TRUE</code>, the support parameter for each
respondent and each question will be stored.
The default is <code>FALSE</code>. <em>NOTE: Because storing a sample
takes an enormous amount of memory, this option should be
selected only if the chain is thinned heavily or the data have a small
number of observations.</em>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega2.out</code></td>
<td>
<p>logical. If <code>TRUE</code>, the variannce parameter of the support
parameter model will be stored.
The default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi2.out</code></td>
<td>
<p>logical. If <code>TRUE</code>, the variannce parameter of the model
for the coefficients in the support parameter model will be stored.
The default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi2.out</code></td>
<td>
<p>logical. If <code>TRUE</code>, the variance of the village random intercepts 
in the support parameter model  will be stored.
The default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical. A switch that determines whether or not to
print the progress of the chain and Metropolis acceptance ratios for
the cut points of the response model. The default is
<code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed.store</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the seed will be stored in order
to update the chain later.  The default is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update</code></td>
<td>
<p>logical.  If <code>TURE</code>, the function is run to update a chain.
The default is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update.start</code></td>
<td>
<p>list.  If the function is run to update a chain, the output
object of the previous run should be supplied.  The default is <code>NULL</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model takes the following form:
</p>
<p>Consider an endorsement experiment where we wish to measure the level
of support for <code class="reqn">K</code> political
actors.  In the survey, respondents are asked whether or
not they support each of <code class="reqn">J</code> policies chosen by researchers.
Let <code class="reqn">Y_{ij}</code> represent respondent
<code class="reqn">i</code>'s answer to the survey question regarding policy <code class="reqn">j</code>.
Suppose that the response variable <code class="reqn">Y_{ij}</code> is the ordered factor
variable taking one of <code class="reqn">L_{j}</code> levels, i.e., <code class="reqn">Y_{ij} \in \{0,
    1, \dots,
  L_{j} - 1\}</code> where <code class="reqn">L_{j} &gt; 1</code>.  We assume that a greater value of
<code class="reqn">Y_{ij}</code>
indicates a greater level of support for policy <code class="reqn">j</code>.
We denote an <code class="reqn">M</code> dimensional vector of the observed
characteristics of respondent <code class="reqn">i</code> by <code class="reqn">Z_i</code>.
</p>
<p>In the experiment, we
randomly assign one of <code class="reqn">K</code> political actors as an endorser to
respondent <code class="reqn">i</code>'s question regarding policy <code class="reqn">j</code> and denote this
treatment variable by <code class="reqn">T_{ij} \in \{0,1,\dots,K\}</code>.  We use
<code class="reqn">T_{ij}=0</code> to represent the control observations where no
political endorsement is attached to the question. Alternatively, one
may use the endorsement by a neutral actor as the control group.
</p>
<p>The model for the response variable, <code class="reqn">Y_{ij}</code>, is given by,
</p>
<p style="text-align: center;"><code class="reqn">Y_{ij} = l \; {\rm if} \; \tau_{l} &lt; Y^{*}_{ij} \le
    \tau_{l + 1},
  </code>
</p>

<p style="text-align: center;"><code class="reqn">Y^{*}_{ij} \; | \; T_{ij} = k \sim \mathcal{N}(- \alpha_{j} +
    \beta_{j} (x_{i} + s_{ijk}), \; I)
  </code>
</p>

<p>where <code class="reqn">l \in \{0, 1, \dots, L_{j} \}, \tau_{0} = -\infty &lt;
    \tau_{1} = 0 &lt; \tau_{2} &lt; \dots &lt; \tau_{L_{j}} = \infty</code>.
<code class="reqn">\beta_j</code>'s are assumed to be positive.
</p>
<p>The model for the support parameter, <code class="reqn">s_{ijk}</code>, is given by
if <code class="reqn">T_{ij} \neq 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    s_{ijk} \sim \mathcal{N}(Z_i^{T} \lambda_{jk}, \; \omega_{jk}^2)
  </code>
</p>

<p>with covariates, and
</p>
<p style="text-align: center;"><code class="reqn">
    s_{ijk} \sim \mathcal{N}(\lambda_{jk}, \; \omega_{jk}^2),
  </code>
</p>

<p>without covariates, for <code class="reqn">j = 1, \dots, J, \; k = 1, \dots, K</code>,
and if <code class="reqn">T_{ij} = 0, \; s_{ijk} = 0</code>.
</p>
<p>The <code class="reqn">\lambda</code>'s in the support parameter model are modeled in the
following hierarchical manner,
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda_{jk} \sim \mathcal{N}(\theta_k, \; \Phi_k)
  </code>
</p>
  
<p>for <code class="reqn">k = 1, \dots, K</code>.
</p>
<p>If you set <code>identical.lambda = FALSE</code> and <code>hierarchical = TRUE</code>,
the model for <code class="reqn">s_{ijk}</code> is if <code class="reqn">T_{ij} \neq 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    s_{ijk} \sim \mathcal{N}(\lambda^{0}_{jk, village[i]} + Z_i^{T} \lambda_{jk}, \; \omega_{jk}^2)
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda^{0}_{jk, village[i]} \sim \mathcal{N}(V_{village[i]}^{T} \kappa_{jk}, \; \psi_{jk}^2)
  </code>
</p>

<p>for <code class="reqn">k = 1, \dots, K</code> and <code class="reqn">j = 1, \dots, J</code>.  In addition,
<code class="reqn">\lambda</code> and <code class="reqn">\kappa</code> are modeled in the following
hierarchical manner,
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda^{*}_{jk} \sim \mathcal{N}(\theta_k, \; \Phi_k)
  </code>
</p>
  
<p>for <code class="reqn">k = 1, \dots, K</code>, where <code class="reqn">\lambda^{*}_{jk} =
  (\lambda^{T}_{jk}, \kappa^{T}_{jk})^{T}</code>.
</p>
<p>If you set <code>identical.lambda = TRUE</code> and <code>hierarchical = TRUE</code>,
the model for <code class="reqn">s_{ijk}</code> is if <code class="reqn">T_{ij} \neq 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    s_{ijk} \sim \mathcal{N}(\lambda^{0}_{k, village[i]} + Z_i^{T} \lambda_{k}, \; \omega_{k}^2)
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda^{0}_{k, village[i]} \sim \mathcal{N}(V_{village[i]}^{T} \kappa_{k}, \; \psi_{k}^2)
  </code>
</p>

<p>for <code class="reqn">k = 1, \dots, K</code>.
</p>
<p>If the covariates are included in the model, the model for the
ideal points is given by
</p>
<p style="text-align: center;"><code class="reqn">
    x_{i} \sim \mathcal{N}(Z_{i}^{T} \delta, \; \sigma_{x}^{2})
  </code>
</p>

<p>for <code class="reqn">i = 1, \dots, N</code> where <code class="reqn">\sigma_x^2</code> is a known prior
variance.
</p>
<p>If you set <code>hierarchical = TRUE</code>,
the model is
</p>
<p style="text-align: center;"><code class="reqn">
    x_{i} \sim \mathcal{N}(\delta^{0}_{village[i]} + Z_i^{T} \delta, \; \sigma^2)
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    \delta^{0}_{village[i]} \sim \mathcal{N}(V_{village[i]}^{T} \zeta, \; \rho^2)
  </code>
</p>

<p>for <code class="reqn">k = 1, \dots, K</code>.
</p>
<p>Finally, the following independent prior distributions are placed on
unknown parameters,
</p>
<p style="text-align: center;"><code class="reqn">
    \alpha_j \sim \mathcal{N}(\mu_\alpha, \; \sigma_\alpha^2)
  </code>
</p>

<p>for <code class="reqn">j = 1, \dots, J</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    \beta_j \sim \mathcal{TN}_{\beta_j &gt; 0}(\mu_\beta, \; \sigma_\beta^2)
  </code>
</p>

<p>for <code class="reqn">j = 1, \dots, J</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    \delta \sim \mathcal{N}(\mu_\delta, \; \Sigma_\delta),
  </code>
</p>

<p style="text-align: center;"><code class="reqn">
    \theta_k \sim \mathcal{N}(\mu_\theta, \; \Sigma_\theta)
  </code>
</p>

<p>for <code class="reqn">k = 1, \dots, K</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    \omega_{jk}^2 \sim  {\rm Inv-}\chi^{2}(\nu_{\omega}^0, \;
    s_{\omega}^0)
  </code>
</p>

<p>for <code class="reqn">j = 1, \dots, J</code> and <code class="reqn">k = 1, \dots, K</code>, and
</p>
<p style="text-align: center;"><code class="reqn">  
    {\rm diag}(\Phi_k) \sim  {\rm Inv-}\chi^{2}(\nu_{\Phi}^0, \;
    s_{\Phi}^0)
  </code>
</p>

<p>for <code class="reqn">k = 1, \dots, K</code>, where <code class="reqn">\Phi_k</code> is assumed to be a
diagonal matrix.
</p>


<h3>Value</h3>

<p>An object of class <code>"endorse"</code>, which is a list containing the following
elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>an <code>"mcmc"</code> object. A sample from the posterior distribution
of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>If <code>x.sd = TRUE</code>, a vector of the standard deviation of
the ideal points in each draw. If <code>x.sd = FALSE</code>, an mcmc
object that contains a sample from the posterior distribution of the
ideal points.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>If <code>s.out = TRUE</code>, an mcmc object that contains a sample
from the posterior distribution of <code class="reqn">s_{ijk}</code>.  Variable
names are:
</p>
<p><code>s(observation id)(question id)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>If <code>covariates = TRUE</code>, an mcmc object that contains
a sample from the posterior distribution of <code class="reqn">\delta</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>If <code>tau.out = TRUE</code>, an mcmc object that contains a
sample from the posterior distribution of <code class="reqn">\tau</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>an mcmc object. A sample from the posterior distribution
of <code class="reqn">\lambda</code>.  Variable names are:
</p>
<p><code>lambda(question id)(group id).(covariate id)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>an mcmc object. A sample from the posterior distribution
of <code class="reqn">\theta</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>an mcmc object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeta</code></td>
<td>
<p>an mcmc object.
</p>
</td>
</tr>
</table>
<p>Note that the posterior sample of all parameters are NOT
standardized. In making posterior inference, each parameter should be
divided by the standard deviation of x (in the default setting, it is
given as "x") or by <code class="reqn">\sigma^2</code> (in the default setting, it
is given as "sigma2").
</p>
<p>Also note that <code class="reqn">\alpha</code> and the intercept in
<code class="reqn">\delta</code> (or, if the model is hierarchical, the intercept
in <code class="reqn">\zeta</code>) are not identified.  Instead,
</p>
<p style="text-align: center;"><code class="reqn">  
    - \alpha + \beta * \delta_0
  </code>
</p>

<p>or, if the model is hierarchical,
</p>
<p style="text-align: center;"><code class="reqn">  
    - \alpha + \beta * \zeta_0
  </code>
</p>

<p>is identified after either of the above standardization, where
<code class="reqn">\delta_0</code> and <code class="reqn">\zeta_0</code> denote the
intercepts.
</p>
<p>When using the auxiliary data functionality, the following objects are included:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>aux</code></td>
<td>
<p>logical value indicating whether estimation incorporates auxiliary moments
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nh</code></td>
<td>
<p>integer count of the number of auxiliary moments
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Yuki Shiraito, Department of Political Science, University of Michigan <a href="mailto:shiraito@umich.edu">shiraito@umich.edu</a>
</p>
<p>Kosuke Imai, Department of Government and Statistics, Harvard University
<a href="mailto:Imai@Harvard.Edu">Imai@Harvard.Edu</a>, <a href="https://imai.fas.harvard.edu">https://imai.fas.harvard.edu</a>
</p>


<h3>References</h3>

<p>Bullock, Will, Kosuke Imai, and Jacob N. Shapiro. (2011)
“Statistical Analysis of Endorsement Experiments: Measuring
Support for Militant Groups in Pakistan,” <em>Political Analysis</em>,
Vol. 19, No. 4 (Autumn), pp.363-384.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(pakistan)

Y &lt;- list(Q1 = c("Polio.a", "Polio.b", "Polio.c", "Polio.d", "Polio.e"),
          Q2 = c("FCR.a", "FCR.b", "FCR.c", "FCR.d", "FCR.e"),
          Q3 = c("Durand.a", "Durand.b", "Durand.c", "Durand.d",
                 "Durand.e"),
          Q4 = c("Curriculum.a", "Curriculum.b", "Curriculum.c",
                 "Curriculum.d", "Curriculum.e"))



## Varying-lambda non-hierarchical model without covariates
endorse.out &lt;- endorse(Y = Y, data = pakistan, identical.lambda = FALSE,
                       covariates = FALSE, hierarchical = FALSE)

## Varying-lambda non-hierarchical model with covariates
indiv.covariates &lt;- formula( ~ female + rural)
endorse.out &lt;- endorse(Y = Y, data = pakistan, identical.lambda = FALSE,
                       covariates = TRUE,
                       formula.indiv = indiv.covariates,
                       hierarchical = FALSE)

## Common-lambda non-hierarchical model with covariates
indiv.covariates &lt;- formula( ~ female + rural)
endorse.out &lt;- endorse(Y = Y, data = pakistan, identical.lambda = TRUE,
                       covariates = TRUE,
                       formula.indiv = indiv.covariates,
                       hierarchical = FALSE)

## Varying-lambda hierarchical model without covariates
div.data &lt;- data.frame(division = sort(unique(pakistan$division)))
div.formula &lt;- formula(~ 1)
endorse.out &lt;- endorse(Y = Y, data = pakistan, data.village = div.data,
                       village = "division", identical.lambda = FALSE,
                       covariates = FALSE, hierarchical = TRUE,
                       formula.village = div.formula)

## Varying-lambda hierarchical model with covariates
endorse.out &lt;- endorse(Y = Y, data = pakistan, data.village = div.data,
                       village = "division", identical.lambda = FALSE,
                       covariates = TRUE,
                       formula.indiv = indiv.covariates,
                       hierarchical = TRUE,
                       formula.village = div.formula)

## Common-lambda hierarchical model without covariates
endorse.out &lt;- endorse(Y = Y, data = pakistan, data.village = div.data,
                       village = "division", identical.lambda = TRUE,
                       covariates = FALSE, hierarchical = TRUE,
                       formula.village = div.formula)

## Common-lambda hierarchical model with covariates
endorse.out &lt;- endorse(Y = Y, data = pakistan, data.village = div.data,
                       village = "division", identical.lambda = TRUE,
                       covariates = TRUE,
                       formula.indiv = indiv.covariates,
                       hierarchical = TRUE,
                       formula.village = div.formula)

## End(Not run)
</code></pre>


</div>