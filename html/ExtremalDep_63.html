<div class="container">

<table style="width: 100%;"><tr>
<td>summary_ExtDep</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Summary of MCMC algorithm.</h2>

<h3>Description</h3>

<p>This function computes summaries on the posterior sample obtained from the adaptive MCMC scheme for the non-parametric estimation of a bivariate dependence structure.</p>


<h3>Usage</h3>

<pre><code class="language-R">summary_ExtDep(object, mcmc, burn, cred=0.95, plot=FALSE, ...)    
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A vector of values on <code class="reqn">[0,1]</code>. If missing, a regular grid of length <code class="reqn">100</code> is considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>An output of the <code>fExtDep.np</code> function with <code>method="Bayesian"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>
<p>A positive integer indicating the burn-in period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cred</code></td>
<td>
<p>A value in <code class="reqn">[0,1]</code> indicating the level of the credibility intervals to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>A logical value; if <code>TRUE</code> a summary of the estimated dependence is displayed by calling the <code>plot_ExtDep.np</code> function with <code>type="summary"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional graphical parameters for <code>plot_ExtDep.np</code> when <code>plot=TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For each value say <code class="reqn">\omega \in [0,1]</code> given, the complement <code class="reqn">1-\omega </code> is automatically computed to define the observation <code class="reqn">(\omega,1-\omega)</code> on the bivariate unit simplex.
</p>
<p>It is obvious that the value of <code>burn</code> must be greater than the number of iterations in the mcmc algorithm. This can be found in <code>mcmc</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>

<dl>
<dt>k.median, k.up, k.low:</dt>
<dd>
<p>Posterior median, upper and lower bounds of the CI for the estimated Bernstein polynomial degree <code class="reqn">\kappa</code>;</p>
</dd>
<dt>h.mean, h.up, h.low:</dt>
<dd>
<p>Posterior mean, upper and lower bounds of the CI for the estimated angular density <code class="reqn">h</code>;</p>
</dd>
<dt>A.mean, A.up, A.low:</dt>
<dd>
<p>Posterior mean, upper and lower bounds of the CI for the estimated Pickands dependence function <code class="reqn">A</code>;</p>
</dd>
<dt>p0.mean, p0.up, p0.low:</dt>
<dd>
<p>Posterior mean, upper and lower bounds of the CI for the estimated point mass <code class="reqn">p_0</code>;</p>
</dd>
<dt>p1.mean, p1.up, p1.low:</dt>
<dd>
<p>Posterior mean, upper and lower bounds of the CI for the estimated point mass <code class="reqn">p_1</code>;</p>
</dd>
<dt>A_post:</dt>
<dd>
<p>Posterior sample for Pickands dependence function;</p>
</dd>
<dt>h_post:</dt>
<dd>
<p>Posterior sample for angular density;</p>
</dd>
<dt>eta.diff_post:</dt>
<dd>
<p>Posterior sample for the Bernstein polynomial coefficients (<code class="reqn">\eta</code> parametrisation);</p>
</dd>
<dt>beta_post:</dt>
<dd>
<p>Posterior sample for the Bernstein polynomial coefficients (<code class="reqn">\beta</code> parametrisation);</p>
</dd>
<dt>p0_post, p1_post:</dt>
<dd>
<p>Posterior sample for point masses <code class="reqn">p_0</code> and <code class="reqn">p_1</code>;</p>
</dd>
<dt>w:</dt>
<dd>
<p>A vector of values on the bivariate simplex where the angular density and Pickands dependence function were evaluated;</p>
</dd>
<dt>burn:</dt>
<dd>
<p>The argument provided;</p>
</dd>
</dl>
<p>If the margins were also fitted, the list given as <code>object</code> would contain <code>mar1</code> and <code>mar2</code> and the function would also output:
</p>

<dl>
<dt>mar1.mean, mar1.up, mar1.low:</dt>
<dd>
<p>Posterior mean, upper and lower bounds of the CI for the estimated marginal parameter on the first component;</p>
</dd>
<dt>mar2.mean, mar2.up, mar2.low:</dt>
<dd>
<p>Posterior mean, upper and lower bounds of the CI for the estimated marginal parameter on the second component;</p>
</dd>
<dt>mar1_post:</dt>
<dd>
<p>Posterior sample for the estimated marginal parameter on the first component;</p>
</dd>
<dt>mar2_post: </dt>
<dd>
<p>Posterior sample for the estimated marginal parameter on the second component;</p>
</dd>  
</dl>
<h3>Author(s)</h3>

<p>Simone Padoan, <a href="mailto:simone.padoan@unibocconi.it">simone.padoan@unibocconi.it</a>,
<a href="https://faculty.unibocconi.it/simonepadoan/">https://faculty.unibocconi.it/simonepadoan/</a>;
Boris Beranger, <a href="mailto:borisberanger@gmail.com">borisberanger@gmail.com</a>
<a href="https://www.borisberanger.com">https://www.borisberanger.com</a>
</p>


<h3>See Also</h3>

<p><code>fExtDep.np</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">
####################################################
### Example - Pollution levels in Milan, Italy ###
####################################################
	
## Not run: 

### Here we will only model the dependence structure	
data(MilanPollution)

data &lt;- Milan.winter[,c("NO2","SO2")] 
data &lt;- as.matrix(data[complete.cases(data),])

# Thereshold
u &lt;- apply(data, 2, function(x) quantile(x, prob=0.9, type=3))

# Hyperparameters
hyperparam &lt;- list(mu.nbinom = 6, var.nbinom = 8, a.unif=0, b.unif=0.2)

### Standardise data to univariate Frechet margins

f1 &lt;- fGEV(data=data[,1], method="Bayesian", sig0 = 0.0001, nsim = 5e+4)
diagnostics(f1)
burn1 &lt;- 1:30000
gev.pars1 &lt;- apply(f1$param_post[-burn1,],2,mean)
sdata1 &lt;- trans2UFrechet(data=data[,1], pars=gev.pars1, type="GEV")

f2 &lt;- fGEV(data=data[,2], method="Bayesian", sig0 = 0.0001, nsim = 5e+4)
diagnostics(f2)
burn2 &lt;- 1:30000
gev.pars2 &lt;- apply(f2$param_post[-burn2,],2,mean)
sdata2 &lt;- trans2UFrechet(data=data[,2], pars=gev.pars2, type="GEV")

sdata &lt;- cbind(sdata1,sdata2)

### Bayesian estimation using Bernstein polynomials

pollut1 &lt;- fExtDep.np(method="Bayesian", data=sdata, u=TRUE,
                      mar.fit=FALSE, k0=5, hyperparam = hyperparam, nsim=5e+4)

diagnostics(pollut1)
pollut1_sum &lt;- summary_ExtDep(mcmc=pollut1, burn=3e+4, plot=TRUE)

## End(Not run)
	
</code></pre>


</div>