<div class="container">

<table style="width: 100%;"><tr>
<td>subNonStandardNames</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
sub for nonstandard names
</h2>

<h3>Description</h3>

<p><code>sub(nonStandardNames[, 1], 
  nonStandardNames[, 2], x)</code>
</p>
<p>Accented characters common in non-English 
languages often get mangled in different 
ways by different software.  For example, 
the "e" in "Andre" may carry an accent that 
gets replaced by other characters by different 
software.  
</p>
<p>This function first converts <code>"Andr*"</code> 
to <code>"Andr_"</code> for any character "*" not 
in <code>standardCharacters</code>.  It then looks 
for <code>"Andr_"</code> in <code>nonStandardNames</code>.  
By default, it will find that and replace it 
with "Andre".  
</p>


<h3>Usage</h3>

<pre><code class="language-R">subNonStandardNames(x,
  standardCharacters=c(letters, LETTERS, ' ', 
    '.', '?', '!', ',', 0:9,   '/', '*', '$', 
    '%', '\"', "\'", '-', '+', '&amp;', '_', ';', 
    '(', ')', '[', ']', '\n'),
  replacement='_',
  gsubList=list(list(pattern=
        '\\\\\\\\|\\\\',
      replacement='\"')),
  removeSecondLine=TRUE,
  nonStandardNames=Ecdat::nonEnglishNames, 
  namesNotFound="attr.replacement", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>character vector or matrix or a 
<code>data.frame</code> of character vectors in 
which it is desired replace
<code>nonStandardNames[, 1]</code> in 
<code>subNonStandardCharacters(x, ...)</code> 
with the corresponding element of 
<code>nonStandardNames[, 2]</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardCharacters, replacement, 
gsubList, ...</code></td>
<td>

<p>arguments passed to 
<code>subNonStandardCharacters</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeSecondLine</code></td>
<td>

<p>logical:  If <code>TRUE</code>, delete anything
following <code>"\n"</code> and return it as 
an attribute <code>secondLine</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonStandardNames</code></td>
<td>

<p><code>data.frame</code> or character matrix with 
two columns: 
Replace any substring of <code>x</code> matching 
<code>nonStandardNames[, 1]</code> with the 
corresponding element of 
<code>nonStandardNames[, 2]</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>namesNotFound</code></td>
<td>

<p>character vector describing how to treat 
substitutions not found in 
<code>nonStandardNames[, 1]</code>:  
</p>

<ul>
<li>
<p><code>attr.replacement</code>: Return an 
attribute <code>namesNotFound</code> with 
<code>grep(replacement, 
          subNonStandardCharacters(...))</code>, 
if any.

</p>
</li>
<li>
<p><code>attr.notFound</code>:  
Return an attribute <code>namesNotFound</code>  
with <code>x != 
        subNonStandardCharacters(...)</code>, 
if any.

</p>
</li>
<li>
<p>"print":  Print the elements of 
<code>x</code> <code>notFound</code> per either
<code>attr.replacement</code> or 
<code>attr.notFound</code>, as requested.
  
</p>
</li>
<li>
<p>"":  Do not report any <code>notFound</code> 
elements of <code>x</code>.

</p>
</li>
</ul>
<p>NOTE:  x = "_" will be identified by 
<code>attr.replacement</code> but not by 
<code>attr.notfound</code> assuming the default 
value for <code>replacement</code>. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>1.  <code>removeSecondLine</code>s
</p>
<p>2.  <code>x. &lt;- subNonStandardCharacters(x, 
  standardCharacters, replacement, ...)</code>
</p>
<p>3.  Loop over all rows of 
<code>nonStandardNames</code> substituting 
anything matching 
<code>nonStandardNames[i, 1]</code> with 
<code>nonStandardNames[i, 2]</code>.
</p>
<p>4.  Eliminate leading and trailing blanks.
</p>
<p>5.  <code>if(is.matrix(x))</code> return a matrix;  
<code>if(is.data.frame(x))</code> return a 
<code>data.frame(..., stringsAsFactors=FALSE)</code> 
</p>
<p>NOTE: On 13 May 2013 Jeff Newmiller at the
University of California, Davis, wrote, 'I 
think it is a fools errand to think that you 
can automatically "normalize" arbitrary Unicode
characters to an ASCII form that everyone will
agree on.'  (This was a reply on 
<code>r-help@r-project.org</code>, subject:  "Re: [R]
Matching names with non-English characters".) 
Doubtless someone has software to do a better 
job of this than what this function does, but 
I've so far been unable to find it in R.  If 
you know of a better solution to this problem, 
I'd be pleased to hear from you.  Spencer Graves
</p>


<h3>Value</h3>

<p>a character vector with all 
<code>nonStandardCharacters</code> replaced first by
<code>replacement</code> and then by the second 
column of <code>nonStandardNames</code> for any that
match the first column.  If a <code>secondLine</code> 
is found on any elements, it is returned as a
<code>secondLine</code> attribute. 
</p>
<p>If any names with <code>nonStandardCharacters</code> 
are not found in <code>nonStandardNames[, 1]</code>,
they are identified in an optional attribute 
per the <code>namesNotFound</code> argument.    
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code>sub</code>
<code>nonEnglishNames</code>
<code>subNonStandardCharacters</code>
<code>stripBlanks</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##
## 1.  Example 
##
tstSNSN &lt;- c('Raul', 'Ra`l', 'Torres,Raul', 
    'Torres, Ra`l', "Robert C. \\Bobby\\\\", 
    'Ed  \n --Vacancy', '', '  ')

#  confusion in character sets can create
#  names like Names[2]
##
## 2.  subNonStandardNames(vector)
##

SNS2 &lt;- subNonStandardNames(tstSNSN)
SNS2

# check 
SNS2. &lt;- c('Raul', 'Raul', 'Torres,Raul', 'Torres, Raul',
            'Robert C. "Bobby"', 'Ed', '', '')
attr(SNS2., 'secondLine') &lt;- c(rep(NA, 5), ' --Vacancy',
        NA, NA)


all.equal(SNS2, SNS2.)

##
## 3.  subNonStandardNames(matrix)
##
tstmat &lt;- parseName(tstSNSN, surnameFirst=TRUE)
submat &lt;- subNonStandardNames(tstmat)

# check 
SNSmat &lt;- parseName(SNS2., surnameFirst=TRUE)

all.equal(submat, SNSmat)


##
## 4.  subNonStandardNames(data.frame)
##
tstdf &lt;- as.data.frame(tstmat)
subdf &lt;- subNonStandardNames(tstdf)

# check 
SNSdf &lt;- as.data.frame(SNSmat, stringsAsFactors=FALSE)

all.equal(subdf, SNSdf)


##
## 5.  namesNotFound 
##
noSub &lt;- subNonStandardNames('xx_x')

# check 
noSub. &lt;- 'xx_x'
attr(noSub., 'namesNotFound') &lt;- 'xx_x'

all.equal(noSub, noSub.)

</code></pre>


</div>