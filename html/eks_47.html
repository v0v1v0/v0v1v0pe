<div class="container">

<table style="width: 100%;"><tr>
<td>tidyst_kdr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Tidy and geospatial kernel density ridge estimates</h2>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel density ridge estimates for 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tidy_kdr(data, dTolerance, ...)
st_kdr(x, dTolerance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data frame/tibble of data values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>sf object with point geometry</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dTolerance</code></td>
<td>
<p>tolerance parameter in <code>sf::st_simplify</code> for reducing complexity of density ridge</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other parameters in <code>ks::kdr</code> function</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A density ridge can be interpreted as the line connecting the peaks in the kernel density estimate, like for a mountain range. It can also be interpreted as the filament generalisation of 2-d principal components.  For details of the computation and the bandwidth selection procedure of the kernel density ridge estimate, see <code>?ks::kdr</code>. The bandwidth matrix of smoothing parameters is computed as in <code>ks::kdde(deriv_order=2)</code>.
</p>
<p>To reduce the complexity of the density ridge, a call to <code>sf::st_simplify(,dTolerance)</code> is made. If <code>dTolerance</code> is missing, then it defaults to approximately the mean distance between each pair of consecutive points in each segment of the density ridge. If <code>dTolerance=0</code> then this step of Ramer-Douglas-Peucker simplification is not carried out.
</p>


<h3>Value</h3>

<p>The output from <code>*_kdr</code> have the same structure as the kernel density estimate from <code>*_kde</code>, except that <code>x,y</code> indicate the points on the density ridge, rather than the grid points themselves, and <code>estimate</code> becomes NA. For <code>st_kdr</code>, the density ridge is stored as a multipoints <code>sf</code> object.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## tidy density ridge estimate
library(ggplot2)
data(cardio, package="ks")
cardio &lt;- dplyr::as_tibble(cardio[,c("ASTV","Mean")])
set.seed(8192)
cardio &lt;- cardio[sample(1:nrow(cardio), round(nrow(cardio)/4,0)),]
## gridsize=c(21,21) is for illustrative purposes only
## remove for more complete KDR
t1 &lt;- tidy_kdr(cardio, gridsize=c(21,21))
gt &lt;- ggplot(t1, aes(x=ASTV, y=Mean)) 
gt + geom_point_ks(colour=3, alpha=0.8) + 
    geom_path(aes(colour=label, group=segment), linewidth=1.2, alpha=0.8) +
    scale_colour_manual(values=6)

## geospatial density ridge estimate
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
## gridsize=c(21,21) is for illustrative purposes only 
## remove for more complete KDR
s1 &lt;- st_kdr(hakeoides, gridsize=c(21,21))

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(sf::st_geometry(hakeoides), add=TRUE, col=3, pch=16)
plot(s1, add=TRUE, col=6, lwd=3, alpha=0.8)

## geom_sf plot
gs &lt;- ggplot(s1) + geom_sf(data=wa, fill=NA) + ggthemes::theme_map()
gs + geom_sf(data=hakeoides, colour=3, alpha=0.5) +
    geom_sf(data=s1$sf, aes(colour=label), linewidth=1.2, alpha=0.8) +
    scale_colour_manual(values=6) + coord_sf(xlim=xlim, ylim=ylim) 
</code></pre>


</div>