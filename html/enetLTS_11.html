<div class="container">

<table style="width: 100%;"><tr>
<td>predict.enetLTS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
make predictions from the <code>"enetLTS"</code> object.
</h2>

<h3>Description</h3>

<p>Similar to other predict methods, this function predicts fitted values, logits,
coefficients and nonzero coefficients from a fitted <code>"enetLTS"</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'enetLTS'
predict(object,newX,vers=c("reweighted","raw"),
    type=c("link","response","coefficients","nonzero","class"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>the model fit from which to make predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newX</code></td>
<td>
<p>new values for the predictor matrix <code>X</code>.
Must be a matrix; can be sparse as in <code>Matrix</code> package.
This argument is not used for <code>type=c("coefficients","nonzero")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vers</code></td>
<td>
<p>a character string denoting which fit to use for the predictions.
Possible values are <code>"reweighted"</code> (the default) for
predicting values from the reweighted fit, <code>"raw"</code> for predicting
values from the raw fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of prediction required. <code>type="link"</code> gives the link function.
<code>type="response"</code> gives the
fitted probabilities for <code>"binomial"</code> and gives the fitted values for
<code>"gaussian"</code>. <code>type="coefficients"</code> computes the coefficients from the
fitted model. <code>type="nonzero"</code> returns a list of the indices of the nonzero
coefficients. <code>type="class"</code> is available only for <code>"binomial"</code> model,
and produces the class label corresponding to the maximum probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments from the <code>enetLTS</code> object if needed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>newdata</code> argument defaults to the matrix of predictors used to fit
the model such that the fitted values are computed.
</p>
<p><code>coef.enetLTS(...)</code> is equivalent to <code>predict.enetLTS(object,newX,type="coefficients",...)</code>, where newX argument is the matrix as in <code>enetLTS</code>.
</p>


<h3>Value</h3>

<p>The requested predicted values are returned.
</p>


<h3>Author(s)</h3>

<p>Fatma Sevinc KURNAZ, Irene HOFFMANN, Peter FILZMOSER
<br> Maintainer: Fatma Sevinc KURNAZ &lt;fatmasevinckurnaz@gmail.com&gt;;&lt;fskurnaz@yildiz.edu.tr&gt;</p>


<h3>See Also</h3>

<p><code>enetLTS</code>,
<code>coef.enetLTS</code>,
<code>nonzeroCoef.enetLTS</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## for gaussian

set.seed(86)
n &lt;- 100; p &lt;- 25                             # number of observations and variables
beta &lt;- rep(0,p); beta[1:6] &lt;- 1              # 10% nonzero coefficients
sigma &lt;- 0.5                                  # controls signal-to-noise ratio
x &lt;- matrix(rnorm(n*p, sigma),nrow=n)
e &lt;- rnorm(n,0,1)                             # error terms
eps &lt;- 0.1                                    # contamination level
m &lt;- ceiling(eps*n)                           # observations to be contaminated
eout &lt;- e; eout[1:m] &lt;- eout[1:m] + 10        # vertical outliers
yout &lt;- c(x %*% beta + sigma * eout)        # response
xout &lt;- x; xout[1:m,] &lt;- xout[1:m,] + 10      # bad leverage points


fit1 &lt;- enetLTS(xout,yout)
predict(fit1,newX=xout)
predict(fit1,newX=xout,type="coefficients")
predict(fit1,newX=xout,type="nonzero",vers="raw")
# provide new X matrix
newX &lt;- matrix(rnorm(n*p, sigma),nrow=n)
predict(fit1,newX=newX,type="response")
predict(fit1,newX=newX,type="coefficients")
predict(fit1,newX=newX,type="nonzero")

## for binomial

eps &lt;-0.05                                     # %10 contamination to only class 0
m &lt;- ceiling(eps*n)
y &lt;- sample(0:1,n,replace=TRUE)
xout &lt;- x
xout[y==0,][1:m,] &lt;- xout[1:m,] + 10;          # class 0
yout &lt;- y                                      # wrong classification for vertical outliers


fit2 &lt;- enetLTS(xout,yout,family="binomial")
predict(fit2,newX=xout)
predict(fit2,newX=xout,type="coefficients")
predict(fit2,newX=xout,type="nonzero",vers="raw")
predict(fit2,newX=newX,type="response")
predict(fit2,newX=newX,type="class")
predict(fit2,newX=newX,type="coefficients",vers="raw")
predict(fit2,newX=newX,type="nonzero")



## for multinomial

n &lt;- 120; p &lt;- 15
NC &lt;- 3
X &lt;- matrix(rnorm(n * p), n, p)
betas &lt;- matrix(1:NC, ncol=NC, nrow=p, byrow=TRUE)
betas[(p-5):p,]=0; betas &lt;- rbind(rep(0,NC),betas)
lv &lt;- cbind(1,X) %*% betas
probs &lt;- exp(lv)/apply(exp(lv),1,sum)
y &lt;- apply(probs,1,function(prob){sample(1:NC, 1, TRUE, prob)})
xout &lt;- X
eps &lt;-0.05                          # %10 contamination to only class 0
m &lt;- ceiling(eps*n)
xout[1:m,] &lt;- xout[1:m,] + 10       # bad leverage points
yout &lt;- y


fit3    &lt;- enetLTS(xout,yout,family="multinomial")
predict(fit3,newX=xout)
predict(fit3,newX=xout,type="coefficients")
predict(fit3,newX=xout,type="nonzero",vers="raw")
predict(fit3,newX=xout,type="response")
predict(fit3,newX=xout,type="class")
predict(fit3,newX=xout,type="coefficients",vers="raw")
predict(fit3,newX=xout,type="nonzero")

</code></pre>


</div>