<div class="container">

<table style="width: 100%;"><tr>
<td>kden</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kernel Density Estimation, With Variety of Kernels</h2>

<h3>Description</h3>

<p>Density, cumulative distribution function, quantile function and
random number generation for the kernel density estimation using the kernel
specified by <code>kernel</code>, with a constant bandwidth specified by either
<code>lambda</code> or <code>bw</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dkden(x, kerncentres, lambda = NULL, bw = NULL, kernel = "gaussian",
  log = FALSE)

pkden(q, kerncentres, lambda = NULL, bw = NULL, kernel = "gaussian",
  lower.tail = TRUE)

qkden(p, kerncentres, lambda = NULL, bw = NULL, kernel = "gaussian",
  lower.tail = TRUE)

rkden(n = 1, kerncentres, lambda = NULL, bw = NULL,
  kernel = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>quantiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kerncentres</code></td>
<td>
<p>kernel centres (typically sample data vector or scalar)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>bandwidth for kernel (as half-width of kernel) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>bandwidth for kernel (as standard deviations of kernel) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>kernel name (<code>default = "gaussian"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical, if TRUE then log density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>quantiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>logical, if FALSE then upper tail probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>cumulative probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size (positive integer)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Kernel density estimation using one of many possible kernels with a
constant bandwidth. 
</p>
<p>The alternate bandwidth definitions are discussed in the
<code>kernels</code>, with the <code>lambda</code> as the default.
The <code>bw</code> specification is the same as used in the
<code>density</code> function.
</p>
<p>The possible kernels are also defined in <code>kernels</code> help
documentation with the <code>"gaussian"</code> as the default choice.
</p>
<p>The density function <code>dkden</code> produces exactly the
same density estimate as <code>density</code> when a sequence
of <code>x</code> values are provided, see examples. The latter function is far
more efficient in this situation as it takes advantage of the computational
savings from doing the kernel smoothing in the spectral domain (using the FFT),
where the convolution becomes a multiplication. So even after accounting for applying
the (Fast) Fourier Transform (FFT) and its inverse it is much more efficient
especially for a large sample size or large number of evaluation points.
</p>
<p>However, this KDE function applies the less efficient convolution using the
standard definition:
</p>
<p style="text-align: center;"><code class="reqn">\hat{f}_(x) = \frac{1}{n} \sum_{j=1}^{n} K(\frac{x - x_j}{\lambda})</code>
</p>

<p>where <code class="reqn">K(.)</code> is the density function for the standard
kernel. Thus are no restriction on the values <code>x</code> can take. For example, in the 
<code>"gaussian"</code> kernel case for a particular <code>x</code> the density is evaluated as
<code>mean(dnorm(x, kerncentres, lambda))</code> for the density and
<code>mean(pnorm(x, kerncentres, lambda))</code> for cumulative distribution
function which is slower than the FFT but is more adaptable.
</p>
<p>An inversion sampler is used for random number generation which also rather
inefficient, as it can be carried out more efficiently using a mixture representation.
</p>
<p>The quantile function is rather complicated as there is no closed form solution,
so is obtained by numerical approximation of the inverse cumulative distribution function
<code class="reqn">P(X \le q) = p</code> to find <code class="reqn">q</code>. The quantile function 
<code>qkden</code> evaluates the KDE cumulative distribution
function over the range from <code>c(max(kerncentre) - lambda, max(kerncentre) + lambda)</code>,
or <code>c(max(kerncentre) - 5*lambda, max(kerncentre) + 5*lambda)</code> for normal kernel.
Outside of this range the quantiles are set to <code>-Inf</code> for lower tail and <code>Inf</code>
for upper tail. A sequence of values
of length fifty times the number of kernels (with minimum of 1000) is first
calculated. Spline based interpolation using <code>splinefun</code>,
with default <code>monoH.FC</code> method, is then used to approximate the quantile
function. This is a similar approach to that taken
by Matt Wand in the <code>qkde</code> in the <code>ks</code> package.
</p>
<p>If no bandwidth is provided <code>lambda=NULL</code> and <code>bw=NULL</code> then the normal
reference rule is used, using the <code>bw.nrd0</code> function, which is
consistent with the <code>density</code> function. At least two kernel
centres must be provided as the variance needs to be estimated.
</p>


<h3>Value</h3>

<p><code>dkden</code> gives the density, 
<code>pkden</code> gives the cumulative distribution function,
<code>qkden</code> gives the quantile function and 
<code>rkden</code> gives a random sample.
</p>


<h3>Acknowledgments</h3>

<p>Based on code
by Anna MacDonald produced for MATLAB.
</p>


<h3>Note</h3>

<p>Unlike most of the other extreme value mixture model functions the 
<code>kden</code> functions have not been vectorised as
this is not appropriate. The main inputs (<code>x</code>, <code>p</code> or <code>q</code>)
must be either a scalar or a vector, which also define the output length.
</p>
<p>The kernel centres <code>kerncentres</code> can either be a single datapoint or a vector
of data. The kernel centres (<code>kerncentres</code>) and locations to evaluate density (<code>x</code>)
and cumulative distribution function (<code>q</code>) would usually be different.
</p>
<p>Default values are provided for all inputs, except for the fundamentals 
<code>kerncentres</code>, <code>x</code>, <code>q</code> and <code>p</code>. The default sample size for 
<code>rkden</code> is 1.
</p>
<p>Missing (<code>NA</code>) and Not-a-Number (<code>NaN</code>) values in <code>x</code>,
<code>p</code> and <code>q</code> are passed through as is and infinite values are set to
<code>NA</code>. None of these are not permitted for the parameters.
</p>
<p>Error checking of the inputs (e.g. invalid probabilities) is carried out and
will either stop or give warning message as appropriate.
</p>


<h3>Author(s)</h3>

<p>Yang Hu and Carl Scarrott <a href="mailto:carl.scarrott@canterbury.ac.nz">carl.scarrott@canterbury.ac.nz</a>.
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Kernel_density_estimation">http://en.wikipedia.org/wiki/Kernel_density_estimation</a>
</p>
<p><a href="http://en.wikipedia.org/wiki/Cross-validation_(statistics)">http://en.wikipedia.org/wiki/Cross-validation_(statistics)</a>
</p>
<p>Scarrott, C.J. and MacDonald, A. (2012). A review of extreme value
threshold estimation and uncertainty quantification. REVSTAT - Statistical
Journal 10(1), 33-59. Available from <a href="http://www.ine.pt/revstat/pdf/rs120102.pdf">http://www.ine.pt/revstat/pdf/rs120102.pdf</a>
</p>
<p>Hu Y. and Scarrott, C.J. (2018). evmix: An R Package for Extreme Value Mixture Modeling, 
Threshold Estimation and Boundary Corrected Kernel Density Estimation. Journal of
Statistical Software 84(5), 1-27. doi: 10.18637/jss.v084.i05.
</p>
<p>Bowman, A.W. (1984). An alternative method of cross-validation for the smoothing of
density estimates. Biometrika 71(2), 353-360.
</p>
<p>Duin, R.P.W. (1976). On the choice of smoothing parameters for Parzen estimators of
probability density functions. IEEE Transactions on Computers C25(11), 1175-1179.
</p>
<p>MacDonald, A., Scarrott, C.J., Lee, D., Darlow, B., Reale, M. and Russell, G. (2011).
A flexible extreme value mixture model. Computational Statistics and Data Analysis
55(6), 2137-2157.
</p>
<p>Wand, M. and Jones, M.C. (1995). Kernel Smoothing. Chapman &amp;&amp; Hall.
</p>


<h3>See Also</h3>

<p><code>kernels</code>, <code>kfun</code>,
<code>density</code>, <code>bw.nrd0</code>
and <code>dkde</code> in <code>ks</code> package.
</p>
<p>Other kden: <code>bckden</code>, <code>fbckden</code>,
<code>fgkgcon</code>, <code>fgkg</code>,
<code>fkdengpdcon</code>, <code>fkdengpd</code>,
<code>fkden</code>, <code>kdengpdcon</code>,
<code>kdengpd</code>
</p>
<p>Other kdengpd: <code>bckdengpd</code>,
<code>fbckdengpd</code>, <code>fgkg</code>,
<code>fkdengpdcon</code>, <code>fkdengpd</code>,
<code>fkden</code>, <code>gkg</code>,
<code>kdengpdcon</code>, <code>kdengpd</code>
</p>
<p>Other gkg: <code>fgkgcon</code>, <code>fgkg</code>,
<code>fkdengpd</code>, <code>gkgcon</code>,
<code>gkg</code>, <code>kdengpd</code>
</p>
<p>Other bckden: <code>bckdengpdcon</code>,
<code>bckdengpd</code>, <code>bckden</code>,
<code>fbckdengpdcon</code>, <code>fbckdengpd</code>,
<code>fbckden</code>, <code>fkden</code>
</p>
<p>Other bckdengpd: <code>bckdengpdcon</code>,
<code>bckdengpd</code>, <code>bckden</code>,
<code>fbckdengpdcon</code>, <code>fbckdengpd</code>,
<code>fbckden</code>, <code>fkdengpd</code>,
<code>gkg</code>, <code>kdengpd</code>
</p>
<p>Other fkden: <code>fkden</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
set.seed(1)
par(mfrow = c(2, 2))

nk=50
x = rnorm(nk)
xx = seq(-5, 5, 0.01)
plot(xx, dnorm(xx))
rug(x)
for (i in 1:nk) lines(xx, dnorm(xx, x[i], sd = bw.nrd0(x))*0.05)
lines(xx, dkden(xx, x), lwd = 2, col = "red")
lines(density(x), lty = 2, lwd = 2, col = "green")
legend("topright", c("True Density", "KDE Using evmix", "KDE Using density function"),
lty = c(1, 1, 2), lwd = c(1, 2, 2), col = c("black", "red", "green"))

# Estimate bandwidth using cross-validation likelihood
x = rnorm(nk)
fit = fkden(x)
hist(x, nk/5, freq = FALSE, xlim = c(-5, 5), ylim = c(0, 0.6)) 
rug(x)
for (i in 1:nk) lines(xx, dnorm(xx, x[i], sd = fit$bw)*0.05)
lines(xx,dnorm(xx), col = "black")
lines(xx, dkden(xx, x, lambda = fit$lambda), lwd = 2, col = "red")
lines(density(x), lty = 2, lwd = 2, col = "green")
lines(density(x, bw = fit$bw), lwd = 2, lty = 2,  col = "blue")
legend("topright", c("True Density", "KDE fitted evmix",
"KDE Using density, default bandwidth", "KDE Using density, c-v likelihood bandwidth"),
lty = c(1, 1, 2, 2), lwd = c(1, 2, 2, 2), col = c("black", "red", "green", "blue"))

plot(xx, pnorm(xx), type = "l")
rug(x)
lines(xx, pkden(xx, x), lwd = 2, col = "red")
lines(xx, pkden(xx, x, lambda = fit$lambda), lwd = 2, col = "green")
# green and blue (quantile) function should be same
p = seq(0, 1, 0.001)
lines(qkden(p, x, lambda = fit$lambda), p, lwd = 2, lty = 2, col = "blue") 
legend("topleft", c("True Density", "KDE using evmix, normal reference rule",
"KDE using evmix, c-v likelihood","KDE quantile function, c-v likelihood"),
lty = c(1, 1, 1, 2), lwd = c(1, 2, 2, 2), col = c("black", "red", "green", "blue"))

xnew = rkden(10000, x, lambda = fit$lambda)
hist(xnew, breaks = 100, freq = FALSE, xlim = c(-5, 5))
rug(xnew)
lines(xx,dnorm(xx), col = "black")
lines(xx, dkden(xx, x), lwd = 2, col = "red")
legend("topright", c("True Density", "KDE Using evmix"),
lty = c(1, 2), lwd = c(1, 2), col = c("black", "red"))

## End(Not run)

</code></pre>


</div>