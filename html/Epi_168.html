<div class="container">

<table style="width: 100%;"><tr>
<td>simLexis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate a Lexis object representing follow-up in a multistate
model.</h2>

<h3>Description</h3>

<p>Based on a (pre-)<code>Lexis</code> object representing persons
at given states and times, and full specification of transition
intensities between states in the form of models for the transition
rates, this function simulates transition times and -types for persons
and returns a <code>Lexis</code> object representing the simulated
cohort. The simulation scheme accommodates multiple timescales,
including time since entry into an intermediate state, and accepts
fitted Poisson models, Cox-models or just a function as specification
of rates.</p>


<h3>Usage</h3>

<pre><code class="language-R">simLexis( Tr, init,
           N = 1,
      lex.id,
     t.range = 20,
       n.int = 101,
    time.pts = seq(0,t.range,length.out=n.int) )
nState( obj, at, from, time.scale = 1 )
pState( nSt, perm = 1:ncol(nSt) )
## S3 method for class 'pState'
plot( x,
                     col = rainbow(ncol(x)),
                  border = "transparent",
                    xlab = "Time",
                    ylim = 0:1,
                    ylab = "Probability", ... )
## S3 method for class 'pState'
lines( x,
                      col = rainbow(ncol(x)),
                   border = "transparent", ... )
   </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Tr</code></td>
<td>
<p>A named list of named lists. The names of the list are names
of the transient states in the model. Each list element is again a
named list. The names of the elements of this inner list are the
names of the states reachable from the state with name equal to the
list. Elements of the intter lists represent transitions. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>A (pre-)<code>Lexis</code> object representing the initial
state of the persons whose trajectories through the multiple states
we want to simulate. Must have attributes "time.scales" and "time.since" — see
details. Duplicate values of <code>lex.id</code> are not sensible and not
accepted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Numeric. How many persons should be simulated. <code>N</code>
persons with covariate configuration of each row in <code>init</code>
will be simulated. Either a scalar or a vector of length <code>nrow(init)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lex.id</code></td>
<td>
<p>Vector of ids of the simulated persons. Useful when
simulating in chunks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.range</code></td>
<td>
<p>Numerical scalar. The range of time over which to
compute the cumulative rates when simulating. Simulted times
beyond this will result in an obervation censored at <code>t.range</code>
after entry.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.int</code></td>
<td>
<p>Number of intervals to use when computing (cumulative) rates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.pts</code></td>
<td>
<p>Numerical vector of times since start. Cumulative
rates for transitions are computed at these times after stater and
entry state. Simulation is only done till time <code>max(time.pts)</code>
after start, where persons are censored. Must start with 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>A <code>Lexis</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>The point on the time scale <code>time.scale</code> from which
we start counting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.scale</code></td>
<td>
<p>The timescale to which <code>from</code> refer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p>Time points (after <code>from</code>) where the number of persons
in each state is to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nSt</code></td>
<td>
<p>A table obtained by <code>nState</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perm</code></td>
<td>
<p>A permutation of columns used before cumulating row-wise
and taking percentages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>pState</code>, e.g. created by <code>pState</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>Colors for filling the areas between curves.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>border</code></td>
<td>
<p>Colors for outline of the areas between curves.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>Label on x-axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>Limits on y-axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>Label on y-axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed on to <code>plot</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The simulation command <code>simLexis</code> is not defined as a
method for <code>Lexis</code> objects, because the input is not a
<code>Lexis</code> object, the <code>Lexis</code>-like object is merely
representing a prevalent population and a specification of which
variables that are timescales. The variables <code>lex.dur</code> and
<code>lex.Xst</code> are ignored (and overwritten) if present. The core
input is the list <code>Tr</code> giving the transitions.
</p>
<p>The components of <code>Tr</code> represents the transition intensities
between states. The transition from state <code>A</code> to <code>B</code>, say,
is assumed stored in <code>Tr$A$B</code>. Thus names of the elements of
<code>Tr</code> are names of transient states, and the names of the elements
of each these are the names of states reachable from the corresponding
transient state.
</p>
<p>The transition intensities are assumed modelled by either a glm with
Poisson family or a Cox-model. In both cases the timescale(s) in the
model must be using the names fo the timescales in a Lexis object
representng the follow-up in a cohort, and the risk time must be taken
from the variable <code>lex.dur</code> — see the example.
</p>
<p>Alternatively, an element in <code>Tr</code> could be a function
that from a data frame produces transition rates, or specifically
cumulative transition rates over intervals of length <code>lex.dur</code>.
</p>
<p>The pre-<code>Lexis</code> object <code>init</code> must contain values of all
variables used in any of the objects in <code>Tr</code>, as well as all
timescales - even those not used in the models. Moreover, the
attributes <code>time.scales</code> and <code>time.since</code> must be
present. The attribute <code>time.since</code> is a character vector of the
same length as <code>time.scales</code> and an element has value <code>"A"</code>
if the corresponding time scale is defined as
"time since entry into state <code>A</code>", otherwise the value is
<code>""</code>. If not present it will be set to a vector of <code>""</code>s,
which is only OK if no time scales are defined as time since entry to
a state.
</p>
<p>Note that the variables pre-<code>Lexis</code> object <code>init</code> must have
the same mode and class as in the dataset used for fitting the models
— hence the indexing of rows by brackets in the assignment of values used in
the example below - this way the variables have their attributes
preserved; using <code>init[,"var"] &lt;-</code> or <code>init$var &lt;-</code> replaces
the variable, whereas  <code>init[1:4,"var"] &lt;-</code> or
<code>init$var[1:4] &lt;-</code> replaces values only and prevents you from
entering non-existing factor levels etc.
</p>
<p>The function <code>Lexis</code> automatically generates an attribute
<code>time.since</code>, and <code>cutLexis</code> updates it when new time
scales are defined. Hence, the simplest way of defining a initial
pre-<code>Lexis</code> object representing a current state of a (set of) persons
to be followed through a multistate model is to take <code>NULL</code> rows
of an existing Lexis object (normally the one used for estimation),
and so ensuring that all relevant attributes and state levels are
properly defined. See the example code.
</p>
<p>The prevalence function <code>nState</code> computes the distribution of
individuals in different states at prespecified times. Only sensible
for a simulated <code>Lexis</code> object. The function <code>pState</code> takes
a matrix as output by <code>nState</code> and computes the row-wise
cumulative probabilities across states, and leaves an object of class
<code>pState</code>, suitable for plotting.
</p>


<h3>Value</h3>

<p><code>simLexis</code> returns a <code>Lexis</code> object representing
the experience of a population starting as <code>init</code> followed
through the states according to the transitions in <code>Tr</code>.
</p>
<p>The function <code>nState</code> returns a table of persons classified by
states at each of the times in <code>at</code>. Note that this function can
easily produce meaningless results, for example if applied to a
<code>Lexis</code> object not created by simulation. If you apply it to a
<code>Lexis</code> object generated by <code>simLexis</code>, you must make sure
that you start (<code>from</code>) the point where you started the
simulation on the correct timescale, and you will get funny results if
you try to tabulate beyond the censoring time for the simulation.
The resulting object has class <code>"table"</code>.
</p>
<p>The result from using <code>pState</code> on the result from <code>nState</code>
has class <code>c("pState","matrix")</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>.</p>


<h3>See Also</h3>

<p><code>Lexis</code>,
<code>cutLexis</code>,
<code>splitLexis</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(DMlate)
dml &lt;- Lexis( entry = list(Per=dodm, Age=dodm-dobth, DMdur=0 ),
               exit = list(Per=dox),
        exit.status = factor(!is.na(dodth),labels=c("DM","Dead")),
               data = DMlate[runif(nrow(DMlate))&lt;0.1,] )
# Split follow-up at insulin, introduce a new timescale,
# and split non-precursor states
dmi &lt;- cutLexis( dml, cut = dml$doins,
                      pre = "DM",
                new.state = "Ins",
                new.scale = "t.Ins",
             split.states = TRUE )
# Split the follow in 1-year intervals for modelling
Si &lt;- splitLexis( dmi, 0:30/2, "DMdur" )
# Define knots
nk &lt;- 4
( ai.kn &lt;- with( subset(Si,lex.Xst=="Ins"),
                 quantile( Age+lex.dur, probs=(1:nk-0.5)/nk ) ) )
( ad.kn &lt;- with( subset(Si,lex.Xst=="Dead"),
                 quantile( Age+lex.dur, probs=(1:nk-0.5)/nk ) ) )
( di.kn &lt;- with( subset(Si,lex.Xst=="Ins"),
                 quantile( DMdur+lex.dur, probs=(1:nk-0.5)/nk ) ) )
( dd.kn &lt;- with( subset(Si,lex.Xst=="Dead"),
                 quantile( DMdur+lex.dur, probs=(1:nk-0.5)/nk ) ) )
( td.kn &lt;- with( subset(Si,lex.Xst=="Dead(Ins)"),
                 quantile( t.Ins+lex.dur, probs=(1:nk-0.5)/nk ) ) )

# Fit Poisson models to transition rates
library( splines )
DM.Ins &lt;- glm( (lex.Xst=="Ins") ~ Ns( Age  , knots=ai.kn ) +
                                  Ns( DMdur, knots=di.kn ) +
                                  I(Per-2000) + sex,
               family=poisson, offset=log(lex.dur),
               data = subset(Si,lex.Cst=="DM") )
DM.Dead &lt;- glm( (lex.Xst=="Dead") ~ Ns( Age  , knots=ad.kn ) +
                                    Ns( DMdur, knots=dd.kn ) +
                                    I(Per-2000) + sex,
               family=poisson, offset=log(lex.dur),
               data = subset(Si,lex.Cst=="DM") )
Ins.Dead &lt;- glm( (lex.Xst=="Dead(Ins)") ~ Ns( Age  , knots=ad.kn ) +
                                          Ns( DMdur, knots=dd.kn ) +
                                          Ns( t.Ins, knots=td.kn ) +
                                          I(Per-2000) + sex,
               family=poisson, offset=log(lex.dur),
               data = subset(Si,lex.Cst=="Ins") )

# Stuff the models into an object representing the transitions
Tr &lt;- list( "DM" = list( "Ins"       = DM.Ins,
                         "Dead"      = DM.Dead  ),
           "Ins" = list( "Dead(Ins)" = Ins.Dead ) )
lapply( Tr, names )

# Define an initial object - note the subsetting that ensures that
# all attributes are carried over
ini &lt;- Si[1,1:9][-1,]
ini[1:2,"lex.Cst"] &lt;- "DM"
ini[1:2,"Per"] &lt;- 1995
ini[1:2,"Age"] &lt;- 60
ini[1:2,"DMdur"] &lt;- 5
ini[1:2,"sex"] &lt;- c("M","F")
str(ini)

# Simulate 200 of each sex using the estimated models in Tr
simL &lt;- simLexis( Tr, ini, time.pts=seq(0,11,0.5), N=200 )
summary( simL )

# Find the number of persons in each state at a set of times.
# Note that the times are shirter than the time-span simulated.
nSt &lt;- nState( subset(simL,sex=="M"),
               at=seq(0,10,0.1), from=1995, time.scale="Per" )
nSt

# Show the cumulative prevalences in a different order than that of the
# state-level ordering and plot them using all defaults
pp &lt;- pState( nSt, perm=c(1,2,4,3) )
head( pp )
plot( pp )

# A more useful set-up of the graph
clr &lt;- c("orange2","forestgreen")
par( las=1 )
plot( pp, col=clr[c(2,1,1,2)] )
lines( as.numeric(rownames(pp)), pp[,2], lwd=2 )
mtext( "60 year old male, diagnosed 1995", side=3, line=2.5, adj=0 )
mtext( "Survival curve", side=3, line=1.5, adj=0 )
mtext( "DM, no insulin   DM, Insulin", side=3, line=0.5, adj=0, col=clr[1] )
mtext( "DM, no insulin", side=3, line=0.5, adj=0, col=clr[2] )
axis( side=4 )

# Using a Cox-model for the mortality rates assuming the two mortality
# rates to be proportional:
# When we fit a Cox-model, lex.dur must be used in the Surv() function,
# and the I() constrction must be used when specifying intermediate
# states as covariates, since factors with levels not present in the
# data will create NAs in the parameter vector returned by coxph, which
# in return will crash the simulation machinery.
library( survival )
Cox.Dead &lt;- coxph( Surv( DMdur, DMdur+lex.dur,
                         lex.Xst %in% c("Dead(Ins)","Dead")) ~
                   Ns( Age-DMdur, knots=ad.kn ) +
                   I(lex.Cst=="Ins") +
                   I(Per-2000) + sex,
               data = Si )
Cr &lt;- list( "DM" = list( "Ins"       = DM.Ins,
                         "Dead"      = Cox.Dead  ),
           "Ins" = list( "Dead(Ins)" = Cox.Dead ) )
simL &lt;- simLexis( Cr, ini, time.pts=seq(0,11,0.2), N=200 )
summary( simL )
nSt &lt;- nState( subset(simL,sex=="M"),
               at=seq(0,10,0.2), from=1995, time.scale="Per" )
pp &lt;- pState( nSt, perm=c(1,2,4,3) )
plot( pp )
</code></pre>


</div>