<div class="container">

<table style="width: 100%;"><tr>
<td>gkgcon</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kernel Density Estimate and GPD Both Upper and Lower Tails Extreme Value Mixture Model
With Single Continuity Constraint at Both</h2>

<h3>Description</h3>

<p>Density, cumulative distribution function, quantile function and
random number generation for the extreme value mixture model with
kernel density estimate for bulk distribution between thresholds and
conditional GPD beyond thresholds and continuity at both of them. The parameters are the kernel bandwidth
<code>lambda</code>, lower tail (threshold <code>ul</code>, 
GPD shape <code>xil</code> and tail fraction <code>phiul</code>)
and upper tail (threshold <code>ur</code>, GPD shape 
<code>xiR</code> and tail fraction <code>phiur</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">dgkgcon(x, kerncentres, lambda = NULL,
  ul = as.vector(quantile(kerncentres, 0.1)), xil = 0, phiul = TRUE,
  ur = as.vector(quantile(kerncentres, 0.9)), xir = 0, phiur = TRUE,
  bw = NULL, kernel = "gaussian", log = FALSE)

pgkgcon(q, kerncentres, lambda = NULL,
  ul = as.vector(quantile(kerncentres, 0.1)), xil = 0, phiul = TRUE,
  ur = as.vector(quantile(kerncentres, 0.9)), xir = 0, phiur = TRUE,
  bw = NULL, kernel = "gaussian", lower.tail = TRUE)

qgkgcon(p, kerncentres, lambda = NULL,
  ul = as.vector(quantile(kerncentres, 0.1)), xil = 0, phiul = TRUE,
  ur = as.vector(quantile(kerncentres, 0.9)), xir = 0, phiur = TRUE,
  bw = NULL, kernel = "gaussian", lower.tail = TRUE)

rgkgcon(n = 1, kerncentres, lambda = NULL,
  ul = as.vector(quantile(kerncentres, 0.1)), xil = 0, phiul = TRUE,
  ur = as.vector(quantile(kerncentres, 0.9)), xir = 0, phiur = TRUE,
  bw = NULL, kernel = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>quantiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kerncentres</code></td>
<td>
<p>kernel centres (typically sample data vector or scalar)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>bandwidth for kernel (as half-width of kernel) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ul</code></td>
<td>
<p>lower tail threshold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xil</code></td>
<td>
<p>lower tail GPD shape parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phiul</code></td>
<td>
<p>probability of being below lower threshold <code class="reqn">[0, 1]</code> or <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ur</code></td>
<td>
<p>upper tail threshold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xir</code></td>
<td>
<p>upper tail GPD shape parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phiur</code></td>
<td>
<p>probability of being above upper threshold <code class="reqn">[0, 1]</code> or <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>bandwidth for kernel (as standard deviations of kernel) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>kernel name (<code>default = "gaussian"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical, if TRUE then log density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>quantiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>logical, if FALSE then upper tail probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>cumulative probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size (positive integer)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Extreme value mixture model combining kernel density estimate (KDE) for the bulk
between thresholds and GPD beyond thresholds and continuity at both of them.
</p>
<p>The user can pre-specify <code>phiul</code> and <code>phiur</code> 
permitting a parameterised value for the tail fractions <code class="reqn">\phi_ul</code> and  <code class="reqn">\phi_ur</code>.
Alternatively, when
<code>phiul=TRUE</code> and <code>phiur=TRUE</code> the tail fractions are estimated as the tail
fractions from the KDE bulk model.
</p>
<p>The alternate bandwidth definitions are discussed in the
<code>kernels</code>, with the <code>lambda</code> as the default.
The <code>bw</code> specification is the same as used in the
<code>density</code> function.
</p>
<p>The possible kernels are also defined in <code>kernels</code>
with the <code>"gaussian"</code> as the default choice.
</p>
<p>Notice that the tail fraction cannot be 0 or 1, and the sum of upper and lower tail
fractions <code>phiul + phiur &lt; 1</code>, so the lower threshold must be less than the upper, 
<code>ul &lt; ur</code>.
</p>
<p>The cumulative distribution function has three components. The lower tail with 
tail fraction <code class="reqn">\phi_{ul}</code> defined by the KDE bulk model (<code>phiul=TRUE</code>)
upto the lower threshold <code class="reqn">x &lt; u_l</code>:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = H(u_l) [1 - G_l(x)].</code>
</p>

<p>where <code class="reqn">H(x)</code> is the kernel density estimator cumulative distribution function (i.e. 
<code>mean(pnorm(x, kerncentres, bw))</code> and  
<code class="reqn">G_l(X)</code> is the conditional GPD cumulative distribution function with negated
<code class="reqn">x</code> value and threshold, i.e. <code>pgpd(-x, -ul, sigmaul, xil, phiul)</code>. The KDE
bulk model between the thresholds <code class="reqn">u_l \le x \le u_r</code> given by:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = H(x).</code>
</p>

<p>Above the threshold <code class="reqn">x &gt; u_r</code> the usual conditional GPD:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = H(u_r) + [1 - H(u_r)] G_r(x)</code>
</p>

<p>where <code class="reqn">G_r(X)</code> is the GPD cumulative distribution function, 
i.e. <code>pgpd(x, ur, sigmaur, xir, phiur)</code>.
</p>
<p>The cumulative distribution function for the pre-specified tail fractions 
<code class="reqn">\phi_{ul}</code> and <code class="reqn">\phi_{ur}</code> is more complicated.  The unconditional GPD
is used for the lower tail <code class="reqn">x &lt; u_l</code>:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \phi_{ul} [1 - G_l(x)].</code>
</p>

<p>The KDE bulk model between the thresholds <code class="reqn">u_l \le x \le u_r</code> given by:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \phi_{ul}+ (1-\phi_{ul}-\phi_{ur}) (H(x) - H(u_l)) / (H(u_r) - H(u_l)).</code>
</p>

<p>Above the threshold <code class="reqn">x &gt; u_r</code> the usual conditional GPD:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = (1-\phi_{ur}) + \phi_{ur} G(x)</code>
</p>

<p>Notice that these definitions are equivalent when <code class="reqn">\phi_{ul} = H(u_l)</code> and
<code class="reqn">\phi_{ur} = 1 - H(u_r)</code>.
</p>
<p>The continuity constraint at <code>ur</code> means that:
</p>
<p style="text-align: center;"><code class="reqn">\phi_{ur} g_r(x) = (1-\phi_{ul}-\phi_{ur}) h(u_r)/ (H(u_r) - H(u_l)).</code>
</p>

<p>By rearrangement, the GPD scale parameter <code>sigmaur</code> is then:
</p>
<p style="text-align: center;"><code class="reqn">\sigma_ur = \phi_{ur} (H(u_r) - H(u_l))/ h(u_r) (1-\phi_{ul}-\phi_{ur}).</code>
</p>

<p>where <code class="reqn">h(x)</code>, <code class="reqn">g_l(x)</code> and <code class="reqn">g_r(x)</code> are the KDE and conditional GPD
density functions for lower and upper tail respectively. 
In the special case of where the tail fraction is defined by the bulk model this reduces to
</p>
<p style="text-align: center;"><code class="reqn">\sigma_ur = [1-H(u_r)] / h(u_r)</code>
</p>
<p>.
</p>
<p>The continuity constraint at <code>ul</code> means that:
</p>
<p style="text-align: center;"><code class="reqn">\phi_{ul} g_l(x) = (1-\phi_{ul}-\phi_{ur}) h(u_l)/ (H(u_r) - H(u_l)).</code>
</p>

<p>The GPD scale parameter <code>sigmaul</code> is replaced by:
</p>
<p style="text-align: center;"><code class="reqn">\sigma_ul = \phi_{ul} (H(u_r) - H(u_l))/ h(u_l) (1-\phi_{ul}-\phi_{ur}).</code>
</p>

<p>In the special case of where the tail fraction is defined by the bulk model this reduces to
</p>
<p style="text-align: center;"><code class="reqn">\sigma_ul = H(u_l)/ h(u_l)</code>
</p>
<p>. 
</p>
<p>If no bandwidth is provided <code>lambda=NULL</code> and <code>bw=NULL</code> then the normal
reference rule is used, using the <code>bw.nrd0</code> function, which is
consistent with the <code>density</code> function. At least two kernel
centres must be provided as the variance needs to be estimated.
</p>
<p>See <code>gpd</code> for details of GPD upper tail component and 
<code>dkden</code> for details of KDE bulk component.
</p>


<h3>Value</h3>

<p><code>dgkgcon</code> gives the density, 
<code>pgkgcon</code> gives the cumulative distribution function,
<code>qgkgcon</code> gives the quantile function and 
<code>rgkgcon</code> gives a random sample.
</p>


<h3>Acknowledgments</h3>

<p>Based on code
by Anna MacDonald produced for MATLAB.
</p>


<h3>Note</h3>

<p>Unlike most of the other extreme value mixture model functions the 
<code>gkgcon</code> functions have not been vectorised as
this is not appropriate. The main inputs (<code>x</code>, <code>p</code> or <code>q</code>)
must be either a scalar or a vector, which also define the output length.
The <code>kerncentres</code> can also be a scalar or vector.
</p>
<p>The kernel centres <code>kerncentres</code> can either be a single datapoint or a vector
of data. The kernel centres (<code>kerncentres</code>) and locations to evaluate density (<code>x</code>)
and cumulative distribution function (<code>q</code>) would usually be different.
</p>
<p>Default values are provided for all inputs, except for the fundamentals 
<code>kerncentres</code>, <code>x</code>, <code>q</code> and <code>p</code>. The default sample size for 
<code>rgkgcon</code> is 1.
</p>
<p>Missing (<code>NA</code>) and Not-a-Number (<code>NaN</code>) values in <code>x</code>,
<code>p</code> and <code>q</code> are passed through as is and infinite values are set to
<code>NA</code>. None of these are not permitted for the parameters or kernel centres.
</p>
<p>Due to symmetry, the lower tail can be described by GPD by negating the quantiles. 
</p>
<p>Error checking of the inputs (e.g. invalid probabilities) is carried out and
will either stop or give warning message as appropriate.
</p>


<h3>Author(s)</h3>

<p>Yang Hu and Carl Scarrott <a href="mailto:carl.scarrott@canterbury.ac.nz">carl.scarrott@canterbury.ac.nz</a>.
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Kernel_density_estimation">http://en.wikipedia.org/wiki/Kernel_density_estimation</a>
</p>
<p><a href="http://en.wikipedia.org/wiki/Generalized_Pareto_distribution">http://en.wikipedia.org/wiki/Generalized_Pareto_distribution</a>
</p>
<p>Scarrott, C.J. and MacDonald, A. (2012). A review of extreme value
threshold estimation and uncertainty quantification. REVSTAT - Statistical
Journal 10(1), 33-59. Available from <a href="http://www.ine.pt/revstat/pdf/rs120102.pdf">http://www.ine.pt/revstat/pdf/rs120102.pdf</a>
</p>
<p>Bowman, A.W. (1984). An alternative method of cross-validation for the smoothing of
density estimates. Biometrika 71(2), 353-360.
</p>
<p>Duin, R.P.W. (1976). On the choice of smoothing parameters for Parzen estimators of
probability density functions. IEEE Transactions on Computers C25(11), 1175-1179.
</p>
<p>MacDonald, A., Scarrott, C.J., Lee, D., Darlow, B., Reale, M. and Russell, G. (2011).
A flexible extreme value mixture model. Computational Statistics and Data Analysis
55(6), 2137-2157.
</p>
<p>Wand, M. and Jones, M.C. (1995). Kernel Smoothing. Chapman &amp;&amp; Hall.
</p>


<h3>See Also</h3>

<p><code>kernels</code>, <code>kfun</code>,
<code>density</code>, <code>bw.nrd0</code>
and <code>dkde</code> in <code>ks</code> package.
</p>
<p>Other kdengpdcon: <code>bckdengpdcon</code>,
<code>fbckdengpdcon</code>, <code>fgkgcon</code>,
<code>fkdengpdcon</code>, <code>fkdengpd</code>,
<code>kdengpdcon</code>, <code>kdengpd</code>
</p>
<p>Other gkg: <code>fgkgcon</code>, <code>fgkg</code>,
<code>fkdengpd</code>, <code>gkg</code>,
<code>kdengpd</code>, <code>kden</code>
</p>
<p>Other gkgcon: <code>fgkgcon</code>, <code>fgkg</code>,
<code>fkdengpdcon</code>, <code>gkg</code>,
<code>kdengpdcon</code>
</p>
<p>Other bckdengpdcon: <code>bckdengpdcon</code>,
<code>bckdengpd</code>, <code>bckden</code>,
<code>fbckdengpdcon</code>, <code>fbckdengpd</code>,
<code>fbckden</code>, <code>fkdengpdcon</code>,
<code>kdengpdcon</code>
</p>
<p>Other fgkgcon: <code>fgkgcon</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
set.seed(1)
par(mfrow = c(2, 2))

kerncentres=rnorm(1000,0,1)
x = rgkgcon(1000, kerncentres, phiul = 0.15, phiur = 0.15)
xx = seq(-6, 6, 0.01)
hist(x, breaks = 100, freq = FALSE, xlim = c(-6, 6))
lines(xx, dgkgcon(xx, kerncentres, phiul = 0.15, phiur = 0.15))

# three tail behaviours
plot(xx, pgkgcon(xx, kerncentres), type = "l")
lines(xx, pgkgcon(xx, kerncentres,xil = 0.3, xir = 0.3), col = "red")
lines(xx, pgkgcon(xx, kerncentres,xil = -0.3, xir = -0.3), col = "blue")
legend("topleft", paste("Symmetric xil=xir=",c(0, 0.3, -0.3)),
  col=c("black", "red", "blue"), lty = 1)

# asymmetric tail behaviours
x = rgkgcon(1000, kerncentres, xil = -0.3, phiul = 0.1, xir = 0.3, phiur = 0.1)
xx = seq(-6, 6, 0.01)
hist(x, breaks = 100, freq = FALSE, xlim = c(-6, 6))
lines(xx, dgkgcon(xx, kerncentres, xil = -0.3, phiul = 0.1, xir = 0.3, phiur = 0.1))

plot(xx, dgkgcon(xx, kerncentres, xil = -0.3, phiul = 0.2, xir = 0.3, phiur = 0.2),
  type = "l", ylim = c(0, 0.4))
lines(xx, dgkgcon(xx, kerncentres, xil = -0.3, phiul = 0.3, xir = 0.3, phiur = 0.3),
  col = "red")
lines(xx, dgkgcon(xx, kerncentres, xil = -0.3, phiul = TRUE, xir = 0.3, phiur = TRUE),
  col = "blue")
legend("topleft", c("phiul = phiur = 0.2", "phiul = phiur = 0.3", "Bulk Tail Fraction"),
  col=c("black", "red", "blue"), lty = 1)

## End(Not run)

</code></pre>


</div>