<div class="container">

<table style="width: 100%;"><tr>
<td>AICweights</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Computes the AIC weights for output from the envcpt function.
</h2>

<h3>Description</h3>

<p>Uses the likelihood and number of parameters from the output of the <code>envcpt</code> function and calculates the AICweights for each model fitted relative to the model with the minimum AIC.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'envcpt'
AICweights(object)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>A list produced as output from the <code>envcpt</code> function.  In essence any list where the first element contains a matrix whose first row is twice the negative log-likelihood and second row is the number of parameters.  Columns are different models to compare.
</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Calculates the AICweights defined as </p>
<p style="text-align: center;"><code class="reqn">w_i=\frac{\exp{-0.5 \Delta_i}}{\sum_r{\exp{-0.5\Delta_r}}}</code>
</p>
<p> where the summation over <code class="reqn">r</code> is across all models considered and <code class="reqn">\Delta_i</code> is the difference between the AIC value for model <code class="reqn">i</code> and the best model.
</p>


<h3>Value</h3>

<p>Vector of AICweights the same length as the number of columns in the first entry to the input list (length 12 if output from envcpt where all models are considered).  The column names from the envcpt output are preserved to give clear indication on models.
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code>envcpt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
set.seed(1)
x=c(rnorm(100,0,1),rnorm(100,5,1))
out=envcpt(x) # run all models with default values
out[[1]] # first row is twice the negative log-likelihood for each model
         # second row is the number of parameters
AIC(out) # returns AIC for each model.
which.min(AIC(out)) # gives meancpt (model 2) as the best model fit.
out$meancpt # gives the model fit for the meancpt model.
AICweights(out) # gives the AIC weights for each model
BIC(out) # returns the BIC for each model.
which.min(BIC(out)) # gives meancpt (model 2) as the best model fit too.
plot(out,type='fit') # plots the fits
plot(out,type="aic") # plots the aic values
plot(out,type="bic") # plots the bic values

set.seed(10)
x=c(0.01*(1:100),1.5-0.02*((101:250)-101))+rnorm(250,0,0.2)
out=envcpt(x,minseglen=10) # run all models with a minimum of 10 observations between changes
AIC(out) # returns the AIC for each model
which.min(AIC(out)) # gives trendcpt (model 8) as the best model fit.
out$trendcpt # gives the model fit for the trendcpt model.
AICweights(out) # gives the AIC weights for each model
BIC(out) # returns the BIC for each model.
which.min(BIC(out)) # gives trendcpt (model 8) as the best model fit too.
plot(out,type='fit') # plots the fits
plot(out,type="aic") # plots the aic values
plot(out,type="bic") # plots the bic values

set.seed(100)
x=arima.sim(model=list(ar=c(0.7,0.2)),n=500)+0.01*(1:500)
out=envcpt(x,models=c(3:6,9:12)) # runs a subset of models (those with AR components) 
AIC(out) # returns the AIC for each model
which.min(AIC(out)) # gives trendar2 (model 10) as the best model fit.
out$trendar2 # gives the model fit for the trendar2 model. Notice that the trend is tiny but does 
# produce a significantly better fit than the meanar2 model.
AICweights(out) # gives the AIC weights for each model
BIC(out) # returns the BIC for each model.
which.min(BIC(out)) # best fit is trendar2 (model 10) again.
plot(out,type='fit') # plots the fits
plot(out,type="aic") # plots the aic values
plot(out,type="bic") # plots the bic values

## End(Not run)
</code></pre>


</div>