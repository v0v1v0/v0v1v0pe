<div class="container">

<table style="width: 100%;"><tr>
<td>trainRF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calibrate a random forest model</h2>

<h3>Description</h3>

<p>This function trains a random forest model. It identifies the optimal number of trees and value for <code>mtry</code> (number of variables sampled as candidates at each split) using out-of-bag error (OOB). The number of trees in each candidate model is set by the user with argument <code>numTrees</code>. The number of predictors to test per split, <code>mtry</code>, is found by exploring a range of values. If the response (<code>y</code>) is a factor, the starting value for <code>mtry</code> is <code>max(1, floor(p / 3))</code>, where <code>p</code> is the number of predictors. If the response is not a factor, the starting value is <code>max(1, floor(sqrt(p)))</code>. Values y<code>mtryIncrement</code> argument until the total number of predictors is used.  See <code>ranger</code> for more details.
</p>
<p>The output of the function is any or all of: a table with out-of-bag (OOB) error of evaluated models; all evaluated models; and/or the single model with the lowest OOB error.
</p>


<h3>Usage</h3>

<pre><code class="language-R">trainRF(
  data,
  resp = names(data)[1],
  preds = names(data)[2:ncol(data)],
  numTrees = c(250, 500, 750, 1000),
  mtryIncrement = 2,
  w = TRUE,
  binary = TRUE,
  out = "model",
  cores = 1,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resp</code></td>
<td>
<p>Response variable. This is either the name of the column in <code>data</code> or an integer indicating the column in <code>data</code> that has the response variable. The default is to use the first column in <code>data</code> as the response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preds</code></td>
<td>
<p>Character list or integer list. Names of columns or column indices of predictors. The default is to use the second and subsequent columns in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numTrees</code></td>
<td>
<p>Vector of number of trees to grow. All possible combinations of <code>mtry</code> and <code>numTrees</code> will be assessed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtryIncrement</code></td>
<td>
<p>Positive integer (default is 2).  Number of predictors to add to <code>mtry</code> until all predictors are in each tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Weights. For random forests, weights are simply used as relative probabilities of selecting a row in <code>data</code> to be used in a particular tree. This argument takes any of:
</p>

<ul>
<li> <p><code>TRUE</code>: Causes the total weight of presences to equal the total weight of absences (if <code>binary = TRUE</code>)
</p>
</li>
<li> <p><code>FALSE</code>: Each datum is assigned a weight of 1.
</p>
</li>
<li>
<p> A numeric vector of weights, one per row in <code>data</code>.
</p>
</li>
<li>
<p> The name of the column in <code>data</code> that contains site weights.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binary</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default) then the response is converted to a binary factor with levels 0 and 1. Otherwise, this argument has no effect and the response will be assumed to be a real number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out</code></td>
<td>
<p>Character vector. One or more values:
</p>

<ul>
<li>    <p><code>'model'</code>: Model with the lowest out-of-bag (OOB) error rate.
</p>
</li>
<li>    <p><code>'models'</code>: All models evaluated, sorted from lowest to highest OOB.
</p>
</li>
<li>    <p><code>'tuning'</code>: Data frame with tuning parameters, one row per model, sorted by OOB error rate.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Number of cores to use. Default is 1. If you have issues when <code>cores</code> &gt; 1, please see the <code>troubleshooting_parallel_operations</code> guide.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> then display progress for finding optimal value of <code>mtry</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to pass to <code>ranger</code>. Of note, <code>num.threads</code> will allow for multi-threaded computation of each RF. However, it could be problemmatic to use this when <code>cores</code> &gt; 1. Also of note, <code>save.memory</code> reduces speed but may make larger jobs possible.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The object that is returned depends on the value of the <code>out</code> argument. It can be a model object, a data frame, a list of models, or a list of all two or more of these.
</p>


<h3>See Also</h3>

<p><code>ranger</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# NB: The examples below show a very basic modeling workflow. They have been 
# designed to work fast, not produce accurate, defensible models. They can
# take a few minutes to run.

library(mgcv)
library(sf)
library(terra)
set.seed(123)

### setup data
##############

# environmental rasters
rastFile &lt;- system.file('extdata/madClim.tif', package='enmSdmX')
madClim &lt;- rast(rastFile)

# coordinate reference system
wgs84 &lt;- getCRS('WGS84')

# lemur occurrence data
data(lemurs)
occs &lt;- lemurs[lemurs$species == 'Eulemur fulvus', ]
occs &lt;- vect(occs, geom=c('longitude', 'latitude'), crs=wgs84)

occs &lt;- elimCellDuplicates(occs, madClim)

occEnv &lt;- extract(madClim, occs, ID = FALSE)
occEnv &lt;- occEnv[complete.cases(occEnv), ]
	
# create 10000 background sites (or as many as raster can support)
bgEnv &lt;- terra::spatSample(madClim, 20000)
bgEnv &lt;- bgEnv[complete.cases(bgEnv), ]
bgEnv &lt;- bgEnv[1:min(10000, nrow(bgEnv)), ]

# collate occurrences and background sites
presBg &lt;- data.frame(
  presBg = c(
    rep(1, nrow(occEnv)),
    rep(0, nrow(bgEnv))
  )
)

env &lt;- rbind(occEnv, bgEnv)
env &lt;- cbind(presBg, env)

predictors &lt;- c('bio1', 'bio12')

### calibrate models
####################

# Note that all of the trainXYZ functions can made to go faster using the
# "cores" argument (set to just 1, by default). The examples below will not
# go too much faster using more cores because they are simplified, but
# you can try!
cores &lt;- 1

# MaxEnt
mx &lt;- trainMaxEnt(
	data = env,
	resp = 'presBg',
	preds = predictors,
	regMult = 1, # too few values for reliable model, but fast
	verbose = TRUE,
	cores = cores
)

# MaxNet
mn &lt;- trainMaxNet(
	data = env,
	resp = 'presBg',
	preds = predictors,
	regMult = 1, # too few values for reliable model, but fast
	verbose = TRUE,
	cores = cores
)

# generalized linear model (GLM)
gl &lt;- trainGLM(
	data = env,
	resp = 'presBg',
	preds = predictors,
	scale = TRUE, # automatic scaling of predictors
	verbose = TRUE,
	cores = cores
)

# generalized additive model (GAM)
ga &lt;- trainGAM(
	data = env,
	resp = 'presBg',
	preds = predictors,
	verbose = TRUE,
	cores = cores
)

# natural splines
ns &lt;- trainNS(
	data = env,
	resp = 'presBg',
	preds = predictors,
	scale = TRUE, # automatic scaling of predictors
	df = 1:2, # too few values for reliable model(?)
	verbose = TRUE,
	cores = cores
)

# boosted regression trees
envSub &lt;- env[1:1049, ] # subsetting data to run faster
brt &lt;- trainBRT(
	data = envSub,
	resp = 'presBg',
	preds = predictors,
	learningRate = 0.001, # too few values for reliable model(?)
	treeComplexity = c(2, 3), # too few values for reliable model, but fast
	minTrees = 1200, # minimum trees for reliable model(?), but fast
	maxTrees = 1200, # too small for reliable model(?), but fast
	tryBy = 'treeComplexity',
	anyway = TRUE, # return models that did not converge
	verbose = TRUE,
	cores = cores
)

# random forests
rf &lt;- trainRF(
	data = env,
	resp = 'presBg',
	preds = predictors,
	numTrees = c(100, 500), # using at least 500 recommended, but fast!
	verbose = TRUE,
	cores = cores
)

### make maps of models
#######################

# NB We do not have to scale rasters before predicting GLMs and NSs because we
# used the `scale = TRUE` argument in trainGLM() and trainNS().

mxMap &lt;- predictEnmSdm(mx, madClim)
mnMap &lt;- predictEnmSdm(mn, madClim) 
glMap &lt;- predictEnmSdm(gl, madClim)
gaMap &lt;- predictEnmSdm(ga, madClim)
nsMap &lt;- predictEnmSdm(ns, madClim)
brtMap &lt;- predictEnmSdm(brt, madClim)
rfMap &lt;- predictEnmSdm(rf, madClim)

maps &lt;- c(
	mxMap,
	mnMap,
	glMap,
	gaMap,
	nsMap,
	brtMap,
	rfMap
)

names(maps) &lt;- c('MaxEnt', 'MaxNet', 'GLM', 'GAM', 'NSs', 'BRTs', 'RFs')
fun &lt;- function() plot(occs, col='black', pch=3, add=TRUE)
plot(maps, fun = fun, nc = 4)

### compare model responses to BIO12 (mean annual precipitation)
################################################################

# make a data frame holding all other variables at mean across occurrences,
# varying only BIO12
occEnvMeans &lt;- colMeans(occEnv, na.rm=TRUE)
occEnvMeans &lt;- rbind(occEnvMeans)
occEnvMeans &lt;- as.data.frame(occEnvMeans)
climFrame &lt;- occEnvMeans[rep(1, 100), ]
rownames(climFrame) &lt;- NULL

minBio12 &lt;- min(env$bio12)
maxBio12 &lt;- max(env$bio12)
climFrame$bio12 &lt;- seq(minBio12, maxBio12, length.out=100)

predMx &lt;- predictEnmSdm(mx, climFrame)
predMn &lt;- predictEnmSdm(mn, climFrame)
predGl &lt;- predictEnmSdm(gl, climFrame)
predGa &lt;- predictEnmSdm(ga, climFrame)
predNat &lt;- predictEnmSdm(ns, climFrame)
predBrt &lt;- predictEnmSdm(brt, climFrame)
predRf &lt;- predictEnmSdm(rf, climFrame)


plot(climFrame$bio12, predMx,
xlab='BIO12', ylab='Prediction', type='l', ylim=c(0, 1))

lines(climFrame$bio12, predMn, lty='solid', col='red')
lines(climFrame$bio12, predGl, lty='dotted', col='blue')
lines(climFrame$bio12, predGa, lty='dashed', col='green')
lines(climFrame$bio12, predNat, lty=4, col='purple')
lines(climFrame$bio12, predBrt, lty=5, col='orange')
lines(climFrame$bio12, predRf, lty=6, col='cyan')

legend(
   'topleft',
   inset = 0.01,
   legend = c(
	'MaxEnt',
	'MaxNet',
	'GLM',
	'GAM',
	'NS',
	'BRT',
	'RF'
   ),
   lty = c(1, 1:6),
   col = c(
	'black',
	'red',
	'blue',
	'green',
	'purple',
	'orange',
	'cyan'
   ),
   bg = 'white'
)


</code></pre>


</div>