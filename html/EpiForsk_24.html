<div class="container">

<table style="width: 100%;"><tr>
<td>flatten_date_intervals</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Flatten Date Intervals</h2>

<h3>Description</h3>

<p>A tidyverse compatible function for simplifying time interval data
</p>


<h3>Usage</h3>

<pre><code class="language-R">flatten_date_intervals(
  data,
  id,
  in_date,
  out_date,
  status = NULL,
  overlap_handling = "most_recent",
  lag = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a lazy
data frame (e.g. from dbplyr or dtplyr).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>&lt;<code>tidy-select</code>&gt; One or more unquoted
expression naming the id variables in data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in_date</code></td>
<td>
<p>&lt;<code>data-masking</code>&gt; One unquoted
expressions naming the start date variable in data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out_date</code></td>
<td>
<p>&lt;<code>data-masking</code>&gt; One unquoted
expression naming the end date variable in data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>status</code></td>
<td>
<p>&lt;<code>tidy-select</code>&gt; One or more unquoted
expressions naming a status variable in data, such as region or
hospitalization reason.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overlap_handling</code></td>
<td>
<p>A character naming the method for handling overlaps
within an individuals time when <code>status</code> has been specified.
</p>

<ul>
<li>
<p> "none": No special handling of the overlapping time intervals within
person is done.
</p>
</li>
<li>
<p> "first": The <code>status</code> mentioned first, that is, has the smallest
<code>in_date</code>, dominates.
</p>
</li>
<li>
<p> "most_recent" (default): The most recent <code>status</code>, that is, the one with
the largest <code>in_date</code>, dominates. When the most recent <code>status</code> is fully
contained within an older (and different) <code>status</code> then the <code>out_date</code>
associated with the most recent <code>in_date</code> is kept, but the remaining time
from the older <code>status</code> is removed. See examples below.
</p>
</li>
</ul>
<p>We currently don't have a method that lets the most recent status dominate
and then potentially return to an older longer running status. If this is
needed, please contact ADLS.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag</code></td>
<td>
<p>A numeric, giving the number of days allowed between time
intervals that should be collapsed into one.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This functions identifies overlapping time intervals within individual and
collapses them into distinct and disjoint intervals. When <code>status</code> is
specified these intervals are both individual and status specific.
</p>
<p>If <code>lag</code> is specified then intervals must be more then <code>lag</code> time units apart
to be considered distinct.
</p>


<h3>Value</h3>

<p>A data frame with the <code>id</code>, <code>status</code> if specified and simplified <code>in_date</code>
and <code>out_date</code>. The returned data is sorted by <code>id</code> and <code>in_date</code>.
</p>


<h3>Author(s)</h3>

<p>ADLS, EMTH &amp; ASO
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### The flatten function works with both dates and numeric

dat &lt;- data.frame(
   ID    = c(1, 1, 1, 2, 2, 3, 3, 4),
   START = c(1, 2, 5, 3, 6, 2, 3, 6),
   END   = c(3, 3, 7, 4, 9, 3, 5, 8))
dat |&gt; flatten_date_intervals(ID, START, END)

dat &lt;- data.frame(
   ID    = c(1, 1, 1, 2, 2, 3, 3, 4, 4),
   START = as.Date(c("2012-02-15", "2005-12-13", "2006-01-24",
                     "2002-03-14", "1997-02-27",
                     "2008-08-13", "1998-09-23",
                     "2005-01-12", "2007-05-10")),
   END   = as.Date(c("2012-06-03", "2007-02-05", "2006-08-22",
                     "2005-02-26", "1999-04-16",
                     "2008-08-22", "2015-01-29",
                     "2007-05-07", "2008-12-12")))
dat |&gt; flatten_date_intervals(ID, START, END)



###  Allow for a 5 days lag between

dat |&gt; flatten_date_intervals(ID, START, END, lag = 5)



### Adding status information

dat &lt;- data.frame(
   ID     = c(1, 1, 1, 2, 2, 3, 3, 4, 4),
   START  = as.Date(c("2012-02-15", "2005-12-13", "2006-01-24",
                      "2002-03-14", "1997-02-27",
                      "2008-08-13", "1998-09-23",
                      "2005-01-12", "2007-05-10")),
   END    = as.Date(c("2012-06-03", "2007-02-05", "2006-08-22",
                      "2005-02-26", "1999-04-16",
                      "2008-08-22", "2015-01-29",
                     "2007-05-07", "2008-12-12")),
   REGION = c("H", "H", "N", "S", "S", "M", "N", "S", "S"))

# Note the difference between the the different overlap_handling methods
dat |&gt; flatten_date_intervals(ID, START, END, REGION, "none")
dat |&gt; flatten_date_intervals(ID, START, END, REGION, "first")
dat |&gt; flatten_date_intervals(ID, START, END, REGION, "most_recent")

</code></pre>


</div>