<div class="container">

<table style="width: 100%;"><tr>
<td>e_rows_update</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Update rows of a tibble</h2>

<h3>Description</h3>

<p>Update rows of a tibble
</p>


<h3>Usage</h3>

<pre><code class="language-R">e_rows_update(
  x,
  y,
  by = NULL,
  ...,
  match,
  unmatched = c("error", "ignore"),
  copy = FALSE,
  in_place = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>A pair of data frames or data frame extensions (e.g. a tibble).
<code>y</code> must have the same columns of <code>x</code> or a subset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>An unnamed character vector giving the key columns. The key columns
must exist in both <code>x</code> and <code>y</code>. Keys typically uniquely identify each row,
but this is only enforced for the key values of <code>y</code> when <code>rows_update()</code>,
<code>rows_patch()</code>, or <code>rows_upsert()</code> are used.
</p>
<p>By default, we use the first column in <code>y</code>, since the first column is
a reasonable place to put an identifier variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match</code></td>
<td>
<p>named <code>list</code> consisting out of two equal length <code>data.frame</code>'s with columns defined in <code>by</code>.
This allows for updates of columns defined in <code>by</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unmatched</code></td>
<td>
<p>For <code>rows_update()</code>, <code>rows_patch()</code>, and <code>rows_delete()</code>,
how should keys in <code>y</code> that are unmatched by the keys in <code>x</code> be handled?
</p>
<p>One of:
</p>

<ul>
<li> <p><code>"error"</code>, the default, will error if there are any keys in <code>y</code> that
are unmatched by the keys in <code>x</code>.
</p>
</li>
<li> <p><code>"ignore"</code> will ignore rows in <code>y</code> with keys that are unmatched by the
keys in <code>x</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in_place</code></td>
<td>
<p>Should <code>x</code> be modified in place? This argument is only
relevant for mutable backends (e.g. databases, data.tables).
</p>
<p>When <code>TRUE</code>, a modified version of <code>x</code> is returned invisibly;
when <code>FALSE</code>, a new object representing the resulting changes is returned.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Mainly a wrapper around <code>rows_update</code>.
Allows for specific implementations should the behavior differ from what's needed by <code>editbl</code>.
Reason for separate method is to avoid conflicts on package loading.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>x</code>. The order of the rows and columns of <code>x</code>
is preserved as much as possible. The output has the following properties:
</p>

<ul>
<li> <p><code>rows_update()</code> and <code>rows_patch()</code> preserve the number of rows;
<code>rows_insert()</code>, <code>rows_append()</code>, and <code>rows_upsert()</code> return all existing
rows and potentially new rows; <code>rows_delete()</code> returns a subset of the
rows.
</p>
</li>
<li>
<p> Columns are not added, removed, or relocated, though the data may be
updated.
</p>
</li>
<li>
<p> Groups are taken from <code>x</code>.
</p>
</li>
<li>
<p> Data frame attributes are taken from <code>x</code>.
</p>
</li>
</ul>
<p>If <code>in_place = TRUE</code>, the result will be returned invisibly.
</p>


</div>