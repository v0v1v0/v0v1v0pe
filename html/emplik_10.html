<div class="container">

<table style="width: 100%;"><tr>
<td>el.cen.kmc1d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Empirical likelihood ratio for 1 mean constraint 
with right censored data</h2>

<h3>Description</h3>

<p>This program uses a fast recursive formula to compute the maximized 
(wrt <code class="reqn">p_i</code>) empirical
log likelihood ratio for right censored data with 
one MEAN constraint:
</p>
<p style="text-align: center;"><code class="reqn"> \sum_{d_i=1}  p_i f(x_i)  = \int f(t) dF(t) = \mu . </code>
</p>

<p>Where <code class="reqn">p_i = \Delta F(x_i)</code> is a probability,
<code class="reqn">d_i</code> is the censoring indicator, 1(uncensored), 0(right censored). 
It also returns those <code class="reqn">p_i</code>. 
</p>
<p>The empirical log likelihood been maximized is
</p>
<p style="text-align: center;"><code class="reqn"> \sum_{d_i=1} \log \Delta F(x_i) + \sum_{d_i=0} \log [1-F(x_i)] . </code>
</p>
 


<h3>Usage</h3>

<pre><code class="language-R">el.cen.kmc1d(x, d, fun, mu, tol = .Machine$double.eps^0.5, step=0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector containing the observed survival times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>a vector containing the censoring indicators, 
1-uncensored; 0-right censored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>a left continuous (weight) function used to calculate
the mean as in <code class="reqn">H_0</code>.
<code>fun(t)</code> must be able to take a vector input <code>t</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a real number used in the constraint, the mean value of <code class="reqn">f(X)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>a small positive number, for the uniroot error tol.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>a small positive number, for use in the uniroot function (as interval) to find lambda root. Sometimes 
uniroot will find the wrong root or no root, resulting a negative "-2LLR" or NA. Change the step to a different 
value often can fix this (but not always). Another sign of wrong root is that
the sum of probabilities not sum to one, or has negative probability values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments, if any, to pass to fun.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is similar to the function in package <code>kmc</code>, but much simpler, i.e.
all implemented in R and only for one mean.
This implementation have two for-loops in R. 
A faster version would use C to do the for-loop part.
But this version seems fast enough and is easier to port to Splus.
</p>
<p>We return the log likelihood all the time. Sometimes, (for right censored case) 
we also return the -2 log likelihood ratio.
In other cases, you have to plot a curve with many values of the 
parameter, mu, to
find out where is the place the log likelihood becomes maximum.
And from there you can get -2 log likelihood ratio between
the maximum location and your current parameter in Ho.
</p>
<p>The input <code>step</code> is used in uniroot function to find a root of lambda. Sometimes
a step value may lead to no root or result in a wrong root. You may try several values 
for the step to see. If the probabilities returned do not sum to one, then the lambda root is a wrong root.
We want the root closest to zero.
</p>
<p>In order to get a proper distribution as NPMLE, we automatically
change the <code class="reqn">d</code> for the largest observation to 1
(even if it is right censored).
<code class="reqn">\mu</code> is a given constant. 
When the given constants <code class="reqn">\mu</code> is too far
away from the NPMLE, there will be no distribution
satisfy the constraint.
In this case the computation will stop or return something ridiculas, (as negative -2LLR).
The -2 Log empirical likelihood ratio
may be +infinite. 
</p>
<p>The constant <code>mu</code> must be inside 
<code class="reqn">( \min f(x_i) , \max f(x_i) ) </code> (with uncensored <code class="reqn">x_i</code>)
for the computation to continue. 
It is always true that the NPMLE values are feasible. So when the
computation stops, try move the <code>mu</code> closer
to the NPMLE â€” 
</p>
<p style="text-align: center;"><code class="reqn"> \sum_{d_i=1} p_i^0 f(x_i) </code>
</p>
 
<p><code class="reqn">p_i^0</code> taken to be the jumps of the NPMLE of CDF. 
Or use a different <code>fun</code>. 
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>the maximized empirical log likelihood under the constraint. Note, here the tied observations are
not collapsed into one obs. with weight 2 (as in el.cen.EM), so the value may differ from those
that do collapse the tied obs. In any case, the -2LLR should not differ (whether collaps or not).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>locations of CDF that have positive mass.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>the jump size of CDF at those locations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>"-2LLR"</code></td>
<td>
<p>If available, it is minus two times the 
empirical Log Likelihood Ratio.
Should be approximately chi-square distributed under Ho. If you got NA or negative value, then something is wrong,
most likely the uniroot has found the wrong root. Suggest: use el.cen.EM2() which uses EM algorithm. It is more stable but slower. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pval</code></td>
<td>
<p>The P-value of the test, using chi-square approximation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam</code></td>
<td>
<p>The Lagrange multiplier.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Mai Zhou </p>


<h3>References</h3>

<p>Zhou, M. and Yang, Y. (2015). A recursive formula for the Kaplan-Meier estimator with mean constraints 
and its application to empirical likelihood.
<em>Computational Statistics</em>  Vol. 30, Issue 4 pp. 1097-1109.
</p>
<p>Zhou, M. (2005). Empirical likelihood ratio with arbitrary censored/truncated data by EM algorithm. 
<em>Journal of Computational and Graphical Statistics</em>, 14(3), 643-656.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- c(1, 1.5, 2, 3, 4.2, 5, 6.1, 5.3, 4.5, 0.9, 2.1, 4.3)
d &lt;- c(1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1)
ff &lt;- function(x) {
    x - 3.7
}
el.cen.kmc1d(x=x, d=d, fun=ff, mu=0)
#######################################
## example with tied observations
x &lt;- c(1, 1.5, 2, 3, 4, 5, 6, 5, 4, 1, 2, 4.5)
d &lt;- c(1,   1, 0, 1, 0, 1, 1, 1, 1, 0, 0,   1)
el.cen.EM(x,d,mu=3.5)
## we should get "-2LLR" = 1.2466....
myfun5 &lt;- function(x, theta, eps) {
u &lt;- (x-theta)*sqrt(5)/eps 
INDE &lt;- (u &lt; sqrt(5)) &amp; (u &gt; -sqrt(5)) 
u[u &gt;= sqrt(5)] &lt;- 0 
u[u &lt;= -sqrt(5)] &lt;- 1 
y &lt;- 0.5 - (u - (u)^3/15)*3/(4*sqrt(5)) 
u[ INDE ] &lt;- y[ INDE ] 
return(u)
}
el.cen.EM(x, d, fun=myfun5, mu=0.5, theta=3.5, eps=0.1)
## example of using wt in the input. Since the x-vector contain
## two 5 (both d=1), and two 2(both d=0), we can also do
xx &lt;- c(1, 1.5, 2, 3, 4, 5, 6, 4, 1, 4.5)
dd &lt;- c(1,   1, 0, 1, 0, 1, 1, 1, 0,   1)
wt &lt;- c(1,   1, 2, 1, 1, 2, 1, 1, 1,   1)
el.cen.EM(x=xx, d=dd, wt=wt, mu=3.5)
## this should be the same as the first example.
</code></pre>


</div>