<div class="container">

<table style="width: 100%;"><tr>
<td>ei.MD.bayes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multinomial Dirichlet model for Ecological Inference in RxC tables</h2>

<h3>Description</h3>

<p>Implements a version of the hierarchical model suggested in Rosen et al. (2001)</p>


<h3>Usage</h3>

<pre><code class="language-R">ei.MD.bayes(formula, covariate = NULL, total = NULL, data, 
            lambda1 = 4, lambda2 = 2, covariate.prior.list = NULL,
            tune.list = NULL, start.list = NULL, sample = 1000, thin = 1, 
            burnin = 1000, verbose = 0, ret.beta = 'r', 
            ret.mcmc = TRUE, usrfun = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula of the form <code>cbind(col1, col2, ...) ~
      cbind(row1, row2, ...)</code>.   Column and row marginals must have the
same totals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate</code></td>
<td>
<p>An optional formula of the form <code>~ covariate</code>.  The 
default is <code>covariate = NULL</code>, which fits the model without a covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total</code></td>
<td>
<p>if row and/or column marginals are given as proportions,
<code>total</code> identifies the name of the variable in <code>data</code> containing the
total number of individuals in each unit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing the variables specified in
<code>formula</code> and <code>total</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p>The shape parameter for the gamma prior (defaults to 4)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>
<p>The rate parameter for the gamma prior (defaults to 2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate.prior.list</code></td>
<td>
<p>a list containing the parameters for
normal prior distributions on delta and gamma for model with
covariate.  See ‘details’ for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune.list</code></td>
<td>
<p>A list containing tuning parameters for each block of
parameters.  See ‘details’ for more information.  Typically, this
will be a list generated by <code>tuneMD</code>.  The
default is <code>NULL</code>, in which case fixed tuning parameters are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.list</code></td>
<td>
<p>A list containing starting values for each block of
parameters.  See ‘details’ for more information.  The default is
<code>start.list = NULL</code>, which generates appropriate random starting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample</code></td>
<td>
<p>Number of draws to be saved from chain
and returned as output from the function (defaults to 1000).  The total
length of the chain is <code>sample</code>*<code>thin</code> + <code>burnin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>an integer specifying the thinning interval for posterior
draws (defaults to 1, but most problems will require a much larger thinning interval).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>integer specifying the number of initial iterations to be discarded (defaults to 1000, but most problems will require a longer burnin).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>an integer specifying whether the progress of the sampler 
is printed to the screen (defaults to 0).  If <code>verbose</code> is greater than 0, the
iteration number is printed to the screen every <code>verbose</code>th
iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ret.beta</code></td>
<td>
<p>A character indicating how the posterior draws of beta should be  
handled: '<code>r</code>'eturn as an R object, '<code>s</code>'ave as .txt.gz
files, '<code>d</code>'iscard (defaults to <code>r</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ret.mcmc</code></td>
<td>
<p>A logical value indicating how the samples from the posterior 
should be returned.  If <code>TRUE</code> (default), samples are returned as
coda <code>mcmc</code> objects.  If <code>FALSE</code>, samples are returned as arrays.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usrfun</code></td>
<td>
<p>the name of an optional a user-defined function to obtain quantities of
interest while drawing from the MCMC chain (defaults to <code>NULL</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>ei.MD.bayes</code> implements a version of the hierarchical
Multinomial-Dirichlet model for ecological inference in <code class="reqn">R
    \times C</code> tables suggested by Rosen et al. (2001).
</p>
<p>Let <code class="reqn">r = 1, \ldots, R</code> index rows, <code class="reqn">C = 1,
    \ldots, C</code> index columns, and <code class="reqn">i = 1, \ldots,
    n</code> index units.  Let <code class="reqn">N_{\cdot ci}</code> be the
marginal count for column <code class="reqn">c</code> in unit <code class="reqn">i</code> and <code class="reqn">X_{ri}</code> be the
marginal proportion for row <code class="reqn">r</code> in unit <code class="reqn">i</code>.  Finally, let
<code class="reqn">\beta_{rci}</code> be the proportion of row <code class="reqn">r</code> in column <code class="reqn">c</code>
for unit <code class="reqn">i</code>.
</p>
<p>The first stage of the model assumes that the vector of column
marginal counts in unit <code class="reqn">i</code> follows a Multinomial distribution of the
form:
</p>
<p style="text-align: center;"><code class="reqn">(N_{\cdot 1i}, \ldots, N_{\cdot Ci}) {\sim}
    {\rm Multinomial}(N_i,\sum_{r=1}^R \beta_{r1i}X_{ri}, \dots,
    \sum_{r=1}^R \beta_{rCi}X_{ri})</code>
</p>

<p>The second stage of the model assumes that the vector of
<code class="reqn">\beta</code> for row <code class="reqn">r</code> in unit <code class="reqn">i</code> follows a Dirichlet
distribution with <code class="reqn">C</code> parameters.  The model may be fit with or
without a covariate. 
</p>
<p>If the model is fit without a covariate, the distribution of the vector
<code class="reqn">\beta_{ri}</code> is :
</p>
<p style="text-align: center;"><code class="reqn">(\beta_{r1i}, \dots, \beta_{rCi}) {\sim} {\rm
      Dirichlet}(\alpha_{r1}, \dots, \alpha_{rC})</code>
</p>

<p>In this case, the prior on each <code class="reqn">\alpha_{rc}</code> is assumed
to be:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_{rc} \sim {\rm Gamma}(\lambda_1, \lambda_2)</code>
</p>

<p>If the model is fit with a covariate, the  distribution of the vector
<code class="reqn">\beta_{ri}</code> is :
</p>
<p style="text-align: center;"><code class="reqn">(\beta_{r1i}, \dots, \beta_{rCi}) {\sim} {\rm
      Dirichlet}(d_r\exp(\gamma_{r1} + \delta_{r1}Z_i),
    d_r\exp(\gamma_{r(C-1)} + \delta_{r(C-1)}Z_i), d_r)</code>
</p>

<p>The parameters <code class="reqn">\gamma_{rC}</code> and
<code class="reqn">\delta_{rC}</code> are constrained to be zero for
identification.  (In this function, the last column entered in the
formula is so constrained.)
</p>
<p>Finally, the prior for <code class="reqn">d_r</code> is: 
</p>
<p style="text-align: center;"><code class="reqn">d_r \sim {\rm Gamma}(\lambda_1, \lambda_2)</code>
</p>

<p>while <code class="reqn">\gamma_{rC}</code> and <code class="reqn">\delta_{rC}</code> are
given improper uniform priors if <code>covariate.prior.list = NULL</code> or
have independent normal priors of the form:
</p>
<p style="text-align: center;"><code class="reqn">\delta_{rC} \sim {\rm N}(\mu_{\delta_{rC}},
     \sigma_{\delta_{rC}}^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma_{rC} \sim {\rm N}(\mu_{\gamma_{rC}},
     \sigma_{\gamma_{rC}}^2)</code>
</p>

<p>If the user wishes to estimate the model with proper normal priors on
<code class="reqn">\gamma_{rC}</code> and <code class="reqn">\delta_{rC}</code>, a list
with four elements must be provided for <code>covariate.prior.list</code>:
</p>

<ul>
<li>
<p><code>mu.delta</code> an <code class="reqn">R \times (C-1)</code> matrix of
prior means for Delta
</p>
</li>
<li>
<p><code>sigma.delta</code> an <code class="reqn">R \times (C-1)</code> matrix of
prior standard deviations for Delta 
</p>
</li>
<li>
<p><code>mu.gamma</code> an <code class="reqn">R \times (C-1)</code> matrix of
prior means for Gamma 
</p>
</li>
<li>
<p><code>sigma.gamma</code> an <code class="reqn">R \times (C-1)</code> matrix of
prior standard deviations for Gamma</p>
</li>
</ul>
<p>Applying the model without a covariate is
most reasonable in situations where one can think of individuals being
randomly assigned to units, so that there are no aggregation or
contextual effects.  When this assumption is not reasonable,
including an appropriate covariate may improve inferences; note,
however, that there is typically little information in the data about
the relationship of any given covariate to the unit parameters, which can
lead to extremely slow mixing of the MCMC chains and difficulty in
assessing convergence.
</p>
<p>Because the conditional distributions are non-standard, draws from the
posterior are obtained by using a Metropolis-within-Gibbs algorithm.
The proposal density for each parameter is a univariate normal
distribution centered at the current parameter value with standard
deviation equal to the tuning constant; the only exception is for
draws of <code class="reqn">\gamma_{rc}</code> and <code class="reqn">\delta_{rc}</code>, which
use a bivariate normal proposal with covariance zero.  
</p>
<p>The function will accept user-specified starting values as an argument.
If the model includes a covariate, the starting values must be a list
with the following elements, in this order:
</p>

<ul>
<li>
<p><code>start.dr</code> a vector of length <code class="reqn">R</code> of starting values for Dr.
Starting values for Dr must be greater than zero.
</p>
</li>
<li>
<p><code>start.betas</code> an <code class="reqn">R \times C</code> by precincts array
of starting values for Beta.  Each row of every precinct must sum to 1.
</p>
</li>
<li>
<p><code>start.gamma</code> an <code class="reqn">R \times C</code> matrix of starting
values for Gamma.  Values in the right-most column must be zero.
</p>
</li>
<li>
<p><code>start.delta</code> an <code class="reqn">R \times C</code> matrix of starting
values for Delta.  Values in the right-most column must be zero.
</p>
</li>
</ul>
<p>If there is no covariate, the starting values must be a list with the following elements:
</p>

<ul>
<li>
<p><code>start.alphas</code> an <code class="reqn">R \times C</code> matrix of starting values for Alpha.  Starting values for Alpha must be greater than zero.
</p>
</li>
<li>
<p><code>start.betas</code> an <code class="reqn">R \times C \times</code> units array of
starting values for Beta.  Each row in every unit must sum to 1.</p>
</li>
</ul>
<p>The function will accept user-specified tuning parameters as an
argument.  The tuning parameters define the standard deviation of the
normal distribution used to generate candidate values for each
parameter.  For the model with a covariate, a bivariate normal
distribution is used to generate proposals; the covariance of these
normal distributions is fixed at zero.  If the model includes a covariate, the tuning parameters must be a list with the following elements, in this order:
</p>

<ul>
<li>
<p><code>tune.dr</code> a vector of length <code class="reqn">R</code> of tuning parameters for Dr
</p>
</li>
<li>
<p><code>tune.beta</code> an <code class="reqn">R \times (C-1)</code> by precincts array
of tuning parameters for Beta 
</p>
</li>
<li>
<p><code>tune.gamma</code> an <code class="reqn">R \times (C-1)</code> matrix of tuning
parameters for Gamma 
</p>
</li>
<li>
<p><code>tune.delta</code> an <code class="reqn">R \times (C-1)</code> matrix of tuning
parameters for Delta</p>
</li>
</ul>
<p>If there is no covariate, the tuning parameters are a list with the following elements:
</p>

<ul>
<li>
<p><code>tune.alpha</code> an <code class="reqn">R \times C</code> matrix of tuning parameters for Alpha
</p>
</li>
<li>
<p><code>tune.beta</code> an <code class="reqn">R \times (C-1)</code> by precincts array
of tuning parameters for Beta
</p>
</li>
</ul>
<h3>Value</h3>

<p>A list containing 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>draws</code></td>
<td>
<p>A list containing samples from the posterior distribution
of the parameters.  If a covariate is included in the model, the list contains: 
</p>

<ul>
<li>
<p><code>Dr</code> Posterior draws for Dr parameters as an R
<code class="reqn">\times</code>sample matrix.  If
<code>ret.mcmc = TRUE</code>, <code>Dr</code> is an <code>mcmc</code> object.
</p>
</li>
<li>
<p><code>Beta</code> Posterior draws for beta parameters.  Only returned if 
<code>ret.beta = TRUE</code>.  If <code>ret.mcmc = 
TRUE</code>, a  (R * C * units) <code class="reqn">\times</code> sample matrix saved as an <code>mcmc</code> 
object.  Otherwise, a R <code class="reqn">\times</code> C <code class="reqn">\times</code> units
<code class="reqn">\times</code> sample array
</p>
</li>
<li>
<p><code>Gamma</code> Posterior draws for gamma parameters.  If <code>ret.mcmc =
TRUE</code>, a  (R * (C - 1)) <code class="reqn">\times</code> sample matrix saved as an <code>mcmc</code>
object.  Otherwise, a R <code class="reqn">\times</code> (C - 1) <code class="reqn">\times</code> sample array
</p>
</li>
<li>
<p><code>Delta</code> Posterior draws for delta parameters.  If <code>ret.mcmc =                 
TRUE</code>, a  (R * (C - 1)) <code class="reqn">\times</code> sample matrix saved as an <code>mcmc</code>      
object.  Otherwise, a R <code class="reqn">\times</code>(C - 1) <code class="reqn">\times</code> sample array
</p>
</li>
<li>
<p><code>Cell.count</code> Posterior draws for the cell counts, summed
across units.  If <code>ret.mcmc =
    TRUE</code>, a (R * C) <code class="reqn">\times</code> sample matrix saved as an <code>mcmc</code> object.
Otherwise, a R <code class="reqn">\times</code> C <code class="reqn">\times</code> sample array
</p>
</li>
</ul>
<p>If the model is fit without a covariate, the list includes:
</p>

<ul>
<li>
<p><code>Alpha</code> Posterior draws for alpha parameters.  If <code>ret.mcmc =
    TRUE</code>, a (R * C) <code class="reqn">\times</code> sample matrix saved as an <code>mcmc</code> object.
Otherwise, a R <code class="reqn">\times</code> C <code class="reqn">\times</code> sample array
</p>
</li>
<li>
<p><code>Beta</code> Posterior draws for beta parameters.  If <code>ret.mcmc =
    TRUE</code>, a (R * C * units) <code class="reqn">\times</code> sample matrix saved as
an <code>mcmc</code> object. 
Otherwise, a R <code class="reqn">\times</code> C <code class="reqn">\times</code> units
<code class="reqn">\times</code> sample array 
</p>
</li>
<li>
<p><code>Cell.count</code> Posterior draws for the cell counts, summed
across units.  If <code>ret.mcmc =
    TRUE</code>, a (R * C) <code class="reqn">\times</code> sample matrix saved as an<code>mcmc</code> object.
Otherwise, a R <code class="reqn">\times</code> C <code class="reqn">\times</code> sample array
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acc.ratios</code></td>
<td>
<p> A list containing acceptance ratios for the
parameters.  If the model includes a covariate, the list includes:
</p>
  
<ul>
<li>
<p><code>dr.acc</code> A vector of acceptance ratios for <code>Dr</code> draws
</p>
</li>
<li>
<p><code>beta.acc</code> A vector of acceptance ratios for <code>Beta</code> draws
</p>
</li>
<li>
<p><code>gamma.acc</code> A vector of acceptance ratios for <code>Gamma</code> and
<code>Delta</code> draws
</p>
</li>
</ul>
<p>If the model is fit without a covariate , the list includes:
</p>

<ul>
<li>
<p><code>alpha.acc</code> A vector of acceptance ratios for <code>Alpha</code> draws
</p>
</li>
<li>
<p><code>beta.acc</code> A vector of acceptance ratios for <code>Beta</code> draws  
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usrfun</code></td>
<td>
<p>Output from the optional <code>usrfn</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>Call to <code>ei.MD.bayes</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Michael Kellermann &lt;<a href="mailto:mrkellermann@gmail.com">mrkellermann@gmail.com</a>&gt; and Olivia Lau 
&lt;<a href="mailto:olivia.lau@post.harvard.edu">olivia.lau@post.harvard.edu</a>&gt;
</p>


<h3>References</h3>

<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2002.
<em>Output Analysis and Diagnostics for MCMC (CODA)</em>. <a href="https://CRAN.R-project.org/package=coda">https://CRAN.R-project.org/package=coda</a>.
</p>
<p>Ori Rosen, Wenxin Jiang, Gary King, and Martin A. Tanner.
2001.  “Bayesian and Frequentist Inference for Ecological
Inference: The <code class="reqn">R \times (C-1)</code> Case.” 
<em>Statistica Neerlandica</em> 55: 134-156.  </p>


<h3>See Also</h3>

<p><code>lambda.MD</code>, <code>cover.plot</code>, 
<code>density.plot</code>, <code>tuneMD</code>, 
<code>mergeMD</code></p>


</div>