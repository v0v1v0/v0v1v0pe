<div class="container">

<table style="width: 100%;"><tr>
<td>percolate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Percolater</h2>

<h3>Description</h3>

<p>Store queries into an index then, via the percolate API, define
documents to retrieve these queries.
</p>


<h3>Usage</h3>

<pre><code class="language-R">percolate_register(
  conn,
  index,
  id,
  type = NULL,
  body = list(),
  routing = NULL,
  preference = NULL,
  ignore_unavailable = NULL,
  percolate_format = NULL,
  refresh = NULL,
  ...
)

percolate_match(
  conn,
  index,
  type = NULL,
  body,
  routing = NULL,
  preference = NULL,
  ignore_unavailable = NULL,
  percolate_format = NULL,
  ...
)

percolate_list(conn, index, ...)

percolate_count(conn, index, type, body, ...)

percolate_delete(conn, index, id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code>connect()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>Index name. Required</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>A precolator id. Required</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Document type. Required</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>body</code></td>
<td>
<p>Body json, or R list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>routing</code></td>
<td>
<p>(character) In case the percolate queries are partitioned by a custom
routing value, that routing option makes sure that the percolate request only gets
executed on the shard where the routing value is partitioned to. This means that the
percolate request only gets executed on one shard instead of all shards. Multiple values
can be specified as a comma separated string, in that case the request can be be executed
on more than one shard.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preference</code></td>
<td>
<p>(character) Controls which shard replicas are preferred to execute
the request on. Works the same as in the search API.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_unavailable</code></td>
<td>
<p>(logical) Controls if missing concrete indices should
silently be ignored. Same as is in the search API.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>percolate_format</code></td>
<td>
<p>(character) If ids is specified then the matches array in the
percolate response will contain a string array of the matching ids instead of an
array of objects. This can be useful to reduce the amount of data being send back to
the client. Obviously if there are two percolator queries with same id from different
indices there is no way to find out which percolator query belongs to what index. Any
other value to percolate_format will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refresh</code></td>
<td>
<p>If <code>TRUE</code> then refresh the affected shards to make this
operation visible to search, if "wait_for" then wait for a refresh to
make this operation visible to search, if <code>FALSE</code> (default) then do
nothing with refreshes. Valid choices: <code>TRUE</code>, <code>FALSE</code>, "wait_for"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Curl options. Or in <code>percolate_list</code> function, further args
passed on to <code>Search()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Additional body options, pass those in the body. These aren't query string
parameters:
</p>

<ul>
<li>
<p> filter - Reduces the number queries to execute during percolating. Only the
percolator queries that match with the filter will be included in the percolate
execution. The filter option works in near realtime, so a refresh needs to have
occurred for the filter to included the latest percolate queries.
</p>
</li>
<li>
<p> query - Same as the filter option, but also the score is computed. The
computed scores can then be used by the track_scores and sort option.
</p>
</li>
<li>
<p> size - Defines to maximum number of matches (percolate queries) to be returned.
Defaults to unlimited.
</p>
</li>
<li>
<p> track_scores - Whether the _score is included for each match. The _score is
based on the query and represents how the query matched the percolate query's
metadata, not how the document (that is being percolated) matched the query. The query
option is required for this option. Defaults to false.
</p>
</li>
<li>
<p> sort - Define a sort specification like in the search API. Currently only
sorting _score reverse (default relevancy) is supported. Other sort fields will
throw an exception. The size and query option are required for this setting. Like
track_score the score is based on the query and represents how the query matched
to the percolate query's metadata and not how the document being percolated matched
to the query.
</p>
</li>
<li>
<p> aggs - Allows aggregation definitions to be included. The aggregations are
based on the matching percolator queries, look at the aggregation documentation on
how to define aggregations.
</p>
</li>
<li>
<p> highlight - Allows highlight definitions to be included. The document being
percolated is being highlight for each matching query. This allows you to see how
each match is highlighting the document being percolated. See highlight documentation
on how to define highlights. The size option is required for highlighting, the
performance of highlighting in the percolate API depends of how many matches are
being highlighted.
</p>
</li>
</ul>
<h3>The Elasticsearch v5 split</h3>

<p>In Elasticsearch &lt; v5, there's a certain set of percolate APIs available,
while in Elasticsearch &gt;= v5, there's a different set of APIs available.
</p>
<p>Internally within these percolate functions we detect your Elasticsearch
version, then use the appropriate APIs
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-percolate-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-percolate-query.html</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
x &lt;- connect(errors = "complete")

##### Elasticsearch &lt; v5
if (x$es_ver() &lt; 500) {
# typical usage
## create an index first
if (index_exists(x, "myindex")) index_delete(x, "myindex")
mapping &lt;- '{
  "mappings": {
    "mytype": {
      "properties": {
        "message": {
           "type": "text"
        },
        "query": {
           "type": "percolator"
        }
      }
    }
  }
}'
index_create(x, "myindex", body = mapping)

## register a percolator
perc_body = '{
 "query" : {
    "match" : {
      "message" : "bonsai tree"
    }
 }
}'
percolate_register(x, index = "myindex", type = "mytype", 
  id = 1, body = perc_body)

## register another
perc_body2 &lt;- '{
  "query" : {
    "match" : {
      "message" : "jane doe"
    }
  }
}'
percolate_register(x, index = "myindex", type = "mytype", 
  id = 2, body = perc_body2)

## match a document to a percolator
doc &lt;- '{
 "query": {
   "percolate": {
     "field": "query",
     "document": {
       "message" : "A new bonsai tree in the office"
     }
   }
 }
}'
percolate_match(x, index = "myindex", type = "mytype", body = doc)

## List percolators - for an index, no type, can't do across indices
percolate_list(x, index = "myindex")$hits$hits

## Percolate counter
percolate_count(x, index = "myindex", type = "mytype", body = doc)$total

## delete a percolator
percolate_delete(x, index = "myindex", id = 2)
} # end ES &lt; 5


##### Elasticsearch &gt;= v5
if (x$es_ver() &gt;= 500 &amp;&amp; x$es_ver() &lt;= 700) {
if (index_exists(x, "myindex")) index_delete(x, "myindex")

body &lt;- '{
  "mappings": {
    "mytype": {
      "properties": {
        "message": {
           "type": "text"
        },
        "query": {
           "type": "percolator"
        }
      }
    }
  }
}'

# create the index with mapping
index_create(x, "myindex", body = body)

## register a percolator
z &lt;- '{
  "query" : {
     "match" : {
       "message" : "bonsai tree"
     }
  }
}'
percolate_register(x, index = "myindex", type = "mytype", id = 1, body = z)

## register another
x2 &lt;- '{
  "query" : {
    "match" : {
      "message" : "the office"
    }
  }
}'
percolate_register(x, index = "myindex", type = "mytype", id = 2, body = x2)

## match a document to a percolator
query &lt;- '{
  "query" : {
    "percolate" : {
      "field": "query",
      "document": {
        "message": "A new bonsai tree in the office"
      }
    }
  }
}'
percolate_match(x, index = "myindex", body = query)
} # end ES &gt;= 5




##### Elasticsearch &gt;= v7
if (x$es_ver() &gt;= 700) {
if (index_exists(x, "myindex")) index_delete(x, "myindex")

body &lt;- '{
  "mappings": {
    "properties": {
      "message": {
        "type": "text"
      },
      "query": {
        "type": "percolator"
      }
    }
  }
}'

# create the index with mapping
index_create(x, "myindex", body = body)

## register a percolator
z &lt;- '{
  "query" : {
     "match" : {
       "message" : "bonsai tree"
     }
  }
}'
percolate_register(x, index = "myindex", id = 1, body = z)

## register another
x2 &lt;- '{
  "query" : {
    "match" : {
      "message" : "the office"
    }
  }
}'
percolate_register(x, index = "myindex", id = 2, body = x2)

## match a document to a percolator
query &lt;- '{
  "query" : {
    "percolate" : {
      "field": "query",
      "document": {
        "message": "A new bonsai tree in the office"
      }
    }
  }
}'
percolate_match(x, index = "myindex", body = query)
} # end ES &gt;= 7



## End(Not run)
</code></pre>


</div>