<div class="container">

<table style="width: 100%;"><tr>
<td>equivalence.xyplot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constructs graphical regression-based tests of equivalence inside
a lattice coplot</h2>

<h3>Description</h3>

<p> Implements regression-based tests of equivalence within
lattice graphics.</p>


<h3>Usage</h3>

<pre><code class="language-R"> equivalence.xyplot(formula, alpha, b0.ii, b1.ii,
add.smooth=FALSE, b0.absolute=FALSE, ...)  </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula describing the form of conditioning plot. See
the manual entry for <code>xyplot</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p> the size of the test </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0.ii</code></td>
<td>
<p>the half-length of the region of similarity for the
intercept, can be relative or absolute (see below). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b1.ii</code></td>
<td>
<p>the half-length of the region of similarity for the
slope.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.smooth</code></td>
<td>
<p>adds a loess smooth to the graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0.absolute</code></td>
<td>
<p>is b0.ii in absolute or relative units?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> extra arguments passed on to <kbd>xyplot</kbd> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The graphic created by this function was proposed by Robinson et
al. (2005) as a visual summary of the regression-based TOST.  At first
glance the graph will look messy; interpretation eases with practice.  The
following points should be noted.
</p>

<ul>
<li>
<p>LS line:A black, solid line of best fit is added.
</p>
</li>
<li>
<p>Mean:A grey vertical bar indicates the mean of x and the TOST confidence
interval for the intercept.
</p>
</li>
<li>
<p>b0 R.S.:A shaded polygon is the region of
similarity of the intercept, to test the model bias.  
</p>
</li>
<li>
<p>Test b0:If the grey vertical bar is within the shaded polygon
then reject the null hypothesis of dissimilarity. This is a test of
<em>bias</em>. 
</p>
</li>
<li>
<p>...1 -If the <em>region</em> is too low then the predictions are
too low. 
</p>
</li>
<li>
<p>...2 -If the <em>region</em> is too high then the predictions are
too high. 
</p>
</li>
<li>
<p>...3 -If the <em>region</em> is too narrow then the predictions are
too variable. 
</p>
</li>
<li>
<p>b1 C.I.:A black vertical bar undermeath the grey bar represents a confidence
interval for the slope of the line of best fit.
</p>
</li>
<li>
<p>b1 R.S.:Two black dashed lines are added representing the region of
similarity.
</p>
</li>
<li>
<p>Test b1:If the black bar is within the angle
described by the dashed black lines then the slope of the
observed/predicted regression is significantly similar to 1. This
is a test of <em>proportionality</em>.
</p>
</li>
<li>
<p>...1 -If the <em>bar</em> is too high then the slope is too high; the
model over-predicts the higher observations and under-predicts the
lower observations.
</p>
</li>
<li>
<p>...2 -If the <em>bar</em> is too low then the slope is too low; the
model underpredicts the higher observations and overpredicts the
lower observations (analogous to regression to the mean).
</p>
</li>
<li>
<p>...3 -If the <em>bar</em> is too narrow then the predictions are too
variable.
</p>
</li>
</ul>
<p>The implementation in Robinson et al. (2005) required shifting so that
the predictor has 0 mean. This hack has been removed here so that the
basic graph object is a plot of the two variables being compared.  </p>


<h3>Value</h3>

<p>Run for its side effect of producing a lattice plot object.
</p>


<h3>Warning</h3>

<p>The accuracy of the output of this function is
contingent on the usual regression assumptions, which are not checked
here.  <em>Caveat emptor</em>! Consider using equiv.boot() for a
bootstrap-based solution. Transforming either variable will probably
complicate the analysis considerably.</p>


<h3>Acknowledgements</h3>

<p>Feedback from Mohammad Al-Ahmadi has been
very useful for this function.</p>


<h3>Note</h3>

<p>This version produces a regression-based TOST for each level of
the conditioning factor.  There may be an argument for pooling the
test across these levels, in which case some prepanel computations will be
helpful.
</p>
<p>The TOST requires only estimates and standard errors from the data.
Therefore the linear model used in the panel function can be replaced
by any model that will produce suitable estimates.  For example, in
applying this function to hierarchical data we have had success using
lme() instead.
</p>
<p>I'm not entirely convinced that all these lines on one image are a
good idea.  It's straightforward to remove some, or change the
colours. Recommendations for graphics that are visually cleaner are
welcome. </p>


<h3>Author(s)</h3>

<p> Andrew Robinson <a href="mailto:A.Robinson@ms.unimelb.edu.au">A.Robinson@ms.unimelb.edu.au</a></p>


<h3>References</h3>

<p>Robinson, A.P., R.A. Duursma, and J.D. Marshall. 2005. A
regression-based equivalence test for model validation: shifting the
burden of proof. Tree Physiology 25, 903-913. </p>


<h3>See Also</h3>

<p><code>tost.stat</code>, <code>xyplot</code>,
<code>equiv.boot</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
data(pref.4PG)
equivalence.xyplot(pref.4PG$stemvolinc ~ pref.4PG$volinc4PG,
                   alpha=0.05, b0.ii=0.25, b1.ii=0.25, add.smooth=TRUE, 
                   xlab=expression(paste("4PG decadal volume growth (", m^3,
                       ha^-1, decade^-1, ")", sep="")), 
                   ylab=expression(paste("Measured decadal volume growth (",
                       m^3, ha^-1, decade^-1, ")", sep="")))

data(pref.LAI)
equivalence.xyplot(pref.LAI$lai.pa ~ pref.LAI$lai.bl,
                   alpha=0.05, b0.ii=0.25, b1.ii=0.25,
                   xlab=expression(paste("LAI Beer-Lambert (", m^2, m^-2, ")",
                       sep="")), 
                   ylab=expression(paste("LAI Ceptometer (", m^2, m^-2, ")",
                       sep=""))) 


data(ufc)
ufc.ht &lt;- ufc[!is.na(ufc$Height),]
equivalence.xyplot(ufc.ht$Height.m ~ ufc.ht$Height.m.p,
                   alpha=0.05, b0.ii=0.1, b1.ii=0.2,
                   xlab="Predicted height (m)",
                   ylab="Measured height (m)")

equivalence.xyplot(ufc.ht$Height.m ~ ufc.ht$Height.m.p | ufc.ht$Species,
                   alpha=0.05, b0.ii=0.1, b1.ii=0.2,
                   xlab="Predicted height (m)",
                   ylab="Measured height (m)",
                   subset=ufc.ht$Species %in%
                        levels(ufc.ht$Species)[table(ufc.ht$Species)&gt;5])
</code></pre>


</div>