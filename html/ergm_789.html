<div class="container">

<table style="width: 100%;"><tr>
<td>summary_formula</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Dispatching a summary function based on the class of the LHS of a
formula.</h2>

<h3>Description</h3>

<p>The generic <code>summary_formula()</code> (note the underscore) expects a
formula argument and will attempt to identify the class of the LHS
of the formula and dispatch to the appropriate <code>summary_formula</code>
method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">summary_formula(object, ..., basis = NULL)

## S3 method for class 'ergm'
summary_formula(object, ..., basis = NULL)

## S3 method for class 'network.list'
summary_formula(object, response = NULL, ..., basis = eval_lhs.formula(object))

## S3 method for class 'network'
summary_formula(object, response = NULL, ..., basis = ergm.getnetwork(object))

## S3 method for class 'ergm_state'
summary_formula(object, ..., basis = NULL)

## S3 method for class 'matrix'
summary_formula(object, response = NULL, ..., basis = ergm.getnetwork(object))

## Default S3 method:
summary_formula(object, response = NULL, ..., basis = ergm.getnetwork(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A two-sided formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or used by methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis</code></td>
<td>
<p>Optional object of the same class as the LHS of the formula, substituted in place of the LHS.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>Either a character string, a formula, or <code>NULL</code> (the default), to specify the response attributes and whether the ERGM is binary or valued. Interpreted as follows: </p>

<dl>
<dt><code>NULL</code></dt>
<dd>
<p>Model simple presence or absence, via a binary ERGM.</p>
</dd>
<dt>character string</dt>
<dd>
<p>The name of the edge attribute whose value is to be modeled. Type of ERGM will be determined by whether the attribute is <code>logical</code> (<code>TRUE</code>/<code>FALSE</code>) for binary or <code>numeric</code> for valued.</p>
</dd>
<dt>a formula</dt>
<dd>
<p>must be of the form <code>NAME~EXPR|TYPE</code> (with <code>|</code> being literal). <code>EXPR</code> is evaluated in the formula's environment with the network's edge attributes accessible as variables. The optional <code>NAME</code> specifies the name of the edge attribute into which the results should be stored, with the default being a concise version of <code>EXPR</code>. Normally, the type of ERGM is determined by whether the result of evaluating <code>EXPR</code> is logical or numeric, but the optional <code>TYPE</code> can be used to override by specifying a scalar of the type involved (e.g., <code>TRUE</code> for binary and <code>1</code> for valued).</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of statistics measured on the network.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>summary_formula(ergm)</code>: an <code>ergm</code> fit method, extracting its model from the fit.
</p>
</li>
<li> <p><code>summary_formula(network.list)</code>: a method for a <code>network.list</code> on the LHS of the formula.
</p>
</li>
<li> <p><code>summary_formula(network)</code>: a method for a <code>network</code> on the LHS of the formula.
</p>
</li>
<li> <p><code>summary_formula(ergm_state)</code>: a method for the semi-internal <code>ergm_state</code> on the LHS of the formula.
</p>
</li>
<li> <p><code>summary_formula(matrix)</code>: a method for a <code>matrix</code> on the LHS of the formula.
</p>
</li>
<li> <p><code>summary_formula(default)</code>: a fallback method.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>ergm()</code>, <code>network()</code>, <code>ergmTerm</code>
</p>
<p><code>summary.ergm_model()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#
# Lets look at the Florentine marriage data
#
data(florentine)
#
# test the summary_formula function
#
summary(flomarriage ~ edges + kstar(2))
m &lt;- as.matrix(flomarriage)
summary(m ~ edges)  # twice as large as it should be
summary(m ~ edges, directed=FALSE) # Now it's correct

</code></pre>


</div>