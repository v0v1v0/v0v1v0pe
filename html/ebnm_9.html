<div class="container">

<table style="width: 100%;"><tr>
<td>ebnm_group</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solve the EBNM problem for grouped data</h2>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem for observations
belonging to distinct groups.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ebnm_group(
  x,
  s = 1,
  group,
  prior_family = "point_normal",
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and
missing standard errors are not allowed. Two prior families have
additional restrictions: when horseshoe priors are used, errors
must be homoskedastic; and since function
<code>deconv</code> in package <code>deconvolveR</code> takes
<code class="reqn">z</code>-scores, the "deconvolver" family requires that all standard errors
be equal to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A vector of character strings that gives the group to which each
observation belongs. It must have the same length as argument <code>x</code>. For
an example of usage, see Examples below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior_family</code></td>
<td>
<p>A named vector that specifies the prior family <code class="reqn">G</code>
for each group. If the same prior family is to be used for all groups, then
a character string may be used instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>A named list that specifies, for each group, the mode of the
respective prior <code class="reqn">g</code>, or <code>"estimate"</code> if the mode is to be
estimated from the data. If the mode is the same across groups, then a
scalar may be used instead. If all modes are to be estimated, then
<code>mode = "estimate"</code> may be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A named list that specifies, for each group, the scale
parameter(s) of the respective prior, or <code>"estimate"</code> if the scale
parameters are to be estimated from the data. If the scale parameter is the
same across groups, then a scalar may be used instead. If all scales are to
be estimated, then <code>scale = "estimate"</code> may be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g_init</code></td>
<td>
<p>The prior distributions <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the "true" <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. If
<code>g_init</code> is supplied, it should be a named list that specifies, for
each group, a prior of the appropriate class (<code>normalmix</code>
for normal, point-normal,
scale mixture of normals, and <code>deconvolveR</code> prior families, as well as
for the NPMLE; class <code>laplacemix</code> for
point-Laplace families; class <code>gammamix</code> for point-exponential
families; class <code>horseshoe</code> for horseshoe families; and class
<code>unimix</code> for <code>unimodal_</code> families).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters. When a <code>unimodal_</code> prior family is used,
these parameters are passed to function <code>ash</code> in package
<code>ashr</code>. Although it
does not call into <code>ashr</code>, the scale mixture of normals family accepts
parameter <code>gridmult</code> for purposes of comparison. When <code>gridmult</code>
is set, an <code>ashr</code>-style grid will be used instead of the default
<code>ebnm</code> grid. When the "deconvolver" family is used, additional
parameters are passed to function <code>deconv</code> in
package <code>deconvolveR</code>. Families of generalized binary priors take several
additional parameters; see <code>ebnm_generalized_binary</code>. In all
other cases, additional parameters are ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The EBNM model for grouped data, with observations <code class="reqn">x_j</code> belonging to
groups <code class="reqn">k = 1, ..., K</code>, is
</p>
<p style="text-align: center;"><code class="reqn">x_j | \theta_j, s_j \sim N(\theta_j, s_j^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_j \sim g_{k(j)} \in G_{k(j)}.</code>
</p>

<p>Solving the EBNM problem for grouped data is equivalent to solving a
separate EBNM problem for each group <code class="reqn">k = 1, ..., K</code>, with the optimal
log likelihood equal to the sum of the optimal log likelihoods for each
separate problem.
</p>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt>
<dd>
<p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt>
<dd>
<p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt>
<dd>
<p>The fitted prior <code class="reqn">\hat{g}</code> (an object of
class <code>normalmix</code>, <code>laplacemix</code>,
<code>gammamix</code>, <code>unimix</code>,
<code>tnormalmix</code>, or <code>horseshoe</code>).</p>
</dd>
<dt><code>log_likelihood</code></dt>
<dd>
<p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt>
<dd>
<p>A function that can be used to
produce samples from the posterior. For all prior families other
than the horseshoe, the sampler takes a single parameter
<code>nsamp</code>, the number of posterior samples to return per
observation. Since <code>ebnm_horseshoe</code> returns an MCMC sampler,
it additionally takes parameter <code>burn</code>, the number of burn-in
samples to discard.</p>
</dd>
</dl>
<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p><code>ebnm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">group &lt;- c(rep("small_sd", 100), rep("large_sd", 100))
theta &lt;- c(rnorm(100, sd = 1), rnorm(100, sd = 10))
s &lt;- 1
x &lt;- theta + rnorm(200, 0, s)

ebnm.group.res &lt;- ebnm_group(x, s, group)

# Use different prior families for each group:
ebnm.group.res &lt;- ebnm_group(
  x, s, group,
  prior_family = list(small_sd = "normal", large_sd = "normal_scale_mixture")
)

# Different modes and scales can be set similarly:
ebnm.group.res &lt;- ebnm_group(
  x, s, group,
  mode = list(small_sd = 0, large_sd = "estimate"),
  scale = list(small_sd = 1, large_sd = "estimate")
)

</code></pre>


</div>