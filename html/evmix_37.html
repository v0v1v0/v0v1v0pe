<div class="container">

<table style="width: 100%;"><tr>
<td>bckden</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Boundary Corrected Kernel Density Estimation Using a Variety of Approaches</h2>

<h3>Description</h3>

<p>Density, cumulative distribution function, quantile function and
random number generation for boundary corrected kernel density estimators
using a variety of approaches (and different kernels) with a constant
bandwidth <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dbckden(x, kerncentres, lambda = NULL, bw = NULL,
  kernel = "gaussian", bcmethod = "simple", proper = TRUE,
  nn = "jf96", offset = NULL, xmax = NULL, log = FALSE)

pbckden(q, kerncentres, lambda = NULL, bw = NULL,
  kernel = "gaussian", bcmethod = "simple", proper = TRUE,
  nn = "jf96", offset = NULL, xmax = NULL, lower.tail = TRUE)

qbckden(p, kerncentres, lambda = NULL, bw = NULL,
  kernel = "gaussian", bcmethod = "simple", proper = TRUE,
  nn = "jf96", offset = NULL, xmax = NULL, lower.tail = TRUE)

rbckden(n = 1, kerncentres, lambda = NULL, bw = NULL,
  kernel = "gaussian", bcmethod = "simple", proper = TRUE,
  nn = "jf96", offset = NULL, xmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>quantiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kerncentres</code></td>
<td>
<p>kernel centres (typically sample data vector or scalar)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>bandwidth for kernel (as half-width of kernel) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>bandwidth for kernel (as standard deviations of kernel) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>kernel name (<code>default = "gaussian"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bcmethod</code></td>
<td>
<p>boundary correction method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proper</code></td>
<td>
<p>logical, whether density is renormalised to integrate to unity (where needed)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn</code></td>
<td>
<p>non-negativity correction method (simple boundary correction only)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>offset added to kernel centres (logtrans only) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmax</code></td>
<td>
<p>upper bound on support (copula and beta kernels only) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical, if TRUE then log density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>quantiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>logical, if FALSE then upper tail probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>cumulative probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size (positive integer)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Boundary corrected kernel density estimation (BCKDE) with improved
bias properties near the boundary compared to standard KDE available in 
<code>kden</code> functions. The user chooses from a wide range
of boundary correction methods designed to cope with a lower bound at zero
and potentially also both upper and lower bounds.
</p>
<p>Some boundary correction methods require a secondary correction for
negative density estimates of which two methods are implemented. Further, some
methods don't necessarily give a density which integrates to one, so an option
is provided to renormalise to be proper.
</p>
<p>It assumes there is a lower bound at zero, so prior transformation of data is
required for a alternative lower bound (possibly including negation to allow
for an upper bound).
</p>
<p>The alternate bandwidth definitions are discussed in the
<code>kernels</code>, with the <code>lambda</code> as the default.
The <code>bw</code> specification is the same as used in the
<code>density</code> function.
</p>
<p>Certain boundary correction methods use the standard kernels which are defined
in the <code>kernels</code> help
documentation with the <code>"gaussian"</code> as the default choice.
</p>
<p>The quantile function is rather complicated as there is no closed form solution,
so is obtained by numerical approximation of the inverse cumulative distribution function
<code class="reqn">P(X \le q) = p</code> to find <code class="reqn">q</code>. The quantile function 
<code>qbckden</code> evaluates the KDE cumulative distribution
function over the range from <code>c(0, max(kerncentre) + lambda)</code>,
or <code>c(0, max(kerncentre) + 5*lambda)</code> for normal kernel. Outside of this
range the quantiles are set to <code>0</code> for lower tail and <code>Inf</code>
(or <code>xmax</code> where appropriate) for upper tail. A sequence of values
of length fifty times the number of kernels (upto a maximum of 1000) is first
calculated. Spline based interpolation using <code>splinefun</code>,
with default <code>monoH.FC</code> method, is then used to approximate the quantile
function. This is a similar approach to that taken
by Matt Wand in the <code>qkde</code> in the <code>ks</code> package.
</p>
<p>Unlike the standard KDE, there is no general rule-of-thumb bandwidth for all these
estimators, with only certain methods having a guideline in the literature, so none
have been implemented. Hence, a bandwidth must always be specified and you should
consider using <code>fbckden</code> function for cross-validation
MLE for bandwidth.
</p>
<p>Random number generation is slow as inversion sampling using the (numerically evaluated)
quantile function is implemented. Users may want to consider alternative approaches instead,
like rejection sampling.
</p>


<h3>Value</h3>

<p><code>dbckden</code> gives the density, 
<code>pbckden</code> gives the cumulative distribution function,
<code>qbckden</code> gives the quantile function and 
<code>rbckden</code> gives a random sample.
</p>


<h3>Boundary Correction Methods</h3>

<p>Renormalisation to a proper density is assumed by default <code>proper=TRUE</code>.
This correction is needed for <code>bcmethod="renorm"</code>, <code>"simple"</code>,
<code>"beta1"</code>, <code>"beta2"</code>, <code>"gamma1"</code> and <code>"gamma2"</code> which
all require numerical integration. Renormalisation will not be carried out
for other methods, even when <code>proper=TRUE</code>.
</p>
<p>Non-negativity correction is only relevant for the <code>bcmethod="simple"</code> approach.
The Jones and Foster (1996) method is applied <code>nn="jf96"</code> by default. This method
can occassionally give an extra boundary bias for certain populations (e.g. Gamma(2, 1)),
see paper for details. Non-negative values can simply be zeroed (<code>nn="zero"</code>).
Renormalisation should always be applied after non-negativity correction. Non-negativity
correction will not be carried out for other methods, even when requested by user.
</p>
<p>The non-negative correction is applied before renormalisation, when both requested. 
</p>
<p>The boundary correction methods implemented are listed below. The first set can use
any type of kernel (see <code>kernels</code> help
documentation):
</p>
<p><code>bcmethod="simple"</code> is the default and applies the simple boundary correction method
in equation (3.4) of Jones (1993) and is equivalent to the kernel weighted local linear
fitting at the boundary. Renormalisation and non-negativity correction may be required.
</p>
<p><code>bcmethod="cutnorm"</code> applies cut and normalisation method of
Gasser and Muller (1979), where the kernels themselves are individually truncated at
the boundary and renormalised to unity.
</p>
<p><code>bcmethod="renorm"</code> applies first order correction method discussed in
Diggle (1985), where the kernel density estimate is locally renormalised near boundary.
Renormalisation may be required.
</p>
<p><code>bcmethod="reflect"</code> applies reflection method of Boneva, Kendall and Stefanov
(1971) which is equivalent to the dataset being supplemented by the same dataset negated. 
This method implicitly assumes f'(0)=0, so can cause extra artefacts at the boundary. 
</p>
<p><code>bcmethod="logtrans"</code> applies KDE on the log-scale and then back-transforms (with
explicit normalisation) following Marron and Ruppert (1992). This is the approach
implemented in the <code>ks</code> package. As the KDE is applied on
the log scale, the effective bandwidth on the original scale is non-constant. The
<code>offset</code> option is only used for this method and is commonly used to offset
zero kernel centres in log transform to prevent <code>log(0)</code>.
</p>
<p>All the following boundary correction methods do not use kernels in their
usual sense, so ignore the <code>kernel</code> input:
</p>
<p><code>bcmethod="beta1"</code> and <code>"beta2"</code> uses the beta and modified beta kernels
of Chen (1999) respectively. The <code>xmax</code> rescales the beta kernels to be
defined on the support [0, xmax] rather than unscaled [0, 1]. Renormalisation
will be required.
</p>
<p><code>bcmethod="gamma1"</code> and <code>"gamma2"</code> uses the gamma and modified gamma kernels
of Chen (2000) respectively. Renormalisation will be required.
</p>
<p><code>bcmethod="copula"</code> uses the bivariate normal copula based kernesl of 
Jones and Henderson (2007). As with the <code>bcmethod="beta1"</code>  and <code>"beta2"</code>
methods the <code>xmax</code> rescales the copula kernels to be defined on the support [0, xmax]
rather than [0, 1]. In this case the bandwidth is defined as <code class="reqn">lambda=1-\rho^2</code>,
so the bandwidth is limited to <code class="reqn">(0, 1)</code>.
</p>


<h3>Warning</h3>

<p>The <code>"simple"</code>, <code>"renorm"</code>, <code>"beta1"</code>, <code>"beta2"</code>, <code>"gamma1"</code> 
and <code>"gamma2"</code> boundary correction methods may require renormalisation using
numerical integration which can be very slow. In particular, the numerical integration
is extremely slow for the <code>kernel="uniform"</code>, due to the adaptive quadrature in
the <code>integrate</code> function
being particularly slow for functions with step-like behaviour.
</p>


<h3>Acknowledgments</h3>

<p>Based on code
by Anna MacDonald produced for MATLAB.
</p>


<h3>Note</h3>

<p>Unlike most of the other extreme value mixture model functions the 
<code>bckden</code> functions have not been vectorised as
this is not appropriate. The main inputs (<code>x</code>, <code>p</code> or <code>q</code>)
must be either a scalar or a vector, which also define the output length.
</p>
<p>The kernel centres <code>kerncentres</code> can either be a single datapoint or a vector
of data. The kernel centres (<code>kerncentres</code>) and locations to evaluate density (<code>x</code>)
and cumulative distribution function (<code>q</code>) would usually be different.
</p>
<p>Default values are provided for all inputs, except for the fundamentals 
<code>lambda</code>, <code>kerncentres</code>, <code>x</code>, <code>q</code> and <code>p</code>.
The default sample size for <code>rbckden</code> is 1.
</p>
<p>The <code>xmax</code> option is only relevant for the beta and copula methods, so a
warning is produced if this is not <code>NULL</code> for in other methods.
The <code>offset</code> option is only relevant for the <code>"logtrans"</code> method, so a
warning is produced if this is not <code>NULL</code> for in other methods.
</p>
<p>Missing (<code>NA</code>) and Not-a-Number (<code>NaN</code>) values in <code>x</code>,
<code>p</code> and <code>q</code> are passed through as is and infinite values are set to
<code>NA</code>. None of these are not permitted for the parameters.
</p>
<p>Error checking of the inputs (e.g. invalid probabilities) is carried out and
will either stop or give warning message as appropriate.
</p>


<h3>Author(s)</h3>

<p>Yang Hu and Carl Scarrott <a href="mailto:carl.scarrott@canterbury.ac.nz">carl.scarrott@canterbury.ac.nz</a>.
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Kernel_density_estimation">http://en.wikipedia.org/wiki/Kernel_density_estimation</a>
</p>
<p><a href="http://en.wikipedia.org/wiki/Cross-validation_(statistics)">http://en.wikipedia.org/wiki/Cross-validation_(statistics)</a>
</p>
<p>Scarrott, C.J. and MacDonald, A. (2012). A review of extreme value
threshold estimation and uncertainty quantification. REVSTAT - Statistical
Journal 10(1), 33-59. Available from <a href="http://www.ine.pt/revstat/pdf/rs120102.pdf">http://www.ine.pt/revstat/pdf/rs120102.pdf</a>
</p>
<p>Bowman, A.W. (1984). An alternative method of cross-validation for the smoothing of
density estimates. Biometrika 71(2), 353-360.
</p>
<p>Duin, R.P.W. (1976). On the choice of smoothing parameters for Parzen estimators of
probability density functions. IEEE Transactions on Computers C25(11), 1175-1179.
</p>
<p>MacDonald, A., Scarrott, C.J., Lee, D., Darlow, B., Reale, M. and Russell, G. (2011).
A flexible extreme value mixture model. Computational Statistics and Data Analysis
55(6), 2137-2157.
</p>
<p>Chen, S.X. (1999). Beta kernel estimators for density functions. Computational Statistics
and Data Analysis 31, 1310-45.
</p>
<p>Gasser, T. and Muller, H. (1979). Kernel estimation of regression functions. In "Lecture Notes
in Mathematics 757, edited by Gasser and Rosenblatt, Springer.
</p>
<p>Chen, S.X. (2000). Probability density function estimation using gamma kernels.
Annals of the Institute of Statisical Mathematics 52(3), 471-480.
</p>
<p>Boneva, L.I., Kendall, D.G. and Stefanov, I. (1971). Spline transformations: Three new
diagnostic aids for the statistical data analyst (with discussion). Journal of the Royal
Statistical Society B, 33, 1-70.
</p>
<p>Diggle, P.J. (1985). A kernel method for smoothing point process data. Applied Statistics
34, 138-147.
</p>
<p>Marron, J.S. and Ruppert, D. (1994) Transformations to reduce boundary bias in kernel
density estimation, Journal of the Royal Statistical Society. Series B 56(4), 653-671.
</p>
<p>Jones, M.C. and Henderson, D.A. (2007). Kernel-type density estimation on the unit
interval. Biometrika 94(4), 977-984.
</p>


<h3>See Also</h3>

<p><code>kernels</code>, <code>kfun</code>,
<code>density</code>, <code>bw.nrd0</code>
and <code>dkde</code> in <code>ks</code> package.
</p>
<p>Other kden: <code>fbckden</code>, <code>fgkgcon</code>,
<code>fgkg</code>, <code>fkdengpdcon</code>,
<code>fkdengpd</code>, <code>fkden</code>,
<code>kdengpdcon</code>, <code>kdengpd</code>,
<code>kden</code>
</p>
<p>Other bckden: <code>bckdengpdcon</code>,
<code>bckdengpd</code>, <code>fbckdengpdcon</code>,
<code>fbckdengpd</code>, <code>fbckden</code>,
<code>fkden</code>, <code>kden</code>
</p>
<p>Other bckdengpd: <code>bckdengpdcon</code>,
<code>bckdengpd</code>, <code>fbckdengpdcon</code>,
<code>fbckdengpd</code>, <code>fbckden</code>,
<code>fkdengpd</code>, <code>gkg</code>,
<code>kdengpd</code>, <code>kden</code>
</p>
<p>Other bckdengpdcon: <code>bckdengpdcon</code>,
<code>bckdengpd</code>, <code>fbckdengpdcon</code>,
<code>fbckdengpd</code>, <code>fbckden</code>,
<code>fkdengpdcon</code>, <code>gkgcon</code>,
<code>kdengpdcon</code>
</p>
<p>Other fbckden: <code>fbckden</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
set.seed(1)
par(mfrow = c(1, 1))

n=100
x = rgamma(n, shape = 1, scale = 2)
xx = seq(-0.5, 12, 0.01)
plot(xx, dgamma(xx, shape = 1, scale = 2), type = "l")
rug(x)
lines(xx, dbckden(xx, x, lambda = 1), lwd = 2, col = "red")
lines(density(x), lty = 2, lwd = 2, col = "green")
legend("topright", c("True Density", "Simple boundary correction",
"KDE using density function", "Boundary Corrected Kernels"),
lty = c(1, 1, 2, 1), lwd = c(1, 2, 2, 1), col = c("black", "red", "green", "blue"))

n=100
x = rbeta(n, shape1 = 3, shape2 = 2)*5
xx = seq(-0.5, 5.5, 0.01)
plot(xx, dbeta(xx/5, shape1 = 3, shape2 = 2)/5, type = "l", ylim = c(0, 0.8))
rug(x)
lines(xx, dbckden(xx, x, lambda = 0.1, bcmethod = "beta2", proper = TRUE, xmax = 5),
  lwd = 2, col = "red")
lines(density(x), lty = 2, lwd = 2, col = "green")
legend("topright", c("True Density", "Modified Beta KDE Using evmix",
  "KDE using density function"),
lty = c(1, 1, 2), lwd = c(1, 2, 2), col = c("black", "red", "green"))

# Demonstrate renormalisation (usually small difference)
n=1000
x = rgamma(n, shape = 1, scale = 2)
xx = seq(-0.5, 15, 0.01)
plot(xx, dgamma(xx, shape = 1, scale = 2), type = "l")
rug(x)
lines(xx, dbckden(xx, x, lambda = 0.5, bcmethod = "simple", proper = TRUE),
  lwd = 2, col = "purple")
lines(xx, dbckden(xx, x, lambda = 0.5, bcmethod = "simple", proper = FALSE),
  lwd = 2, col = "red", lty = 2)
legend("topright", c("True Density", "Simple BC with renomalisation", 
"Simple BC without renomalisation"),
lty = 1, lwd = c(1, 2, 2), col = c("black", "purple", "red"))

## End(Not run)

</code></pre>


</div>