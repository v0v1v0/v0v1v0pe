<div class="container">

<table style="width: 100%;"><tr>
<td>continuous</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate continuous domain excursion and credible contour sets</h2>

<h3>Description</h3>

<p>Calculates continuous domain excursion and credible contour sets
</p>


<h3>Usage</h3>

<pre><code class="language-R">continuous(
  ex,
  geometry,
  alpha,
  method = c("log", "linear", "step"),
  output = c("sp", "fm", "inla"),
  subdivisions = 1,
  calc.credible = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ex</code></td>
<td>
<p>An <code>excurobj</code> object generated by a call to <code>excursions</code>
or <code>contourmap</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geometry</code></td>
<td>
<p>Specification of the lattice or triangulation geometry of the input.
One of <code>list(x, y)</code>, <code>list(loc, dims)</code>, <code>fm_lattice_2d</code>,
<code>inla.mesh.lattice</code>, <code>fm_mesh_2d</code>, or
<code>inla.mesh</code>, where <code>x</code> and <code>y</code> are vectors, <code>loc</code> is
a two-column matrix of coordinates, and <code>dims</code> is the lattice size vector.
The first three versions are all treated topologically as lattices, and the
lattice boxes are assumed convex.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The target error probability.  A warning is given if it is detected
that the information <code>ex</code> isn't sufficient for the given <code>alpha</code>.
Defaults to the value used when calculating <code>ex</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The spatial probability interpolation transformation method to use.
One of <code>log</code>, <code>linear</code>, or <code>step</code>.  For <code>log</code>, the probabilities
are interpolated linearly in the transformed scale. For <code>step</code>, a conservative
step function is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>Specifies what type of object should be generated. <code>sp</code> gives a
<code>SpatialPolygons</code> object, and <code>fm</code> or <code>inla</code> gives a <code>fm_segm</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subdivisions</code></td>
<td>
<p>The number of mesh triangle subdivisions to perform for the
interpolation of the excursions or contour function. 0 is no subdivision.
The setting has a small effect on the evaluation of <code>P0</code> for the <code>log</code>
method (higher values giving higher accuracy) but the main effect is on the visual
appearance of the interpolation. Default=1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calc.credible</code></td>
<td>
<p>Logical, if TRUE (default), calculate credible contour region
objects in addition to avoidance sets.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p><code>SpatialPolygons</code> or <code>inla.mesh.segment</code> object. The subsets
are tagged, so that credible regions are tagged <code>"-1"</code>, and regions between
levels are tagged <code>as.character(0:nlevels)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>F</code></td>
<td>
<p>Interpolated F function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>Contour and inter-level set indices for the interpolation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>F.geometry</code></td>
<td>
<p>Mesh geometry for the interpolation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P0</code></td>
<td>
<p>P0 measure based on interpolated F function (only for <code>contourmap</code>
input).</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin, D. and Lindgren, F. (2017) <em>Quantifying the uncertainty of contour maps</em>, Journal of Computational and Graphical Statistics, vol 26, no 3, pp 513-524.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>, Journal of Statistical Software, vol 86, no 1, pp 1-20.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
if (require("fmesher")) {
  # Generate mesh and SPDE model
  n.lattice &lt;- 10 # Increase for more interesting, but slower, examples
  x &lt;- seq(from = 0, to = 10, length.out = n.lattice)
  lattice &lt;- fm_lattice_2d(x = x, y = x)
  mesh &lt;- fm_rcdt_2d_inla(lattice = lattice, extend = FALSE, refine = FALSE)

  # Generate an artificial sample
  sigma2.e &lt;- 0.1
  n.obs &lt;- 100
  obs.loc &lt;- cbind(
    runif(n.obs) * diff(range(x)) + min(x),
    runif(n.obs) * diff(range(x)) + min(x)
  )
  Q &lt;- fm_matern_precision(mesh, alpha = 2, rho = 3, sigma = 1)
  x &lt;- fm_sample(n = 1, Q = Q)
  A &lt;- fm_basis(mesh, loc = obs.loc)
  Y &lt;- as.vector(A %*% x + rnorm(n.obs) * sqrt(sigma2.e))

  ## Calculate posterior
  Q.post &lt;- (Q + (t(A) %*% A) / sigma2.e)
  mu.post &lt;- as.vector(solve(Q.post, (t(A) %*% Y) / sigma2.e))
  vars.post &lt;- excursions.variances(chol(Q.post))

  ## Calculate contour map with two levels
  map &lt;- contourmap(
    n.levels = 2, mu = mu.post, Q = Q.post,
    alpha = 0.1, F.limit = 0.1, max.threads = 1
  )

  ## Calculate the continuous representation
  sets &lt;- continuous(map, mesh, alpha = 0.1)

  ## Plot the results
  reo &lt;- mesh$idx$lattice
  cols &lt;- contourmap.colors(map,
    col = heat.colors(100, 1, rev = TRUE),
    credible.col = grey(0.5, 1)
  )
  names(cols) &lt;- as.character(-1:2)

  par(mfrow = c(2, 2))
  image(matrix(mu.post[reo], n.lattice, n.lattice),
    main = "mean", axes = FALSE, asp = 1
  )
  image(matrix(sqrt(vars.post[reo]), n.lattice, n.lattice),
    main = "sd", axes = FALSE, asp = 1
  )
  image(matrix(map$M[reo], n.lattice, n.lattice),
    col = cols, axes = FALSE, asp = 1
  )
  idx.M &lt;- setdiff(names(sets$M), "-1")
  plot(sets$M[idx.M], col = cols[idx.M])
}

## End(Not run)

</code></pre>


</div>