<div class="container">

<table style="width: 100%;"><tr>
<td>xtibber</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Test-Inversion Bootstrap for Extreme-Value Analysis
</h2>

<h3>Description</h3>

<p>Test-inversion bootstrap (TIB) for fevd class objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">xtibber(x, type = c("return.level", "parameter"), which.one,
	tib.method = c("interp", "rm"), nuisance = "shape", B,
	test.pars, rsize, block.length = 1, shuffle = NULL,
	replace = TRUE, alpha = 0.05, qcov = NULL,
	qcov.base = NULL, stud = FALSE, step.size, tol = 1e-04,
	max.iter = 1000, keep.iters = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>List object of class “fevd”.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>character string stating whether to calculate TIB intervals for a return level or a parameter as this funciton will only calculate an interval for a single parameter/return level at a time.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.one</code></td>
<td>

<p>number or character stating which return level or which parameter to find CIs for.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tib.method</code></td>
<td>

<p>character stating whether to estimate the TIB interval by interpolating from a series of pre-determined values of the nuisance parameter or to use the Robbins-Monroe (RM) method.  See the help file for <code>tibber</code> from the distillery package for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nuisance</code></td>
<td>

<p>character naming the nuisance parameter.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B, rsize, block.length, shuffle, replace</code></td>
<td>

<p>See the help file for <code>booter</code> from the distillery package for more information on these arguments.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.pars</code></td>
<td>

<p>numeric vector giving the sequence of nuisance parameter values for the interpolation method, or a numeric vector of length two giving the starting values for the RM method.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>numeric between zero and one giving the desired confidence level.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qcov</code></td>
<td>
<p>numeric matrix with rows the same length as <code>q</code> and columns equal to the number of parameters (+ 1 for the threshold, if a POT model).  This gives any covariate values for a nonstationary model.  If NULL, and model is non-stationary, only the intercept terms for modeled parameters are used, and if a non-constant threshold, only the first threshold value is used.  Not used if model is stationary. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qcov.base</code></td>
<td>
<p>numeric matrix analogous to <code>qcov</code>.  When provided, the function returns the difference in return levels between the level for the covariates in <code>qcov</code> and the level for covariates in <code>qcov.base</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stud</code></td>
<td>

<p>logical if TRUE will calculate Studentized intervals (generally not profitable with the TIB method).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step.size</code></td>
<td>

<p>Used with the RM method only.  Numeric giving the size of increments to use in the root-finding algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>Used with the RM method only.  Numeric stating how close to the desired level of confidence is satisfactory.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>

<p>numeric giving the maximum number of iterations for the root-finding algorithm before giving up.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.iters</code></td>
<td>

<p>logical, should all of the values in the root-finding search be kept?  Needed if a plot will be made.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>logical, if TRUE will print progress information to the screen.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>optional arguments to <code>nlminb</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function provides a wrapper to the <code>tibber</code> function from distillery for “fevd” objects.
</p>


<h3>Value</h3>

<p>See the help file for tibber for more information on the value
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>References</h3>

<p>Gilleland, E. (2020) Bootstrap methods for statistical inference. Part I: Comparative forecast verification for continuous variables. <em>Journal of Atmospheric and Oceanic Technology</em>, <b>37</b> (11), 2117 - 2134, doi: 10.1175/JTECH-D-20-0069.1.
</p>
<p>Gilleland, E. (2020) Bootstrap methods for statistical inference. Part II: Extreme-value analysis. <em>Journal of Atmospheric and Oceanic Technology</em>, <b>37</b> (11), 2135 - 2144, doi: 10.1175/JTECH-D-20-0070.1.
</p>


<h3>See Also</h3>

<p><code>fevd</code>, <code>tibber</code>, <code>booter</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data("ftcanmax")
fit &lt;- fevd( Prec, data = ftcanmax )

tbfit &lt;- xtibber( fit, which.one = 100, B = 500,
		 test.pars = seq(-0.01,0.2,,100), verbose = TRUE )

tbfit

plot( tbfit )


## End(Not run)
</code></pre>


</div>