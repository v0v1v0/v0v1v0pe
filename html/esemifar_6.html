<div class="container">

<table style="width: 100%;"><tr>
<td>dsmoothlm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Data-driven Local Polynomial for the Trend's Derivatives in Equidistant Time
Series</h2>

<h3>Description</h3>

<p>This function runs through an iterative process in order to find the
optimal bandwidth for the nonparametric estimation of the first or second
derivative of the trend in an equidistant time series (with long-memory
errors) and subsequently employs the obtained bandwidth via local
polynomial regression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dsmoothlm(
  y,
  d = c(1, 2),
  pmin = c(0, 1, 2, 3, 4, 5),
  pmax = c(0, 1, 2, 3, 4, 5),
  qmin = c(0, 1, 2, 3, 4, 5),
  qmax = c(0, 1, 2, 3, 4, 5),
  mu = c(0, 1, 2, 3),
  mu.p = c(0, 1, 2, 3),
  pp = c(1, 3),
  bStart.p = 0.15,
  InfR.p = c("Opt", "Nai", "Var")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a numeric vector that contains the time series ordered from past to
present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>an integer <code>1</code> or <code>2</code> that defines the order of
derivative; the default is <code>d = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function and thus defines the kernel
function that will be used within the local polynomial regression; is set to
<code>1</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.p</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function for the iterative process to
obtain initial estimates for <code class="reqn">c_f</code>, <code class="reqn">d</code> and <code class="reqn">b_0</code>; is set to
<code>1</code> by default.
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Number</strong> </td>
<td style="text-align: left;"> <strong>Kernel</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>0</code> </td>
<td style="text-align: left;"> Uniform Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>1</code> </td>
<td style="text-align: left;"> Epanechnikov Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>2</code> </td>
<td style="text-align: left;"> Bisquare Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>3</code> </td>
<td style="text-align: left;"> Triweight Kernel
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pp</code></td>
<td>
<p>an integer <code>1</code> (local linear regression) or <code>3</code> (local
cubic regression) that indicates the order of polynomial upon which
<code class="reqn">c_f</code>, <code class="reqn">d</code> and <code class="reqn">b_0</code> will be calculated by
<code>tsmoothlm</code>; the default is <code>pp = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bStart.p</code></td>
<td>
<p>a numeric object that indicates the starting value of the
bandwidth for the iterative process to obtain initial estimates for <code class="reqn">c_f</code>,
<code class="reqn">d</code> and <code class="reqn">b_0</code>; should be <code class="reqn">&gt; 0</code>; is set to <code>0.15</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>InfR.p</code></td>
<td>
<p>a character object that represents the inflation
rate in the form <code class="reqn">h_d = h^a</code> of the bandwidth for the iterative process
to obtain initial estimates for <code class="reqn">c_f</code>,
<code class="reqn">d</code> and <code class="reqn">b_0</code>; is set to <code>"Opt"</code> by default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The trend is estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series, <code class="reqn">x_t</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function and <code class="reqn">\epsilon_t</code> are stationary errors with
<code class="reqn">E(\epsilon_t) = 0</code> and is assumed to follow a FARIMA(<code class="reqn">p, d, q</code>)
model (see also Beran and Feng, 2002).
</p>
<p>The iterative-plug-in (IPI) algorithm, which numerically minimizes the
Asymptotic Mean Squared Error (AMISE), is based on the proposal of Beran
and Feng (2002a).
</p>
<p>The variance factor <code class="reqn">c_f</code>, the long memory parameter <code class="reqn">d</code> and the
starting bandwidth <code class="reqn">b0</code> are first obtained from a pilot-estimation of
the time series' nonparametric trend (<code class="reqn">\nu = 0</code>) with polynomial order
<code class="reqn">p_p</code>. The estimate is then plugged into the iterative procedure for
estimating the first or second derivative (<code class="reqn">\nu = 1</code> or <code class="reqn">\nu = 2</code>).
For further details on the asymptotic theory or the algorithm, we refer the
user to Letmathe, Beran and Feng (2023).
</p>
<p>The function itself is applicable in the following way: Based on a data input
<code>y</code>, an order of polynomial <code>pp</code> for the variance factor estimation
procedure, a starting value for the relative bandwidth <code>bStart.p</code> in the
variance factor estimation procedure and a kernel function defined by the
smoothness parameter <code>mu</code>, an optimal bandwidth is numerically calculated
for the trend's derivative of order <code>d</code>. In fact, aside from the input
vector <code>y</code>, every argument has a default setting that can be adjusted for
the individual case. However, it is recommended to initially use the default
values for the estimation of the
first derivative and adjust the argument <code>d</code> to <code>d = 2</code> for the
estimation of the second derivative.
The initial bandwidth does not affect the resulting optimal bandwidth in
theory. However in practice, local minima of the AMISE can influence the
results. For more specific information on the input arguments consult the
section <em>Arguments</em>.
</p>
<p>After the bandwidth estimation, the nonparametric derivative of the series
is calculated with respect to the obtained optimal bandwidth by means of a
local polynomial regression. The output object is then a list that contains,
among other components, the original time series, the estimates of the
derivative and the estimated optimal bandwidth.
</p>
<p>The default print method for this function delivers key numbers such as
the iteration steps and the generated optimal bandwidth rounded to the fourth
decimal. The exact numbers and results such as the estimated nonparametric
trend series are saved within the output object and can be addressed via the
<code>$</code> sign.
</p>


<h3>Value</h3>

<p>The function returns a list with different components:
</p>

<dl>
<dt>b0</dt>
<dd>
<p>the optimal bandwidth chosen by the IPI-algorithm.</p>
</dd>
<dt>bStart.p</dt>
<dd>
<p>the starting bandwidth for the nonparametric trend estimation
that leads to the initial estimates; input argument.</p>
</dd>
<dt>cf0</dt>
<dd>
<p>the estimated variance factor.</p>
</dd>
<dt>InfR.p</dt>
<dd>
<p>the inflation rate setting.</p>
</dd>
<dt>iterations</dt>
<dd>
<p>the bandwidths of the single iterations steps</p>
</dd>
<dt>mu.p</dt>
<dd>
<p>the smoothness parameter of the second order kernel; input
argument.</p>
</dd>
<dt>n</dt>
<dd>
<p>the number of observations.</p>
</dd>
<dt>niterations</dt>
<dd>
<p>the total number of iterations until convergence.</p>
</dd>
<dt>orig</dt>
<dd>
<p>the original input series; input argument.</p>
</dd>
<dt>p</dt>
<dd>
<p>the order of polynomial for the local polynomial
regression used within derivative estimation procedure.</p>
</dd>
<dt>pp</dt>
<dd>
<p>the order of polynomial for the local polynomial
regression used in the pilot estimation; input argument.</p>
</dd>
<dt>v</dt>
<dd>
<p>the considered order of the trend's derivative; input argument
<code>d</code>.</p>
</dd>
<dt>ws</dt>
<dd>
<p>the weighting system matrix used within the local polynomial
regression; this matrix is a condensed version of a complete weighting system
matrix; in each row of <code>ws</code>, the weights for conducting the smoothing
procedure at a specific observation time point can be found; the first
<code class="reqn">[nb + 0.5]</code> rows, where <code class="reqn">n</code> corresponds to the number of
observations, <code class="reqn">b</code> is the bandwidth considered for smoothing and
<code class="reqn">[.]</code> denotes the integer part, contain the weights at the
<code class="reqn">[nb + 0.5]</code> left-hand boundary points; the weights in row
<code class="reqn">[nb + 0.5] + 1</code> are representative for the estimation at all
interior points and the remaining rows contain the weights for the right-hand
boundary points; each row has exactly <code class="reqn">2[nb + 0.5] + 1</code> elements,
more specifically the weights for observations of the nearest
<code class="reqn">2[nb + 0.5] + 1</code> time points; moreover, the weights are normalized,
i.e. the weights are obtained under consideration of the time points
<code class="reqn">x_t = t/n</code>, where <code class="reqn">t = 1, 2, ..., n</code>.</p>
</dd>
<dt>ye</dt>
<dd>
<p>the nonparametric estimates of the derivative.</p>
</dd>
</dl>
<h3>Author(s)</h3>


<ul>
<li>
<p> Yuanhua Feng (Department of Economics, Paderborn University), <br>
Author of the Algorithms <br>
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li>
<p> Sebastian Letmathe (Scientific Employee) (Department of Economics,
Paderborn
University), <br>
Package Creator and Maintainer
</p>
</li>
<li>
<p> Dominik Schulz (Scientific Employee) (Department of Economics, Paderborn
University), <br>
Author
</p>
</li>
</ul>
<h3>References</h3>

<p>Letmathe, S., Beran, J. and Feng, Y. (2023). An extended exponential SEMIFAR
model with application in R. Communications in Statistics - Theory and Methods:
1-13.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Logarithm of test data
test_data &lt;- gdpG7
y &lt;- log(test_data$gdp)
n &lt;- length(y)
t &lt;- seq(from = 1962, to = 2020, length.out = n)

# Applied dsmooth function for the trend's first derivative
result_d &lt;- dsmoothlm(y, d = 1, pp = 1, pmax = 1, qmax = 1, InfR.p = "Opt")
estim &lt;- result_d$ye

# Plot of the results
plot(t, estim, xlab = "Year", ylab = "First derivative", type = "l",
 main = paste0("Estimated first derivative of the trend for log-quarterly ",
 "G7-GDP, Q1 1962 - Q4 2019"), cex.axis = 0.8, cex.main = 0.8,
 cex.lab = 0.8, bty = "n")

# Print result
result_d

# The main function "dsmoothlm"------------------------------------------
</code></pre>


</div>