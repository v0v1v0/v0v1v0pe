<div class="container">

<table style="width: 100%;"><tr>
<td>ecr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Interface to ecr similar to the optim function.</h2>

<h3>Description</h3>

<p>The most flexible way to setup evolutionary algorithms with ecr is by
explicitely writing the evolutionary loop utilizing various ecr utlity functions.
However, in everyday life R users frequently need to optimize a single-objective R function.
The <code>ecr</code> function thus provides a more R like interface for single
objective optimization similar to the interface of the <code>optim</code>
function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ecr(
  fitness.fun,
  minimize = NULL,
  n.objectives = NULL,
  n.dim = NULL,
  lower = NULL,
  upper = NULL,
  n.bits,
  representation,
  mu,
  lambda,
  perm = NULL,
  p.recomb = 0.7,
  p.mut = 0.3,
  survival.strategy = "plus",
  n.elite = 0L,
  log.stats = list(fitness = list("min", "mean", "max")),
  log.pop = FALSE,
  monitor = NULL,
  initial.solutions = NULL,
  parent.selector = NULL,
  survival.selector = NULL,
  mutator = NULL,
  recombinator = NULL,
  terminators = list(stopOnIters(100L)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fitness.fun</code></td>
<td>
<p>[<code>function</code>]<br>
The fitness function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minimize</code></td>
<td>
<p>[<code>logical(n.objectives)</code>]<br>
Logical vector with ith entry <code>TRUE</code> if the ith objective of <code>fitness.fun</code>
shall be minimized. If a single logical is passed, it is assumed to be valid
for each objective.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Number of objectives of <code>obj.fun</code>.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.dim</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Dimension of the decision space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>[<code>numeric</code>]<br>
Vector of minimal values for each parameter of the decision space in case
of float or permutation encoding.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>[<code>numeric</code>]<br>
Vector of maximal values for each parameter of the decision space in case
of float or permutation encoding.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.bits</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Number of bits to use for binary representation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>representation</code></td>
<td>
<p>[<code>character(1)</code>]<br>
Genotype representation of the parameters. Available are “binary”,
“float”, “permutation” and “custom”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Number of individuals in the population.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Number of individuals generated in each generation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perm</code></td>
<td>
<p>[<code>integer(1)</code> | <code>vector</code>]<br>
Either a single integer number. In this case the set is assumed to be <code>1:perm</code>.
Alternatively, a set, i.e., a vector of elements can be passed which should form each
individual.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.recomb</code></td>
<td>
<p>[<code>numeric(1)</code>]<br>
Probability of two parents to perform crossover.
Default is 0.7.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.mut</code></td>
<td>
<p>[<code>numeric(1)</code>]<br>
The probability that the mutation operator will be applied to a child. 
Refers only to the application of the mutation operator, not to the 
probability of mutating individual genes of the respective child.
Default is 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>survival.strategy</code></td>
<td>
<p>[<code>character(1)</code>]<br>
Determines the survival strategy used by the EA. Possible are “plus” for
a classical (mu + lambda) strategy and “comma” for (mu, lambda).
Default is “plus”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.elite</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Number of fittest individuals of the current generation that shall be copied to the
next generation without changing. Keep in mind, that the algorithm
does not care about this option if the <code>survival.strategy</code> is set to 'plus'.
Default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.stats</code></td>
<td>
<p>[<code>list</code>]<br>
(Named) list of scalar functions to compute statistics on the fitness values
in each generation. See <code>initLogger</code> for more information.
Default is to log fitness minimum, mean and maximum values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.pop</code></td>
<td>
<p>[<code>logical(1)</code>]<br>
Shall the entire population be saved in each generation?
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monitor</code></td>
<td>
<p>[<code>function</code>]<br>
Monitoring function.
Default is <code>NULL</code>, i.e. no monitoring.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.solutions</code></td>
<td>
<p>[<code>list</code>]<br>
List of individuals which should be placed in the initial population.
If the number of passed individuals
is lower than <code>mu</code>, the population will be filled up
by individuals generated by the corresponding generator.
Default is <code>NULL</code>, i.e., the entire population is generated by the
population generator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parent.selector</code></td>
<td>
<p>[<code>ecr_selector</code>]<br>
Selection operator which implements a procedure to copy individuals from a
given population to the mating pool, i. e., allow them to become parents.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>survival.selector</code></td>
<td>
<p>[<code>ecr_selector</code>]<br>
Selection operator which implements a procedurce to extract individuals from
a given set, which should survive and set up the next generation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutator</code></td>
<td>
<p>[<code>ecr_mutator</code>]<br>
Mutation operator of type <code>ecr_mutator</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recombinator</code></td>
<td>
<p>[<code>ecr_recombinator</code>]<br>
Recombination operator of type <code>ecr_recombinator</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminators</code></td>
<td>
<p>[<code>list</code>]<br>
List of stopping conditions of type “ecr_terminator”.
Default is to stop after 100 iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>[any]<br>
Further arguments passed down to <code>fitness.fun</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>[<code>ecr_result</code>]
</p>


<h3>Examples</h3>

<pre><code class="language-R">fn = function(x) {
   sum(x^2)
}
lower = c(-5, -5); upper = c(5, 5)
res = ecr(fn, n.dim = 2L, n.objectives = 1L, lower = lower, upper = lower,
 representation = "float", mu = 20L, lambda = 10L,
  mutator = setup(mutGauss, lower = lower, upper = upper))
</code></pre>


</div>