<div class="container">

<table style="width: 100%;"><tr>
<td>tricontour</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate contour curves on a triangulation</h2>

<h3>Description</h3>

<p>Calculates contour curves and/or regions between them,
for functions defined on a triangulation
</p>


<h3>Usage</h3>

<pre><code class="language-R">tricontour(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  ...
)

## S3 method for class 'inla.mesh'
tricontour(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  ...
)

## S3 method for class 'matrix'
tricontour(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  loc,
  ...
)

## S3 method for class 'list'
tricontour(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  loc,
  type = c("+", "-"),
  tol = 1e-07,
  ...
)

tricontourmap(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  ...
)

## S3 method for class 'inla.mesh'
tricontourmap(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  ...
)

## S3 method for class 'matrix'
tricontourmap(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  loc,
  ...
)

## S3 method for class 'list'
tricontourmap(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  loc,
  type = c("+", "-"),
  tol = 1e-07,
  output = c("sp", "fm", "inla.mesh.segment"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object generated by a call to <code>inla.mesh.2d</code> or
<code>inla.mesh.create</code>, a triangle-vertex index matrix, or a list
of triangulation information, <code>list(loc, graph=list(tv))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>A vector containing the values to be contoured
(<code>NA</code>s are allowed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlevels</code></td>
<td>
<p>Number of contour levels desired, if and only if
<code>levels</code> is not supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>Numeric vector of levels at which to calculate contour lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to the other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>coordinate matrix, to be supplied when <code>x</code> is given as a
triangle-vertex index matrix only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p><code>"+"</code> or <code>"-"</code>, indicating positive or negative
association. For <code>+</code>, the generated contours enclose regions
where <code class="reqn">u_1 \leq z &lt; u_2</code>, for <code>-</code> the regions fulfil <code class="reqn">u_1
  &lt; z \leq u_2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance for determining if the value at a vertex lies on a level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>The format of the generated output.  Implemented options
are <code>"sp"</code> (default) and <code>"fm"</code> (and deprecated <code>"inla.mesh.segment"</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For <code>tricontour</code>, a list with some of the fields that
<code>inla.mesh.segment</code> objects have:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>A coordinate matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx</code></td>
<td>
<p>Contour segment indices, as a 2-column matrix, each row
indexing a single segment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grp</code></td>
<td>
<p>A vector of group labels.  Each segment has a label, in
<code>1,...,nlevels*2+1</code>, where even labels indicate interior
on-level contour segments, and odd labels indicate boundary segments
between levels.</p>
</td>
</tr>
</table>
<p>For <code>tricontourmap</code>, a list:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>contour</code></td>
<td>
<p>A list of <code>sp</code> or <code>inla.mesh.segment</code> objects
defining countour curves (level sets)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>A list of <code>sp</code> or <code>inla.mesh.segment</code> objects
enclosing regions between level sets</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
if (require("fmesher")) {
  ## Generate mesh and SPDE model
  n.lattice &lt;- 20 # increase for more interesting, but slower, examples
  x &lt;- seq(from = 0, to = 10, length.out = n.lattice)
  lattice &lt;- fm_lattice_2d(x = x, y = x)
  mesh &lt;- fm_rcdt_2d_inla(lattice = lattice, extend = FALSE, refine = FALSE)

  ## Generate an artificial sample
  sigma2.e &lt;- 0.1
  n.obs &lt;- 1000
  obs.loc &lt;- cbind(
    runif(n.obs) * diff(range(x)) + min(x),
    runif(n.obs) * diff(range(x)) + min(x)
  )
  Q &lt;- fm_matern_precision(mesh, alpha = 2, rho = 3, sigma = 1)
  x &lt;- fm_sample(n = 1, Q = Q)
  A &lt;- fm_basis(mesh, loc = obs.loc)
  Y &lt;- as.vector(A %*% x + rnorm(n.obs) * sqrt(sigma2.e))

  ## Calculate posterior
  Q.post &lt;- (Q + (t(A) %*% A) / sigma2.e)
  mu.post &lt;- as.vector(solve(Q.post, (t(A) %*% Y) / sigma2.e))

  ## Calculate continuous contours
  tric &lt;- tricontour(mesh,
    z = mu.post,
    levels = as.vector(quantile(x, c(0.25, 0.75)))
  )

  ## Discrete domain contours
  map &lt;- contourmap(
    n.levels = 2, mu = mu.post, Q = Q.post,
    alpha = 0.1, compute = list(F = FALSE), max.threads = 1
  )

  ## Calculate continuous contour map
  setsc &lt;- tricontourmap(mesh,
    z = mu.post,
    levels = as.vector(quantile(x, c(0.25, 0.75)))
  )

  ## Plot the results
  reo &lt;- mesh$idx$lattice
  idx.setsc &lt;- setdiff(names(setsc$map), "-1")
  cols2 &lt;- contourmap.colors(map,
    col = heat.colors(100, 0.5, rev = TRUE),
    credible.col = grey(0.5, 0)
  )
  names(cols2) &lt;- as.character(-1:2)

  par(mfrow = c(1, 2))
  image(matrix(mu.post[reo], n.lattice, n.lattice),
    main = "mean", axes = FALSE, asp = 1
  )
  plot(setsc$map[idx.setsc], col = cols2[idx.setsc])
  par(mfrow = c(1, 1))
}

## End(Not run)
</code></pre>


</div>