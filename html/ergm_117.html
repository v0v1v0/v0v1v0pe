<div class="container">

<table style="width: 100%;"><tr>
<td>control.simulate.ergm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Auxiliary for Controlling ERGM Simulation</h2>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning ERGM
simulation. <code>control.simulate</code>, <code>control.simulate.formula</code>, and
<code>control.simulate.formula.ergm</code> are all aliases for the same
function.
</p>
<p>While the others supply a full set of simulation
settings, <code>control.simulate.ergm</code> when passed as a control
parameter to <code>simulate.ergm()</code> allows some settings to be
inherited from the ERGM stimation while overriding others.
</p>


<h3>Usage</h3>

<pre><code class="language-R">control.simulate.formula.ergm(
  MCMC.burnin = MCMC.interval * 16,
  MCMC.interval = 1024,
  MCMC.prop = trim_env(~sparse + .triadic),
  MCMC.prop.weights = "default",
  MCMC.prop.args = list(),
  MCMC.batch = NULL,
  MCMC.effectiveSize = NULL,
  MCMC.effectiveSize.damp = 10,
  MCMC.effectiveSize.maxruns = 1000,
  MCMC.effectiveSize.burnin.pval = 0.2,
  MCMC.effectiveSize.burnin.min = 0.05,
  MCMC.effectiveSize.burnin.max = 0.5,
  MCMC.effectiveSize.burnin.nmin = 16,
  MCMC.effectiveSize.burnin.nmax = 128,
  MCMC.effectiveSize.burnin.PC = FALSE,
  MCMC.effectiveSize.burnin.scl = 1024,
  MCMC.effectiveSize.order.max = NULL,
  MCMC.maxedges = Inf,
  MCMC.packagenames = c(),
  MCMC.runtime.traceplot = FALSE,
  network.output = "network",
  term.options = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)

control.simulate(
  MCMC.burnin = MCMC.interval * 16,
  MCMC.interval = 1024,
  MCMC.prop = trim_env(~sparse + .triadic),
  MCMC.prop.weights = "default",
  MCMC.prop.args = list(),
  MCMC.batch = NULL,
  MCMC.effectiveSize = NULL,
  MCMC.effectiveSize.damp = 10,
  MCMC.effectiveSize.maxruns = 1000,
  MCMC.effectiveSize.burnin.pval = 0.2,
  MCMC.effectiveSize.burnin.min = 0.05,
  MCMC.effectiveSize.burnin.max = 0.5,
  MCMC.effectiveSize.burnin.nmin = 16,
  MCMC.effectiveSize.burnin.nmax = 128,
  MCMC.effectiveSize.burnin.PC = FALSE,
  MCMC.effectiveSize.burnin.scl = 1024,
  MCMC.effectiveSize.order.max = NULL,
  MCMC.maxedges = Inf,
  MCMC.packagenames = c(),
  MCMC.runtime.traceplot = FALSE,
  network.output = "network",
  term.options = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)

control.simulate.formula(
  MCMC.burnin = MCMC.interval * 16,
  MCMC.interval = 1024,
  MCMC.prop = trim_env(~sparse + .triadic),
  MCMC.prop.weights = "default",
  MCMC.prop.args = list(),
  MCMC.batch = NULL,
  MCMC.effectiveSize = NULL,
  MCMC.effectiveSize.damp = 10,
  MCMC.effectiveSize.maxruns = 1000,
  MCMC.effectiveSize.burnin.pval = 0.2,
  MCMC.effectiveSize.burnin.min = 0.05,
  MCMC.effectiveSize.burnin.max = 0.5,
  MCMC.effectiveSize.burnin.nmin = 16,
  MCMC.effectiveSize.burnin.nmax = 128,
  MCMC.effectiveSize.burnin.PC = FALSE,
  MCMC.effectiveSize.burnin.scl = 1024,
  MCMC.effectiveSize.order.max = NULL,
  MCMC.maxedges = Inf,
  MCMC.packagenames = c(),
  MCMC.runtime.traceplot = FALSE,
  network.output = "network",
  term.options = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)

control.simulate.ergm(
  MCMC.burnin = NULL,
  MCMC.interval = NULL,
  MCMC.scale = 1,
  MCMC.prop = NULL,
  MCMC.prop.weights = NULL,
  MCMC.prop.args = NULL,
  MCMC.batch = NULL,
  MCMC.effectiveSize = NULL,
  MCMC.effectiveSize.damp = 10,
  MCMC.effectiveSize.maxruns = 1000,
  MCMC.effectiveSize.burnin.pval = 0.2,
  MCMC.effectiveSize.burnin.min = 0.05,
  MCMC.effectiveSize.burnin.max = 0.5,
  MCMC.effectiveSize.burnin.nmin = 16,
  MCMC.effectiveSize.burnin.nmax = 128,
  MCMC.effectiveSize.burnin.PC = FALSE,
  MCMC.effectiveSize.burnin.scl = 1024,
  MCMC.effectiveSize.order.max = NULL,
  MCMC.maxedges = Inf,
  MCMC.packagenames = NULL,
  MCMC.runtime.traceplot = FALSE,
  network.output = "network",
  term.options = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>MCMC.burnin</code></td>
<td>
<p>Number of proposals before any MCMC sampling is done. It
typically is set to a fairly large number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.interval</code></td>
<td>
<p>Number of proposals between sampled statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.prop</code></td>
<td>
<p>Specifies the proposal (directly) and/or
a series of "hints" about the structure of the model being
sampled. The specification is in the form of a one-sided formula
with hints separated by <code>+</code> operations. If the LHS exists and is
a string, the proposal to be used is selected directly.
</p>
<p>A common and default "hint" is <code>~sparse</code>, indicating
that the network is sparse and that the sample should put roughly
equal weight on selecting a dyad with or without a tie as a
candidate for toggling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.prop.weights</code></td>
<td>
<p>Specifies the proposal
distribution used in the MCMC Metropolis-Hastings algorithm.  Possible
choices depending on selected <code>reference</code> and <code>constraints</code>
arguments of the <code>ergm()</code> function, but often include <code>"TNT"</code>
and <code>"random"</code>, and the <code>"default"</code> is to use the one with the
highest priority available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.prop.args</code></td>
<td>
<p>An alternative, direct way of
specifying additional arguments to proposal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.batch</code></td>
<td>
<p>if not 0 or <code>NULL</code>, sample about this many
networks per call to the lower-level code; this can be useful if
<code style="white-space: pre;">⁠output=⁠</code> is a function, where it can be used to limit the number
of networks held in memory at any given time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.effectiveSize, MCMC.effectiveSize.damp, MCMC.effectiveSize.maxruns, MCMC.effectiveSize.burnin.pval, MCMC.effectiveSize.burnin.min, MCMC.effectiveSize.burnin.max, MCMC.effectiveSize.burnin.nmin, MCMC.effectiveSize.burnin.nmax, MCMC.effectiveSize.burnin.PC, MCMC.effectiveSize.burnin.scl, MCMC.effectiveSize.order.max</code></td>
<td>
<p>Set <code>MCMC.effectiveSize</code> to a non-NULL value to adaptively
determine the burn-in and the MCMC length needed to get the
specified effective size; 50 is a reasonable value. In the
adaptive MCMC mode, MCMC is run forward repeatedly
(<code>MCMC.samplesize*MCMC.interval</code> steps, up to
<code>MCMC.effectiveSize.maxruns</code> times) until the target effective
sample size is reached or exceeded.
</p>
<p>After each run, the returned statistics are mapped to the
estimating function scale, then an exponential decay model is fit
to the scaled statistics to find that burn-in which would reduce
the difference between the initial values of statistics and their
equilibrium values by a factor of <code>MCMC.effectiveSize.burnin.scl</code>
of what it initially was, bounded by <code>MCMC.effectiveSize.min</code> and
<code>MCMC.effectiveSize.max</code> as proportions of sample size. If the
best-fitting decay exceeds <code>MCMC.effectiveSize.max</code>, the
exponential model is considered to be unsuitable and
<code>MCMC.effectiveSize.min</code> is used.
</p>
<p>A Geweke diagnostic is then run, after thinning the sample to
<code>MCMC.effectiveSize.burnin.nmax</code>. If this Geweke diagnostic
produces a <code class="reqn">p</code>-value higher than
<code>MCMC.effectiveSize.burnin.pval</code>, it is accepted.
</p>
<p>If <code>MCMC.effectiveSize.burnin.PC&gt;0</code>, instead of using the full
sample for burn-in estimation, at most this many principal
components are used instead.
</p>
<p>The effective size of the post-burn-in sample is computed via
Vats et al. (2019), and compared to the target
effective size. If it is not matched, the MCMC run is resumed,
with the additional draws needed linearly extrapolated but
weighted in favor of the baseline <code>MCMC.samplesize</code> by the
weighting factor <code>MCMC.effectiveSize.damp</code> (higher = less
damping). Lastly, if after an MCMC run, the number of samples
equals or exceeds <code>2*MCMC.samplesize</code>, the chain will be thinned
by 2 until it falls below that, while doubling
<code>MCMC.interval</code>. <code>MCMC.effectiveSize.order.max</code> can be used to
set the order of the AR model used to estimate the effective
sample size and the variance for the Geweke diagnostic.
</p>
<p>Lastly, if <code>MCMC.effectiveSize</code> is a matrix, say, <code class="reqn">W</code>, it
will be treated as a target precision (inverse-variance) matrix.
If <code class="reqn">V</code> is the sample covariance matrix, the target effective
size <code class="reqn">n_{\text{eff}}</code> will be set such that
<code class="reqn">V/n_{\text{eff}}</code> is close to <code class="reqn">W</code> in magnitude,
specifically that <code class="reqn">\operatorname{tr}((V/n_{\text{eff}})W)/p\approx 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.maxedges</code></td>
<td>
<p>The maximum number of edges that may occur during the MCMC sampling. If this number is exceeded at any time, sampling is stopped immediately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.runtime.traceplot</code></td>
<td>
<p>Logical: If <code>TRUE</code>, plot traceplots of the MCMC
sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>network.output</code></td>
<td>
<p>R class with which to output networks. The options are
"network" (default) and "edgelist.compressed" (which saves space but only
supports networks without vertex attributes)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code>? term.options</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Number of threads in which to run the sampling. Defaults to
0 (no parallelism). See the entry on parallel processing
for details and troubleshooting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.type</code></td>
<td>
<p>API to use for parallel processing. Supported values
are <code>"MPI"</code> and <code>"PSOCK"</code>. Defaults to using the <code>parallel</code>
package with PSOCK clusters. See <code>ergm-parallel</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.version.check</code></td>
<td>
<p>Logical: If TRUE, check that the version of
<span class="pkg">ergm</span> running on the slave nodes is the same as
that running on the master node.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.inherit.MT</code></td>
<td>
<p>Logical: If TRUE, slave nodes and
processes inherit the <code>set.MT_terms()</code> setting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>A dummy argument to catch deprecated or mistyped control parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCMC.scale</code></td>
<td>
<p>For <code>control.simulate.ergm()</code> inheriting
<code>MCMC.burnin</code> and <code>MCMC.interval</code> from the <code>ergm</code> fit, the
multiplier for the inherited values. This can be useful because
MCMC parameters used in the fit are tuned to generate a specific
effective sample size for the sufficient statistic in a large
MCMC sample, so the inherited values might not generate
independent realisations.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is only used within a call to the ERGM <code>simulate()</code>
function.  See the Usage section in <code>simulate.ergm()</code> for
details.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>See Also</h3>

<p><code>simulate.ergm()</code>, <code>simulate.formula()</code>.
<code>control.ergm()</code> performs a similar function for
<code>ergm()</code>; <code>control.gof()</code> performs a similar function
for <code>gof()</code>.
</p>


</div>