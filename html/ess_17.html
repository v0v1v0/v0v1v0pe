<div class="container">

<table style="width: 100%;"><tr>
<td>fit_graph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a decomposable graphical model</h2>

<h3>Description</h3>

<p>A generic method for structure learning in decomposable
graphical models
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_graph(
  df,
  type = "fwd",
  q = 0.5,
  trace = FALSE,
  sparse_qic = FALSE,
  thres = 5,
  wrap = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Character data.frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character ("fwd", "bwd", "tree" or "tfwd")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Penalty term in the stopping criterion
where <code>0</code> = AIC and <code>1</code> = BIC. Anything in between is
referred to as <code>qic</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Logical indicating whether or not to trace the procedure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse_qic</code></td>
<td>
<p>Logical. If <code>nrow(df)</code> is small, the tables
tends to be sparse. In these cases the usual penalty term of AIC and
BIC is often too restrictive. If <code>sparse_qic</code> is <code>TRUE</code>
this penality is computed according to a sparse criteria. The criteria
resembles the usual penalty as <code>nrow(df)</code> grows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thres</code></td>
<td>
<p>A threshold mechanism for choosing between two different ways of
calculating the entropy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrap</code></td>
<td>
<p>logical specifying if the result of a run with type = "tree"
should be converted to a "fwd" object</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The types are
</p>

<ul>
<li>
<p> "fwd": forward selection
</p>
</li>
<li>
<p> "bwd": backward selection
</p>
</li>
<li>
<p> "tree": Chow-Liu tree (first order interactions only)
</p>
</li>
<li>
<p> "tfwd": A combination of "tree" and "fwd". This can speed up runtime considerably in high dimensions.
</p>
</li>
</ul>
<p>Using <code>adj_lst</code> on an object returned by <code>fit_graph</code> gives the
adjacency list corresponding to the graph. Similarly one can use <code>adj_mat</code>
to obtain an adjacency matrix. Applying the <code>rip</code> function on an
adjacency list returns the cliques and separators of the graph.
</p>


<h3>Value</h3>

<p>A <code>gengraph</code> object representing a decomposable graph.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1301.2267">https://arxiv.org/abs/1301.2267</a>, doi: <a href="https://doi.org/10.1109/ictai.2004.100">10.1109/ictai.2004.100</a>
</p>


<h3>See Also</h3>

<p><code>adj_lst</code>, <code>adj_mat</code>,
<code>as_igraph</code>, <code>gengraph</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
g &lt;- fit_graph(derma)
print(g)
plot(g)

# Adjacency matrix and adjacency list
adjm &lt;- adj_mat(g)
adjl &lt;- adj_lst(g)

</code></pre>


</div>