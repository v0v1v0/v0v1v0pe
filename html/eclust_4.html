<div class="container">

<table style="width: 100%;"><tr>
<td>r_cluster_data</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cluster data using environmental exposure</h2>

<h3>Description</h3>

<p>This is one of the functions for real data analysis, which will
cluster the data based on the environment, as well as ignoring the
environment
</p>


<h3>Usage</h3>

<pre><code class="language-R">r_cluster_data(data, response, exposure, train_index, test_index,
  cluster_distance = c("corr", "corr0", "corr1", "tom", "tom0", "tom1",
  "diffcorr", "difftom", "fisherScore"), eclust_distance = c("fisherScore",
  "corScor", "diffcorr", "difftom"), measure_distance = c("euclidean",
  "maximum", "manhattan", "canberra", "binary", "minkowski"),
  minimum_cluster_size = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>n x p matrix of data. rows are samples, columns are genes or cpg
sites. Should not contain the environment variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>numeric vector of length n</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exposure</code></td>
<td>
<p>binary (0,1) numeric vector of length n for the exposure
status of the n samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train_index</code></td>
<td>
<p>numeric vector indcating the indices of <code>response</code>
and the rows of <code>data</code> that are in the training set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test_index</code></td>
<td>
<p>numeric vector indcating the indices of <code>response</code> and
the rows of <code>data</code> that are in the test set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_distance</code></td>
<td>
<p>character representing which matrix from the training
set that you want to use to cluster the genes. Must be one of the following
</p>
 <ul><li>
<p> corr, corr0, corr1, tom, tom0, tom1, diffcorr, difftom,
corScor, tomScor, fisherScore </p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eclust_distance</code></td>
<td>
<p>character representing which matrix from the training
set that you want to use to cluster the genes based on the environment. See
<code>cluster_distance</code> for avaialble options. Should be different from
<code>cluster_distance</code>. For example, if <code>cluster_distance=corr</code> and
<code>EclustDistance=fisherScore</code>. That is, one should be based on
correlations ignoring the environment, and the other should be based on
correlations accounting for the environment. This function will always
return this add on</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measure_distance</code></td>
<td>
<p>one of "euclidean","maximum","manhattan",
"canberra", "binary","minkowski" to be passed to <code>dist</code>
function for calculating the distance for the clusters based on the
corr,corr1,corr0, tom, tom0, tom1 matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minimum_cluster_size</code></td>
<td>
<p>The minimum cluster size. Only applicable if
<code>cutMethod='dynamic'</code>. This argument is passed to the
<code>cutreeDynamic</code> function through the
<code>u_cluster_similarity</code> function. Default is 50.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to the <code>u_cluster_similarity</code>
function</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function clusters the data. The results of this function should
then be passed to the <code>r_prepare_data</code> function which output
the appropriate X and Y matrices in the right format for regression
packages such as <code>mgcv</code>, <code>caret</code> and <code>glmnet</code>
</p>


<h3>Value</h3>

<p>a list of length 8: </p>
<dl>
<dt>clustersAddon</dt>
<dd>
<p>clustering results
based on the environment and not the environment. see
<code>u_cluster_similarity</code> for
details</p>
</dd>
<dt>clustersAll</dt>
<dd>
<p>clustering results ignoring the environment. See
<code>u_cluster_similarity</code> for details</p>
</dd>
<dt>etrain</dt>
<dd>
<p>vector of the
exposure variable for the training
set</p>
</dd>
<dt>cluster_distance_similarity</dt>
<dd>
<p>the similarity matrix based on the
argument specified in
<code>cluster_distance</code></p>
</dd>
<dt>eclust_distance_similarity</dt>
<dd>
<p>the similarity
matrix based on the argument specified in
<code>eclust_distance</code></p>
</dd>
<dt>clustersAddonMembership</dt>
<dd>
<p>a data.frame and
data.table of the clustering membership for clustering results based on the
environment and not the environment. As a result, each gene will show up
twice in this table</p>
</dd>
<dt>clustersAllMembership</dt>
<dd>
<p>a data.frame and
data.table of the clustering membership for clustering results based on all
subjects i.e. ignoring the environment. Each gene will only show up once in
this table</p>
</dd>
<dt>clustersEclustMembership</dt>
<dd>
<p>a data.frame and data.table of
the clustering membership for clustering results accounting for the
environment. Each gene will only show up once in this table</p>
</dd>
</dl>
<h3>See Also</h3>

<p><code>u_cluster_similarity</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("tcgaov")
tcgaov[1:5,1:6, with = FALSE]
Y &lt;- log(tcgaov[["OS"]])
E &lt;- tcgaov[["E"]]
genes &lt;- as.matrix(tcgaov[,-c("OS","rn","subtype","E","status"),with = FALSE])
trainIndex &lt;- drop(caret::createDataPartition(Y, p = 0.5, list = FALSE, times = 1))
testIndex &lt;- setdiff(seq_len(length(Y)),trainIndex)

## Not run: 
cluster_res &lt;- r_cluster_data(data = genes,
                              response = Y,
                              exposure = E,
                              train_index = trainIndex,
                              test_index = testIndex,
                              cluster_distance = "tom",
                              eclust_distance = "difftom",
                              measure_distance = "euclidean",
                              clustMethod = "hclust",
                              cutMethod = "dynamic",
                              method = "average",
                              nPC = 1,
                              minimum_cluster_size = 60)

# the number of clusters determined by the similarity matrices specified
# in the cluster_distance and eclust_distance arguments. This will always be larger
# than cluster_res$clustersAll$nclusters which is based on the similarity matrix
# specified in the cluster_distance argument
cluster_res$clustersAddon$nclusters

# the number of clusters determined by the similarity matrices specified
# in the cluster_distance argument only
cluster_res$clustersAll$nclusters

## End(Not run)
</code></pre>


</div>