<div class="container">

<table style="width: 100%;"><tr>
<td>linearTrendTestScaledMds</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Scaled Minimal Detectable Slope for a t-Test for Linear Trend
</h2>

<h3>Description</h3>

<p>Compute the scaled minimal detectable slope associated with a t-test for liner 
trend, given the sample size or predictor variable values, power, and 
significance level.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  linearTrendTestScaledMds(n, x = lapply(n, seq), alpha = 0.05, power = 0.95, 
    alternative = "two.sided", two.sided.direction = "greater", approx = FALSE, 
    tol = 1e-07, maxiter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>numeric vector of sample sizes.  All values of <code>n</code> must be positive integers 
larger than 2.  This argument is ignored when <code>x</code> is supplied.  
Missing (<code>NA</code>), undefined (<code>NaN</code>), and infinite (<code>Inf</code>, <code>-Inf</code>) 
values are not allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>numeric vector of predictor variable values, or a list in which each component is 
a numeric vector of predictor variable values.  Usually, the predictor variable is 
time (e.g., days, months, quarters, etc.).  The default value is 
<code>x=lapply(n,seq)</code>, which yields a list in which the i'th component is the 
seqence of integers from 1 to the i'th value of the vector <code>n</code>.  If <code>x</code> 
is a numeric vector, it must contain at least three elements, two of which must be 
unique.  If <code>x</code> is a list of numeric vectors, each component of <code>x</code> 
must contain at least three elements, two of which must be unique.  
Missing (<code>NA</code>), undefined (<code>NaN</code>), and infinite (<code>Inf</code>, <code>-Inf</code>) 
values are not allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>numeric vector of numbers between 0 and 1 indicating the Type I error level 
associated with the hypothesis test.  The default value is <code>alpha=0.05</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>

<p>numeric vector of numbers between 0 and 1 indicating the power 
associated with the hypothesis test.  The default value is <code>power=0.95</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>

<p>character string indicating the kind of alternative hypothesis.  The possible values 
are <code>"two.sided"</code> (the default), <code>"greater"</code>, and <code>"less"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>two.sided.direction</code></td>
<td>

<p>character string indicating the direction (positive or negative) for the 
scaled minimal detectable slope when <code>alternative="two.sided"</code>.  When <br><code>two.sided.direction="greater"</code> (the default), the scaled minimal 
detectable slope is positive.  When <code>two.sided.direction="less"</code>, 
the scaled minimal detectable slope is negative.  This argument 
is ignored if <code>alternative="less"</code> or <code>alternative="greater"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx</code></td>
<td>

<p>logical scalar indicating whether to compute the power based on an approximation to 
the non-central t-distribution.  The default value is <code>approx=FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>numeric scalar indicating the toloerance to use in the 
<code>uniroot</code> search algorithm.  
The default value is <code>tol=1e-7</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>

<p>positive integer indicating the maximum number of iterations 
argument to pass to the <code>uniroot</code> function.  The default 
value is <code>maxiter=1000</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the argument <code>x</code> is a vector, it is converted into a list with one 
component.  If the arguments <code>n</code>, <code>x</code>, <code>alpha</code>, and 
<code>power</code> are not all the same length, they are replicated to be the same 
length as the length of the longest argument.
</p>
<p>Formulas for the power of the t-test of linear trend for specified values of 
the sample size, scaled slope, and Type I error level are given in 
the help file for <code>linearTrendTestPower</code>.  The function 
<code>linearTrendTestScaledMds</code> uses the <code>uniroot</code> search algorithm to 
determine the minimal detectable scaled slope for specified values of the power, 
sample size, and Type I error level. 
</p>


<h3>Value</h3>

<p>numeric vector of computed scaled minimal detectable slopes.  When 
<code>alternative="less"</code>, or <code>alternative="two.sided"</code> and 
<code>two.sided.direction="less"</code>, the computed slopes are negative.  Otherwise, 
the slopes are positive.
</p>


<h3>Note</h3>

<p>See the help file for <code>linearTrendTestPower</code>.
</p>


<h3>Author(s)</h3>

<p>Steven P. Millard (<a href="mailto:EnvStats@ProbStatInfo.com">EnvStats@ProbStatInfo.com</a>)
</p>


<h3>References</h3>

<p>See the help file for <code>linearTrendTestPower</code>.
</p>


<h3>See Also</h3>

<p><code>linearTrendTestPower</code>, <code>linearTrendTestN</code>, 
<code>plotLinearTrendTestDesign</code>, <code>lm</code>, 
<code>summary.lm</code>, <code>kendallTrendTest</code>, 
Power and Sample Size, Normal, <code>t.test</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Look at how the scaled minimal detectable slope for the t-test for linear 
  # trend increases with increasing required power:

  seq(0.5, 0.9, by = 0.1) 
  #[1] 0.5 0.6 0.7 0.8 0.9 

  scaled.mds &lt;- linearTrendTestScaledMds(n = 10, power = seq(0.5, 0.9, by = 0.1)) 

  round(scaled.mds, 2) 
  #[1] 0.25 0.28 0.31 0.35 0.41

  #----------

  # Repeat the last example, but compute the scaled minimal detectable slopes 
  # based on the approximate power instead of the exact:

  scaled.mds &lt;- linearTrendTestScaledMds(n = 10, power = seq(0.5, 0.9, by = 0.1), 
    approx = TRUE) 

  round(scaled.mds, 2) 
  #[1] 0.25 0.28 0.31 0.35 0.41

  #==========

  # Look at how the scaled minimal detectable slope for the t-test for linear trend 
  # decreases with increasing sample size:

  seq(10, 50, by = 10) 
  #[1] 10 20 30 40 50 

  scaled.mds &lt;- linearTrendTestScaledMds(seq(10, 50, by = 10), alternative = "greater") 

  round(scaled.mds, 2) 
  #[1] 0.40 0.13 0.07 0.05 0.03

  #==========

  # Look at how the scaled minimal detectable slope for the t-test for linear trend 
  # decreases with increasing values of Type I error:

  scaled.mds &lt;- linearTrendTestScaledMds(10, alpha = c(0.001, 0.01, 0.05, 0.1), 
    alternative="greater") 

  round(scaled.mds, 2) 
  #[1] 0.76 0.53 0.40 0.34

  #----------

  # Repeat the last example, but compute the scaled minimal detectable slopes 
  # based on the approximate power instead of the exact:
 
  scaled.mds &lt;- linearTrendTestScaledMds(10, alpha = c(0.001, 0.01, 0.05, 0.1), 
    alternative="greater", approx = TRUE) 

  round(scaled.mds, 2) 
  #[1] 0.70 0.52 0.41 0.36

  #==========

  # Clean up
  #---------
  rm(scaled.mds)
</code></pre>


</div>