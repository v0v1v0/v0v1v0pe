<div class="container">

<table style="width: 100%;"><tr>
<td>community.detection</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply a Community Detection Algorithm</h2>

<h3>Description</h3>

<p>General function to apply community detection algorithms available in
<code>igraph</code>. Follows the <code>EGAnet</code> approach of setting
singleton and disconnected nodes to missing (<code>NA</code>)
</p>


<h3>Usage</h3>

<pre><code class="language-R">community.detection(
  network,
  algorithm = c("edge_betweenness", "fast_greedy", "fluid", "infomap", "label_prop",
    "leading_eigen", "leiden", "louvain", "optimal", "spinglass", "walktrap"),
  allow.singleton = FALSE,
  membership.only = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>network</code></td>
<td>
<p>Matrix or <code>igraph</code> network object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>Character or <code>igraph</code> <code>cluster_*</code> function
(length = 1).
Available options:
</p>

<ul>
<li> <p><code>"edge_betweenness"</code> — See <code>cluster_edge_betweenness</code> for more details
</p>
</li>
<li> <p><code>"fast_greedy"</code> — See <code>cluster_fast_greedy</code> for more details
</p>
</li>
<li> <p><code>"fluid"</code> — See <code>cluster_fluid_communities</code> for more details
</p>
</li>
<li> <p><code>"infomap"</code> — See <code>cluster_infomap</code> for more details
</p>
</li>
<li> <p><code>"label_prop"</code> — See <code>cluster_label_prop</code> for more details
</p>
</li>
<li> <p><code>"leading_eigen"</code> — See <code>cluster_leading_eigen</code> for more details
</p>
</li>
<li> <p><code>"leiden"</code> — See <code>cluster_leiden</code> for more details.
<em>Note</em>: The Leiden algorithm will default to the
modularity objective function (<code>objective_function = "modularity"</code>).
Set <code>objective_function = "CPM"</code> to use the
Constant Potts Model instead (see examples)
</p>
</li>
<li> <p><code>"louvain"</code> — See <code>cluster_louvain</code> for more details
</p>
</li>
<li> <p><code>"optimal"</code> — See <code>cluster_optimal</code> for more details
</p>
</li>
<li> <p><code>"spinglass"</code> — See <code>cluster_spinglass</code> for more details
</p>
</li>
<li> <p><code>"walktrap"</code> — See <code>cluster_walktrap</code> for more details
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow.singleton</code></td>
<td>
<p>Boolean (length = 1).
Whether singleton or single node communities should be allowed.
Defaults to <code>FALSE</code>.
When <code>FALSE</code>, singleton communities will be set to
missing (<code>NA</code>); otherwise, when <code>TRUE</code>, singleton
communities will be allowed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>membership.only</code></td>
<td>
<p>Boolean (length = 1).
Whether the memberships only should be output.
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to obtain all output for the
community detection algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed on to
<code>igraph</code>'s community detection functions
(see <code>algorithm</code> for link to arguments of each algorithm)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns memberships from a community detection algorithm
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Csardi, G., &amp; Nepusz, T. (2006).
The igraph software package for complex network research.
<em>InterJournal, Complex Systems</em>, 1695.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load data
wmt &lt;- wmt2[,7:24]

# Estimate network
network &lt;- EBICglasso.qgraph(data = wmt)

# Compute Edge Betweenness
community.detection(network, algorithm = "edge_betweenness")

# Compute Fast Greedy
community.detection(network, algorithm = "fast_greedy")

# Compute Fluid
community.detection(
  network, algorithm = "fluid",
  no.of.communities = 2 # needs to be set
)

# Compute Infomap
community.detection(network, algorithm = "infomap")

# Compute Label Propagation
community.detection(network, algorithm = "label_prop")

# Compute Leading Eigenvector
community.detection(network, algorithm = "leading_eigen")

# Compute Leiden (with modularity)
community.detection(
  network, algorithm = "leiden",
  objective_function = "modularity"
)

# Compute Leiden (with CPM)
community.detection(
  network, algorithm = "leiden",
  objective_function = "CPM",
  resolution_parameter = 0.05 # "edge density"
)

# Compute Louvain
community.detection(network, algorithm = "louvain")

# Compute Optimal (identifies maximum modularity solution)
community.detection(network, algorithm = "optimal")

# Compute Spinglass
community.detection(network, algorithm = "spinglass")

# Compute Walktrap
community.detection(network, algorithm = "walktrap")

# Example with {igraph} network
community.detection(
  convert2igraph(network), algorithm = "walktrap"
)

</code></pre>


</div>