<div class="container">

<table style="width: 100%;"><tr>
<td>dynEGA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Dynamic Exploratory Graph Analysis</h2>

<h3>Description</h3>

<p>Estimates dynamic communities in multivariate time series
(e.g., panel data, longitudinal data, intensive longitudinal data) at multiple
time scales and at different levels of analysis:
individuals (intraindividual structure), groups, and population (interindividual structure)
</p>


<h3>Usage</h3>

<pre><code class="language-R">dynEGA(
  data,
  id = NULL,
  group = NULL,
  n.embed = 5,
  tau = 1,
  delta = 1,
  use.derivatives = 1,
  level = c("individual", "group", "population"),
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  ncores,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Matrix or data frame.
Participants and variable should be in long format such that
row <em>t</em> represents observations for all variables at time point
<em>t</em> for a participant. The next row, <em>t + 1</em>, represents
the next measurement occasion for that same participant. The next
participant's data should immediately follow, in the same pattern,
after the previous participant
</p>
<p><code>data</code> should have an ID variable labeled <code>"ID"</code>; otherwise, it is
assumed that the data represent the population
</p>
<p>For groups, <code>data</code> should have a Group variable labeled <code>"Group"</code>;
otherwise, it is assumed that there are no groups in <code>data</code>
</p>
<p>Arguments <code>id</code> and <code>group</code> can be specified to tell the function
which column in <code>data</code> it should use as the ID and Group variable, respectively
</p>
<p>A measurement occasion variable is not necessary and should be <em>removed</em>
from the data before proceeding with the analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Numeric or character (length = 1).
Number or name of the column identifying each individual.
Defaults to <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Numeric or character (length = 1).
Number of the column identifying group membership.
Defaults to <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.embed</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>5</code>.
Number of embedded dimensions (the number of observations to
be used in the <code>Embed</code> function). For example,
an <code>"n.embed = 5"</code> will use five consecutive observations
to estimate a single derivative</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>1</code>.
Number of observations to offset successive embeddings in
the <code>Embed</code> function.
Generally recommended to leave "as is"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>1</code>.
The time between successive observations in the time series (i.e, lag).
Generally recommended to leave "as is"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.derivatives</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>1</code>.
The order of the derivative to be used in the analysis.
Available options:
</p>

<ul>
<li> <p><code>0</code> — No derivatives; consistent with moving average
</p>
</li>
<li> <p><code>1</code> — First-order derivatives; interpreted as "velocity" or
rate of change over time
</p>
</li>
<li> <p><code>2</code> — Second-order derivatives; interpreted as "acceleration" or
rate of the rate of change over time
</p>
</li>
</ul>
<p>Generally recommended to leave "as is"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Character vector (up to length of 3).
A character vector indicating which level(s) to estimate:
</p>

<ul>
<li> <p><code>"individual"</code> — Estimates <code>EGA</code> for each individual in <code>data</code>
(intraindividual structure; requires an <code>"ID"</code> column, see <code>data</code>)
</p>
</li>
<li> <p><code>"group"</code> — Estimates <code>EGA</code> for each group in <code>data</code>
(group structure; requires a <code>"Group"</code> column, see <code>data</code>)
</p>
</li>
<li> <p><code>"population"</code> — Estimates <code>EGA</code> across all <code>data</code>
(interindividual structure)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> — Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code>polychoric.matrix</code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> — Uses <code>cor_auto</code> to compute correlations.
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> — Pearson's correlation is computed for all
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> — Spearman's rank-order correlation is computed
for all variables regardless of categories
</p>
</li>
</ul>
<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> — Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> — Computes correlation for all complete cases in the dataset
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> — Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> — Computes the GLASSO with EBIC model selection.
See <code>EBICglasso.qgraph</code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> — Computes the TMFG method.
See <code>TMFG</code> for more details
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>Character or
<code>igraph</code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code>community.detection</code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> — See <code>cluster_leiden</code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> — By default, <code>"louvain"</code> will implement the Louvain algorithm using
the consensus clustering method (see <code>community.consensus</code>
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code>
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> — See <code>cluster_walktrap</code> for more details
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used?
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> — Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> — Applies the Leading Eigenvector algorithm
(<code>cluster_leading_eigen</code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023)
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> — Applies the Louvain algorithm (<code>cluster_louvain</code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Louvain solution is used; otherwise, regular EGA is used.
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Numeric (length = 1).
Number of cores to use in computing results.
Defaults to <code>ceiling(parallel::detectCores() / 2)</code> or half of your
computer's processing power.
Set to <code>1</code> to not use parallel computing
</p>
<p>If you're unsure how many cores your computer has,
then type: <code>parallel::detectCores()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Boolean (length = 1).
Should progress be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to not display progress</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed on to
<code>auto.correlate</code>,
<code>network.estimation</code>,
<code>community.detection</code>,
<code>community.consensus</code>, and
<code>EGA</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Derivatives for each variable's time series for each participant are
estimated using generalized local linear approximation (see <code>glla</code>).
<code>EGA</code> is then applied to these derivatives to model how variables
are changing together over time. Variables that change together over time are detected
as communities
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Derivatives</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>Estimates</code> — A list the length of the unique IDs containing
data frames of zero- to second-order derivatives for each ID in <code>data</code>
</p>
</li>
<li> <p><code>EstimatesDF</code> — A data frame of derivatives across all IDs containing
columns of the zero- to second-order derivatives as well as <code>id</code> and
<code>group</code> variables (<code>group</code> is automatically set to <code>1</code>
for all if no <code>group</code> is provided)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dynEGA</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>population</code> — If <code>level</code> includes <code>"populaton"</code>, then
the <code>EGA</code> results for the entire sample
</p>
</li>
<li> <p><code>group</code> — If <code>level</code> includes <code>"group"</code>, then
a list containing the <code>EGA</code> results for each <code>group</code>
</p>
</li>
<li> <p><code>individual</code> — If <code>level</code> includes <code>"individual"</code>, then
a list containing the <code>EGA</code> results for each <code>id</code>
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Generalized local linear approximation</strong> <br>
Boker, S. M., Deboeck, P. R., Edler, C., &amp; Keel, P. K. (2010)
Generalized local linear approximation of derivatives from time series. In S.-M. Chow, E. Ferrer, &amp; F. Hsieh (Eds.),
<em>The Notre Dame series on quantitative methodology. Statistical methods for modeling human dynamics: An interdisciplinary dialogue</em>,
(p. 161-178). <em>Routledge/Taylor &amp; Francis Group</em>.
</p>
<p>Deboeck, P. R., Montpetit, M. A., Bergeman, C. S., &amp; Boker, S. M. (2009)
Using derivative estimates to describe intraindividual variability at multiple time scales.
<em>Psychological Methods</em>, <em>14(4)</em>, 367-386.
</p>
<p><strong>Original dynamic EGA implementation</strong> <br>
Golino, H., Christensen, A. P., Moulder, R. G., Kim, S., &amp; Boker, S. M. (2021).
Modeling latent topics in social media using Dynamic Exploratory Graph Analysis: The case of the right-wing and left-wing trolls in the 2016 US elections.
<em>Psychometrika</em>.
</p>
<p><strong>Time delay embedding procedure</strong> <br>
Savitzky, A., &amp; Golay, M. J. (1964).
Smoothing and differentiation of data by simplified least squares procedures.
<em>Analytical Chemistry</em>, <em>36(8)</em>, 1627-1639.
</p>


<h3>See Also</h3>

<p><code>plot.EGAnet</code> for plot usage in <code>EGAnet</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Population structure
simulated_population &lt;- dynEGA(
  data = sim.dynEGA, level = "population"
  # uses simulated data in package
  # useful to understand how data should be structured
)

# Group structure
simulated_group &lt;- dynEGA(
  data = sim.dynEGA, level = "group"
  # uses simulated data in package
  # useful to understand how data should be structured
)

## Not run: 
# Individual structure
simulated_individual &lt;- dynEGA(
  data = sim.dynEGA, level = "individual",
  ncores = 2, # use more for quicker results
  verbose = TRUE # progress bar
)

# Population, group, and individual structure
simulated_all &lt;- dynEGA(
  data = sim.dynEGA,
  level = c("individual", "group", "population"),
  ncores = 2, # use more for quicker results
  verbose = TRUE # progress bar
)

# Plot population
plot(simulated_all$dynEGA$population)

# Plot groups
plot(simulated_all$dynEGA$group)

# Plot individual
plot(simulated_all$dynEGA$individual, id = 1)

# Step through all plots
# Unless `id` is specified, 4 random IDs
# will be drawn from individuals
plot(simulated_all)
## End(Not run)

</code></pre>


</div>