<div class="container">

<table style="width: 100%;"><tr>
<td>ergm.allstats</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate all possible vectors of statistics on a network for an ERGM</h2>

<h3>Description</h3>

<p><code>ergm.allstats</code> calculates the sufficient statistics of an
ERGM over the network's sample space.
</p>
<p><code>ergm.exact()</code> uses <code>ergm.allstats()</code> to calculate the exact loglikelihood, evaluated at
<code>eta</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ergm.allstats(formula, constraints = ~., zeroobs = TRUE, force = FALSE, ...)

ergm.exact(eta, formula, constraints = ~., statmat = NULL, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula, constraints</code></td>
<td>
<p>An ERGM formula and
(optionally) a constraint specification formulas. See
<code>ergm()</code>. This function supports only dyad-independent
constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeroobs</code></td>
<td>
<p>Logical: Should the vectors be centered so that the network
passed in the <code>formula</code> has the zero vector as its statistics?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force</code></td>
<td>
<p>Logical: Should the algorithm be run even if it is determined
that the problem may be very large, thus bypassing the warning message that
normally terminates the function in such cases?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments, passed to <code>ergm_model()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>vector of canonical parameter values at which the loglikelihood
should be evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statmat, weights</code></td>
<td>
<p>outputs from <code>ergm.allstats()</code>: if passed, used in lieu of running it.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The mechanism for doing this is a recursive algorithm, where the number of
levels of recursion is equal to the number of possible dyads that can be
changed from 0 to 1 and back again.  The algorithm starts with the network
passed in <code>formula</code>, then recursively toggles each edge twice so that
every possible network is visited.
</p>
<p><code>ergm.allstats()</code> and <code>ergm.exact()</code> should only be used for small
networks, since the number of possible networks grows extremely
fast with the number of nodes.  An error results if it is used on a
network with more than 31 free dyads, which corresponds to a
directed network of more than 6 nodes or an undirected network of
more than 8 nodes; use <code>force=TRUE</code> to override this error.
</p>
<p>In case <code>ergm.exact()</code> is to be called repeatedly, for instance by an
optimization routine, it is preferable to call <code>ergm.allstats()</code>
first, then pass <code>statmat</code> and <code>weights</code> explicitly to avoid
repeatedly calculating these objects.
</p>


<h3>Value</h3>

<p><code>ergm.allstats()</code> returns a list object with these two elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>integer of counts, one for each row of <code>statmat</code> telling
how many networks share the corresponding vector of statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statmat</code></td>
<td>
<p>matrix in which each row is a unique vector of statistics.</p>
</td>
</tr>
</table>
<p><code>ergm.exact()</code> returns the exact value of the loglikelihood, evaluated at
<code>eta</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Count by brute force all the edge statistics possible for a 7-node 
# undirected network
mynw &lt;- network.initialize(7, dir = FALSE)
system.time(a &lt;- ergm.allstats(mynw~edges))

# Summarize results
rbind(t(a$statmat), .freq. = a$weights)

# Each value of a$weights is equal to 21-choose-k, 
# where k is the corresponding statistic (and 21 is 
# the number of dyads in an 7-node undirected network).  
# Here's a check of that fact:
as.vector(a$weights - choose(21, t(a$statmat)))

# Dyad-independent constraints are also supported:
system.time(a &lt;- ergm.allstats(mynw~edges, constraints = ~fixallbut(cbind(1:2,2:3))))
rbind(t(a$statmat), .freq. = a$weights)


# Simple ergm.exact output for this network.
# We know that the loglikelihood for my empty 7-node network
# should simply be -21*log(1+exp(eta)), so we may check that
# the following two values agree:
-21*log(1+exp(.1234)) 
ergm.exact(.1234, mynw~edges, statmat=a$statmat, weights=a$weights)

</code></pre>


</div>