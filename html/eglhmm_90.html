<div class="container">

<table style="width: 100%;"><tr>
<td>reorder.eglhmm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Reorder the states of a fitted eglhmm model
</h2>

<h3>Description</h3>

<p>Reorder the states of a fitted eglhmm model so that the
state effects are in decreasing order.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'eglhmm'
reorder(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>An object of class <code>"eglhmm"</code> as returned by the function
<code>eglhmm()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Not used.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The states of a fitted hidden Markov model are usually in a
rather arbitrary order, which can sometimes make it difficult
to compare different fits.  This function reorders the states
so that the state corresponding to the “largest state
effect” comes first (and so on down the line). What is meant by
“largest state effect” depends on whether the distribution
used in the model is “Dbd”.  If the distribution is
<em>not</em> “Dbd”, then what is meant is simply the largest
of those entries of <code>phi</code> which correspond to <code>state</code>.
(The vector <code>phi</code> is the vector of coefficients of the
linear predictor in the model.  Note that, since the formula
for the model is constructed as <code>y~0+state+...</code>, the
“state” coefficients are unconstrained and there are as
many of them as there are states.)
</p>
<p>If the distribution in question <em>is</em> “Dbd” then things
are a bit more complicated.  We calculate the theoretical expected
values for “Dbd”s with parameters <code class="reqn">\alpha =</code>
<code>alpha[k]</code> and <code class="reqn">\beta =</code> <code>beta[k]</code> where
<code>alpha[k]</code> and <code>beta[k]</code> are the parameter values
corresponding to the <code>k</code>th state.   The states are then
ordered according to the decreasing order of these expected
values.  These expected values are the expected values of the
emissions given that all predictors other than the <em>state</em>
predictors are zero.
</p>


<h3>Value</h3>

<p>An object of class <code>c("eglhmm","reordered")</code> which
is identical to the argument <code>x</code> in most respects.
The components which (may) differ are:
</p>

<ul>
<li> <p><code>tpm</code>
</p>
</li>
<li> <p><code>ispd</code>
</p>
</li>
<li> <p><code>phi</code>
</p>
</li>
<li> <p><code>theta</code>
</p>
</li>
<li> <p><code>Hessian</code>
</p>
</li>
<li> <p><code>gradient</code>
</p>
</li>
<li> <p><code>mean</code> and <code>sd</code>, or <code>lambda</code> or <code>p</code>,
or <code>alpha</code> and <code>beta</code> (depending on which distribution
is being used)
</p>
</li>
<li> <p><code>fy</code>
</p>
</li>
</ul>
<p>The entries of these components will have the same numerical
values as before but, given that the ordering of the states has
actually changed, will have different orderings, corresponding
to the new ordering of the states.
</p>
<p>Note that the <em>attribute</em> <code>preSpecSigma</code> of the
component <code>theta</code>, may differ from what it was in <code>x</code>.
</p>
<p>The returned value will also have a component <code>neworder</code>
which is an integer vector providing the indices of the
reordering of the states.  It also currently (13/02/2024) has a
component <code>newlog.like</code>.  This should (if there is any
justice in the world — but there isn't!) have the same value
as the component <code>log.like</code>.  Once I am confident that
everything is working as it should, the <code>newlog.like</code>
component will be removed.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>eglhmm()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">    loc4 &lt;- c("LngRf","BondiE","BondiOff","MlbrOff")
    SCC4 &lt;- SydColCount[SydColCount$locn %in% loc4,]
    SCC4$locn &lt;- factor(SCC4$locn) # Get rid of unused levels.
    rownames(SCC4) &lt;- 1:nrow(SCC4)
    fit  &lt;- eglhmm(y~locn+depth,data=SCC4,cells=c("locn","depth"),
                  K=2,distr="P",verb=TRUE)
    ofit &lt;- reorder(fit)
</code></pre>


</div>