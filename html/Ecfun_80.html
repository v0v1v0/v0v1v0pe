<div class="container">

<table style="width: 100%;"><tr>
<td>simulate.bic.glm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
A "simulate" method for a <code>BMA::bic.glm</code>
object
</h2>

<h3>Description</h3>

<p>Simulate predictions for <code>newdata</code> for a
model of class <code>bic.glm</code>.  
</p>
<p>NOTES: The <strong>stats</strong> package has a 
<code>simulate</code> method for 
"<code>lm</code>" objects which is used for 
<code>lm</code> and <code>glm</code> 
objects.  This <code>simulate.bic.glm</code> 
function differs from the 
<code>stats::simulate</code> function 
in the same two fundamental and important ways 
as the <code>simulate.glm</code> function:  
</p>

<ol>
<li>
<p><code>stats::simulate</code>
returns simulated data consistent with the 
model fit assuming the estimated model 
parameters are true and exact, i.e., 
ignoring the uncertainty in parameter 
estimation.  Thus, if <code>family = 
      poisson</code>, 
<code>stats::simulate</code>
returns nonnegative integers.  
</p>
<p>By contrast the <code>simulate.bic.glm</code>
function documented here returns optionally 
simulated <code>coef (coefficients)</code> plus 
simulated values for the <code>link</code> and / 
or <code>response</code> but currently <em>NOT</em> 
pseudo-random numbers on the scale of the 
response.  

</p>
</li>
<li> 
<p>The <code>simulate.bic.glm</code> function 
documented here also accepts an optional 
<code>newdata</code> argument, not accepted by 
<code>stats::simulate</code>.  The 
<code>stats::simulate</code> 
function only returns simulated values for 
the cases in the training set with no 
possibilities for use for different sets 
of conditions.  

</p>
</li>
</ol>
<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'bic.glm'
simulate(object, nsim = 1, 
    seed = NULL, newdata=NULL, 
    type = c("coef", "link", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>an object representing a fitted model 
of class <code>bic.glm</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>

<p>number of response vectors to simulate. 
Defaults to 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>Argument passed as the first argument to 
<code>set.seed</code> if not NULL.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>optionally, a <code>data.frame</code> 
in which to look for variables with 
which to predict. If omitted, predictors 
used in fitting are used.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>the type of simulations required. 
</p>

<ul>
<li>
<p>coef
<code>type = "coef"</code> returns pseudo-
random numbers generated by  
<code>mvtnorm::rmvnorm</code> 
with <code>mean</code> = <code>coef</code> 
and <code>sigma</code> = <code>vcov</code> 
for the component of the BMA mixture
randomly selected for each simulation.  
(Obviously, this does not use 
<code>newdata</code>.)

</p>
</li>
<li>
<p>link
<code>type='link'</code> returns simulations 
on the scale of the linear predictors 
using <code>rmvnorm</code> 
applied  to randomly selected components 
of the mixture with <code>mean</code> = 
<code>coef</code> and <code>sigma</code> = 
<code>vcov</code> for that component.  
For a default binomial model, these are 
of log-odds (probabilities on logit 
scale).

</p>
</li>
<li>
<p>response
<code>object[['linkinv']]</code> of <code>
        type = 'link'</code>.  For a binomial model, 
these are predicted probabilities.  

</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments passed to or from other
methods.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>1.  Save current <code>seed</code> and optionally set 
it using code copied from 
<code>stats:::simulate.lm</code>.  
</p>
<p>2.  <code>postprob &lt;- object[['postprob']]; 
  x &lt;- object[['x']]; y &lt;- object[['y']]; 
  mle &lt;- object[['mle']]; 
  linkinv &lt;- object[['linkinv']]</code>.
</p>
<p>3.  <code>cl &lt;- as.list(object[['call']]);  
  wt &lt;- cl[['wt']]; 
  fam &lt;- cl[['glm.family']]</code>
</p>
<p>4.  <code>if(is.null(newdata))newdata &lt;- x</code> 
else ensure that all levels of factors of 
<code>newdata</code> match <code>x</code>.
</p>
<p>5.  <code>xMat &lt;- model.matrix(~., x);  
  newMat &lt;- model.matrix(~., newdata)</code>
</p>
<p>6.  <code>nComponents &lt;- length(postprob);  
  nobs &lt;- NROW(newdata)</code>
</p>
<p>7.  <code>sims &lt;- matrix(NA, nobs, nsim)</code>
</p>
<p>8.  <code>rmdl &lt;- sample(1:nComponents, nsims,
  TRUE, postprob)</code>
</p>
<p>9.  <code>for(Comp in 1:nComponents)
  nsimComp &lt;- sum(rmdl==Comp); 
  refitComp &lt;- glm.fit(xMat[, mle[Comp,]!=0], y, 
    wt, mle[Comp, mle[Comp,]!=0], family=fam); 
  simCoef &lt;- mvtnorm::rmvnorm(nsimComp, coef
    (refitComp), vcov(rfitComp)); 
  sims[rmdl==Comp, ] &lt;- tcrossprod(newMat[, 
    mle[Comp,]!=0], simCoef)</code>
</p>
<p>10.  If <code>length(type)</code> == 1:  return a
<code>data.frame</code> with one column for 
each desired simulation, consistent with the 
behavior of the generic <code>simulate</code>
applied to objects of class <code>lm</code> or 
<code>glm</code>.  Otherwise, return a list of 
<code>data.frame</code>s of the desired types.  
</p>


<h3>Value</h3>

<p>Returns either a <code>data.frame</code> or a
list of <code>data.frame</code>s depending on
'type':  
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>

<p>a <code>data.frame</code> with <code>nsim</code> 
columns and one row for each variable in the max
model.  Values are non-zero for variables in the 
model in the BMA mixture selected for that 
simulation.  The non-zero values are generated 
using <code>mvtnorm::rmvnorm</code>
with  mean = <code>coef</code> and covariance 
matrix = <code>vcov</code> of the model fit 
to the subset of variables in that component
model.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>

<p>a <code>data.frame</code> with <code>nsim</code> 
columns of <code>nobs</code> values each giving the
simulations on the <code>link</code> scale for each
row in <code>newdata</code> (or the training set if
<code>newdata</code> is not provided).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>

<p>a <code>data.frame</code> with <code>nsim</code>
columns of <code>nobs</code> values each giving the
simulations on the <code>response</code> scale, 
being <code>linkinv</code> of the simulations on 
the <code>link</code> scale.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>if length(type)&gt;1</code></td>
<td>

<p>a list with simulations on the desired scales.  
</p>
</td>
</tr>
</table>
<p>The value also has an attribute "<code>seed</code>". 
If argument <code>seed</code> is NULL, the attribute 
is the value of <code>.Random.seed</code> 
before the simulation started.  Otherwise it 
is the value of the argument with a "kind"
attribute with value <code>as.list(RNGkind())</code>.  
</p>
<p>NOTE:  This function currently may not work
with a model fit that involves a multivariate 
<code>link</code> or <code>response</code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code>simulate</code>
<code>simulate.glm</code>
<code>bic.glm</code>
<code>predict.bic.glm</code>
<code>set.seed</code>
<code>rmvnorm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(BMA)
library(mvtnorm)
##
## 1.  a factor and a numeric 
##
PoisReg2 &lt;- data.frame(
  x=factor(rep(0:2, 2)), x1=rep(1:2, e=3))
bicGLM2 &lt;- bic.glm(PoisReg2, y=1:6, poisson)

newDat2 &lt;- data.frame(
  x=factor(rep(c(0, 2), 2), levels=0:2), 
  x1=3:6)
# NOTE:  Force newDat2['x'] to have the same levels
# as PoisReg2['x']

bicGLMsim2n &lt;- simulate(bicGLM2, nsim=5, seed=2,
  newdata=newDat2[1:3,])

##
## 2.  One variable:  BMA returns
##     a mixture of constant &amp; linear models
##
PoisRegDat &lt;- data.frame(x=1:2, y=c(5, 10))
bicGLMex &lt;- bic.glm(PoisRegDat['x'], 
                     PoisRegDat[, 'y'], poisson)
(postprob &lt;- bicGLMex[['postprob']])
bicGLMex['mle']

# Simulate for the model data 
bicGLMsim &lt;- simulate(bicGLMex, nsim=2, seed=1)  

# Simulate for new data
newDat &lt;- data.frame(x=3:4, 
      row.names=paste0('f', 3:4))
bicGLMsin &lt;- simulate(bicGLMex, nsim=3, seed=2, 
                      newdata=newDat)
                      
# Refit with bic.glm.matrix and confirm 
# that simulate returns the same answers

bicGLMat &lt;- bic.glm(as.matrix(PoisRegDat['x']), 
                         PoisRegDat[, 'y'], poisson)
bicGLMatsim &lt;- simulate(bicGLMat, nsim=3, seed=2, 
                      newdata=newDat)
                      
all.equal(bicGLMsin, bicGLMatsim)                      


# The same problem using bic.glm.formula                  
bicGLMfmla &lt;- bic.glm(y ~ x, PoisRegDat, poisson)
bicGLMfmlsim &lt;- simulate(bicGLMfmla, nsim=3, seed=2, 
                      newdata=newDat)
                      
all.equal(bicGLMsin, bicGLMfmlsim)                      

                      
##
## 2a.  Compute the correct answers manually 
##
GLMex1 &lt;- glm(y~x, poisson, PoisRegDat)
GLMex0 &lt;- glm(y~1, poisson, PoisRegDat)

postProb &lt;- bicGLMfmla$postprob
nComp &lt;- length(postProb)
newMat &lt;- model.matrix(~., newDat)
set.seed(2)
(rmdl &lt;- sample(1:nComp, 3, TRUE, 
          postprob))
GLMsim. &lt;- matrix(NA, 2, 3)
dimnames(GLMsim.) &lt;- list(
  rownames(newMat), 
  paste0('sim_', 1:3) )
          
sim1 &lt;- mvtnorm::rmvnorm(2, coef(GLMex1), 
                         vcov(GLMex1))
sim0 &lt;- mvtnorm::rmvnorm(1, coef(GLMex0), 
                         vcov(GLMex0))
GLMsim.[, rmdl==1] &lt;- tcrossprod(newMat, sim1)
GLMsim.[, rmdl==2] &lt;- tcrossprod(
          newMat[, 1, drop=FALSE], sim0)
                      

all.equal(bicGLMsin[[2]], data.frame(GLMsim.), 
    tolerance=4*sqrt(.Machine$double.eps))
# tcrossprod numeric precision is mediocre 
# for the constant model in this example.  

</code></pre>


</div>