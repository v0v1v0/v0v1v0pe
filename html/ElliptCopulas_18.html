<div class="container">

<table style="width: 100%;"><tr>
<td>EllDistrEst</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nonparametric estimation of the density generator of an elliptical distribution</h2>

<h3>Description</h3>

<p>This function uses Liebscher's algorithm to estimate the density generator
of an elliptical distribution by kernel smoothing.
A continuous elliptical distribution has a density of the form
</p>
<p style="text-align: center;"><code class="reqn">f_X(x) = {|\Sigma|}^{-1/2}
g\left( (x-\mu)^\top \, \Sigma^{-1} \, (x-\mu) \right),
</code>
</p>

<p>where <code class="reqn">x \in \mathbb{R}^d</code>,
<code class="reqn">\mu \in \mathbb{R}^d</code> is the mean,
<code class="reqn">\Sigma</code> is a <code class="reqn">d \times d</code> positive-definite matrix
and a function <code class="reqn">g: \mathbb{R}_+ \rightarrow \mathbb{R}_+</code>, called the
density generator of <code class="reqn">X</code>.
The goal is to estimate <code class="reqn">g</code> at some point <code class="reqn">\xi</code>, by
</p>
<p style="text-align: center;"><code class="reqn">
\widehat{g}_{n,h,a}(\xi)
:= \dfrac{\xi^{\frac{-d+2}{2}} \psi_a'(\xi)}{n h s_d}
\sum_{i=1}^n
  K\left( \dfrac{ \psi_a(\xi) - \psi_a(\xi_i) }{h} \right)
+ K\left( \dfrac{ \psi_a(\xi) + \psi_a(\xi_i) }{h} \right),
</code>
</p>

<p>where
<code class="reqn">s_d := \pi^{d/2} / \Gamma(d/2)</code>,
<code class="reqn">\Gamma</code> is the Gamma function,
<code class="reqn">h</code> and <code class="reqn">a</code> are tuning parameters (respectively the bandwidth and a
parameter controlling the bias at <code class="reqn">\xi = 0</code>),
<code class="reqn">\psi_a(\xi) := -a + (a^{d/2} + \xi^{d/2})^{2/d},</code>
<code class="reqn">\xi \in \mathbb{R}</code>, <code class="reqn">K</code> is a kernel function and
<code class="reqn">\xi_i := (X_i - \mu)^\top \, \Sigma^{-1} \, (X_i - \mu),
</code>
for a sample <code class="reqn">X_1, \dots, X_n</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">EllDistrEst(
  X,
  mu = 0,
  Sigma_m1 = diag(d),
  grid,
  h,
  Kernel = "epanechnikov",
  a = 1,
  mpfr = FALSE,
  precBits = 100,
  dopb = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a matrix of size <code class="reqn">n \times d</code>, assumed to be <code class="reqn">n</code> i.i.d. observations
(rows) of a <code class="reqn">d</code>-dimensional elliptical distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>mean of X. This can be the true value or an estimate. It must be
a vector of dimension <code class="reqn">d</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma_m1</code></td>
<td>
<p>inverse of the covariance matrix of X.
This can be the true value or an estimate. It must be
a matrix of dimension <code class="reqn">d \times d</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>grid of values of <code class="reqn">\xi</code> at which we want to estimate the
density generator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>bandwidth of the kernel. Can be either a number or a vector of the
size <code>length(grid)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kernel</code></td>
<td>
<p>name of the kernel. Possible choices are
<code>"gaussian"</code>, <code>"epanechnikov"</code>, <code>"triangular"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>tuning parameter to improve the performance at 0.
Can be either a number or a vector of the
size <code>length(grid)</code>. If this is a vector, the code will need to allocate
a matrix of size <code>nrow(X) * length(grid)</code> which can be prohibitive in
some cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mpfr</code></td>
<td>
<p>if <code>mpfr = TRUE</code>, multiple precision floating point is used
via the package Rmpfr.
This allows for a higher (numerical) accuracy, at the expense of computing time.
It is recommended to use this option for higher dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precBits</code></td>
<td>
<p>number of precBits used for floating point precision
(only used if <code>mpfr = TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dopb</code></td>
<td>
<p>a Boolean value.
If <code>dopb = TRUE</code>, a progress bar is displayed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>the values of the density generator of the elliptical copula,
estimated at each point of the <code>grid</code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Derumigny, Rutger van der Spek
</p>


<h3>References</h3>

<p>Liebscher, E. (2005).
A semiparametric density estimator based on elliptical distributions.
Journal of Multivariate Analysis, 92(1), 205.
<a href="https://doi.org/10.1016/j.jmva.2003.09.007">doi:10.1016/j.jmva.2003.09.007</a>
</p>
<p>The function <code class="reqn">\psi_a</code> is introduced in Liebscher (2005), Example p.210.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>EllDistrSim</code> for the simulation of elliptical distribution samples.
</p>
</li>
<li> <p><code>estim_tilde_AMSE</code> for the estimation of a component of
the asymptotic mean-square error (AMSE) of this estimator
<code class="reqn">\widehat{g}_{n,h,a}(\xi)</code>, assuming <code class="reqn">h</code> has been optimally chosen.
</p>
</li>
<li> <p><code>EllDistrEst.adapt</code> for the adaptive nonparametric estimation
of the generator of an elliptical distribution.
</p>
</li>
<li> <p><code>EllDistrDerivEst</code> for the nonparametric estimation of the
derivatives of the generator.
</p>
</li>
<li> <p><code>EllCopEst</code> for the estimation of elliptical copulas
density generators.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Comparison between the estimated and true generator of the Gaussian distribution
X = matrix(rnorm(500*3), ncol = 3)
grid = seq(0,5,by=0.1)
g_3 = EllDistrEst(X = X, grid = grid, a = 0.7, h=0.05)
g_3mpfr = EllDistrEst(X = X, grid = grid, a = 0.7, h=0.05,
                      mpfr = TRUE, precBits = 20)
plot(grid, g_3, type = "l")
lines(grid, exp(-grid/2)/(2*pi)^{3/2}, col = "red")

# In higher dimensions

d = 250
X = matrix(rnorm(500*d), ncol = d)
grid = seq(0, 400, by = 25)
true_g = exp(-grid/2) / (2*pi)^{d/2}

g_d = EllDistrEst(X = X, grid = grid, a = 100, h=40)

g_dmpfr = EllDistrEst(X = X, grid = grid, a = 100, h=40,
                      mpfr = TRUE, precBits = 10000)
ylim = c(min(c(true_g, as.numeric(g_dmpfr[which(g_dmpfr&gt;0)]))),
         max(c(true_g, as.numeric(g_dmpfr)), na.rm=TRUE) )
plot(grid, g_dmpfr, type = "l", col = "red", ylim = ylim, log = "y")
lines(grid, g_d, type = "l")
lines(grid, true_g, col = "blue")


</code></pre>


</div>