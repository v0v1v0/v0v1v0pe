<div class="container">

<table style="width: 100%;"><tr>
<td>vorobT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Vorob'ev computations</h2>

<h3>Description</h3>

<p>Compute Vorob'ev threshold, expectation and deviation. Also, displaying the
symmetric deviation function is possible.  The symmetric deviation
function is the probability for a given target in the objective space to
belong to the symmetric difference between the Vorob'ev expectation and a
realization of the (random) attained set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">vorobT(x, reference)

vorobDev(x, VE, reference)

symDifPlot(
  x,
  VE,
  threshold,
  nlevels = 11,
  ve.col = "blue",
  xlim = NULL,
  ylim = NULL,
  legend.pos = "topright",
  main = "Symmetric deviation function",
  col.fun = function(n) gray(seq(0, 0.9, length.out = n)^2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either a matrix of data values, or a data frame, or a list of data
frames of exactly three columns.  The third column gives the set (run,
sample, ...) identifier.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>
<p>(<code>numeric()</code>) <br> Reference point as a vector of numerical values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VE, threshold</code></td>
<td>
<p>Vorob'ev expectation and threshold, e.g., as returned
by <code>vorobT()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlevels</code></td>
<td>
<p>number of levels in which is divided the range of the
symmetric deviation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ve.col</code></td>
<td>
<p>plotting parameters for the Vorob'ev expectation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim, ylim, main</code></td>
<td>
<p>Graphical parameters, see
<code>plot.default()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.pos</code></td>
<td>
<p>the position of the legend, see
<code>legend()</code>. A value of <code>"none"</code> hides the legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.fun</code></td>
<td>
<p>function that creates a vector of <code>n</code> colors, see
<code>heat.colors()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>vorobT</code> returns a list with elements <code>threshold</code>,
<code>VE</code>, and <code>avg_hyp</code> (average hypervolume)
</p>
<p><code>vorobDev</code> returns the Vorob'ev deviation.
</p>


<h3>Author(s)</h3>

<p>Mickael Binois
</p>


<h3>References</h3>

<p>M Binois, D Ginsbourger, O Roustant (2015).
“Quantifying uncertainty on Pareto fronts with Gaussian process conditional simulations.”
<em>European Journal of Operational Research</em>, <b>243</b>(2), 386–394.
doi: <a href="https://doi.org/10.1016/j.ejor.2014.07.032">10.1016/j.ejor.2014.07.032</a>.
</p>
<p>C. Chevalier (2013), Fast uncertainty reduction strategies relying on
Gaussian process models, University of Bern, PhD thesis.
</p>
<p>I. Molchanov (2005), Theory of random sets, Springer.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(CPFs)
res &lt;- vorobT(CPFs, reference = c(2, 200))
print(res$threshold)

## Display Vorob'ev expectation and attainment function
# First style
eafplot(CPFs[,1:2], sets = CPFs[,3], percentiles = c(0, 25, 50, 75, 100, res$threshold),
        main = substitute(paste("Empirical attainment function, ",beta,"* = ", a, "%"),
                          list(a = formatC(res$threshold, digits = 2, format = "f"))))

# Second style
eafplot(CPFs[,1:2], sets = CPFs[,3], percentiles = c(0, 20, 40, 60, 80, 100),
        col = gray(seq(0.8, 0.1, length.out = 6)^0.5), type = "area", 
        legend.pos = "bottomleft", extra.points = res$VE, extra.col = "cyan",
        extra.legend = "VE", extra.lty = "solid", extra.pch = NA, extra.lwd = 2,
        main = substitute(paste("Empirical attainment function, ",beta,"* = ", a, "%"),
                          list(a = formatC(res$threshold, digits = 2, format = "f"))))

# Now print Vorob'ev deviation
VD &lt;- vorobDev(CPFs, res$VE, reference = c(2, 200))
print(VD)
# Now display the symmetric deviation function.
symDifPlot(CPFs, res$VE, res$threshold, nlevels = 11)
# Levels are adjusted automatically if too large.
symDifPlot(CPFs, res$VE, res$threshold, nlevels = 200, legend.pos = "none")

# Use a different palette.
symDifPlot(CPFs, res$VE, res$threshold, nlevels = 11, col.fun = heat.colors)
</code></pre>


</div>