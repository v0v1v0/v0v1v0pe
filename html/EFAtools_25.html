<div class="container">

<table style="width: 100%;"><tr>
<td>PARALLEL</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parallel analysis</h2>

<h3>Description</h3>

<p>Various methods for performing parallel analysis. This function uses
future_lapply for which a parallel processing plan can
be selected. To do so, call <code>library(future)</code> and, for example,
<code>plan(multisession)</code>; see examples.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PARALLEL(
  x = NULL,
  N = NA,
  n_vars = NA,
  n_datasets = 1000,
  percent = 95,
  eigen_type = c("PCA", "SMC", "EFA"),
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall"),
  decision_rule = c("means", "percentile", "crawford"),
  n_factors = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>matrix or data.frame. The real data to compare the simulated eigenvalues
against. Must not contain variables of classes other than numeric. Can be a
correlation matrix or raw data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>numeric. The number of cases / observations to simulate. Only has to
be specified if <code>x</code> is either a correlation matrix or <code>NULL</code>. If
x contains raw data, <code>N</code> is found from the dimensions of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_vars</code></td>
<td>
<p>numeric. The number of variables / indicators to simulate.
Only has to be specified if <code>x</code> is left as <code>NULL</code> as otherwise the
dimensions are taken from <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_datasets</code></td>
<td>
<p>numeric. The number of datasets to simulate. Default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>percent</code></td>
<td>
<p>numeric. The percentile to take from the simulated eigenvalues.
Default is 95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigen_type</code></td>
<td>
<p>character. On what the eigenvalues should be found. Can be
either "SMC", "PCA", or "EFA". If using "SMC", the diagonal of the correlation
matrix is replaced by the squared multiple correlations (SMCs) of the
indicators. If using "PCA", the diagonal values of the correlation matrices
are left to be 1. If using "EFA", eigenvalues are found on the correlation
matrices with the final communalities of an EFA solution as diagonal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use</code></td>
<td>
<p>character. Passed to <code>stats::cor</code> if raw data
is given as input. Default is "pairwise.complete.obs".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor_method</code></td>
<td>
<p>character. Passed to <code>stats::cor</code>
Default is "pearson".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decision_rule</code></td>
<td>
<p>character. Which rule to use to determine the number of
factors to retain. Default is <code>"means"</code>, which will use the average
simulated eigenvalues. <code>"percentile"</code>, uses the percentiles specified
in percent. <code>"crawford"</code> uses the 95th percentile for the first factor
and the mean afterwards (based on Crawford et al, 2010).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_factors</code></td>
<td>
<p>numeric. Number of factors to extract if "EFA" is included in
<code>eigen_type</code>. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>EFA</code>. For example,
the extraction method can be changed here (default is "PAF"). PAF is more
robust, but it will take longer compared to the other estimation methods
available ("ML" and "ULS").</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Parallel analysis (Horn, 1965) compares the eigenvalues obtained from
the sample
correlation matrix against those of null model correlation matrices (i.e.,
with uncorrelated variables) of the same sample size. This way, it accounts
for the variation in eigenvalues introduced by sampling error and thus
eliminates the main problem inherent in the Kaiser-Guttman criterion
(<code>KGC</code>).
</p>
<p>Three different ways of finding the eigenvalues under the factor model are
implemented, namely "SMC", "PCA", and "EFA". PCA leaves the diagonal elements
of the correlation matrix as they are and is thus equivalent to what is done
in PCA. SMC uses squared multiple correlations as communality estimates with
which the diagonal of the correlation matrix is replaced. Finally, EFA performs
an <code>EFA</code> with one factor (can be adapted to more factors) to estimate
the communalities and based on the correlation matrix with these as diagonal
elements, finds the eigenvalues.
</p>
<p>Parallel analysis is often argued to be one of the most accurate factor
retention criteria. However, for highly correlated
factor structures it has been shown to underestimate the correct number of
factors. The reason for this is that a null model (uncorrelated variables)
is used as reference. However, when factors are highly correlated, the first
eigenvalue will be much larger compared to the following ones, as
later eigenvalues are conditional on the earlier ones in the sequence and thus
the shared variance is already accounted in the first eigenvalue (e.g.,
Braeken &amp; van Assen, 2017).
</p>
<p>The <code>PARALLEL</code> function can also be called together with other factor
retention criteria in the <code>N_FACTORS</code> function.
</p>


<h3>Value</h3>

<p>A list of class PARALLEL containing the following objects
</p>
<table>
<tr style="vertical-align: top;">
<td><code>eigenvalues_PCA</code></td>
<td>
<p>A matrix containing the eigenvalues of the real and the simulated data found with eigen_type = "PCA"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigenvalues_SMC</code></td>
<td>
<p>A matrix containing the eigenvalues of the real and the simulated data found with eigen_type = "SMC"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigenvalues_EFA</code></td>
<td>
<p>A matrix containing the eigenvalues of the real and the simulated data found with eigen_type = "EFA"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_fac_PCA</code></td>
<td>
<p>The number of factors to retain according to the parallel procedure with eigen_type = "PCA".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_fac_SMC</code></td>
<td>
<p>The number of factors to retain according to the parallel procedure with eigen_type = "SMC".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_fac_EFA</code></td>
<td>
<p>The number of factors to retain according to the parallel procedure with eigen_type = "EFA".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>settings</code></td>
<td>
<p>A list of control settings used in the print function.</p>
</td>
</tr>
</table>
<h3>Source</h3>

<p>Braeken, J., &amp; van Assen, M. A. (2017). An empirical Kaiser criterion.
Psychological Methods, 22, 450 – 466. http://dx.doi.org/10.1037/ met0000074
</p>
<p>Crawford, A. V., Green, S. B., Levy, R., Lo, W. J., Scott, L.,
Svetina, D., &amp; Thompson, M. S. (2010). Evaluation of parallel analysis methods
for determining the number of factors. Educational and Psychological
Measurement, 70(6), 885-901.
</p>
<p>Horn, J. L. (1965). A rationale and test for the number of factors in
factor analysis. Psychometrika, 30(2), 179–185. doi: 10.1007/BF02289447
</p>


<h3>See Also</h3>

<p>Other factor retention criteria: <code>CD</code>, <code>EKC</code>,
<code>HULL</code>, <code>KGC</code>, <code>SMT</code>
</p>
<p><code>N_FACTORS</code> as a wrapper function for this and all the
above-mentioned factor retention criteria.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# example without real data
pa_unreal &lt;- PARALLEL(N = 500, n_vars = 10)

# example with correlation matrix with all eigen_types and PAF estimation
pa_paf &lt;- PARALLEL(test_models$case_11b$cormat, N = 500)

# example with correlation matrix with all eigen_types and ML estimation
# this will be faster than the above with PAF)
pa_ml &lt;- PARALLEL(test_models$case_11b$cormat, N = 500, method = "ML")


## Not run: 
# for parallel computation
future::plan(future::multisession)
pa_faster &lt;- PARALLEL(test_models$case_11b$cormat, N = 500)

## End(Not run)
</code></pre>


</div>