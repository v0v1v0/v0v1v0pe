<div class="container">

<table style="width: 100%;"><tr>
<td>exact_extract</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract or summarize values from rasters</h2>

<h3>Description</h3>

<p>Extracts the values of cells in a raster (<code>RasterLayer</code>, <code>RasterStack</code>
<code>RasterBrick</code>, or <code>SpatRaster</code>) that are covered by polygons in a
simple feature collection (<code>sf</code> or <code>sfc</code>) or <code>SpatialPolygonsDataFrame</code>.
Returns either a summary of the extracted values or the extracted values
themselves.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'Raster,sf'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'Raster,SpatialPolygonsDataFrame'
exact_extract(x, y, ...)

## S4 method for signature 'Raster,SpatialPolygons'
exact_extract(x, y, ...)

## S4 method for signature 'Raster,sfc_MULTIPOLYGON'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'Raster,sfc_POLYGON'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'Raster,sfc_GEOMETRY'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'Raster,sfc_GEOMETRYCOLLECTION'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'SpatRaster,sf'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'SpatRaster,SpatialPolygonsDataFrame'
exact_extract(x, y, ...)

## S4 method for signature 'SpatRaster,SpatialPolygons'
exact_extract(x, y, ...)

## S4 method for signature 'SpatRaster,sfc_MULTIPOLYGON'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'SpatRaster,sfc_POLYGON'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'SpatRaster,sfc_GEOMETRY'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'SpatRaster,sfc_GEOMETRYCOLLECTION'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>RasterLayer</code>, <code>RasterStack</code>, <code>RasterBrick</code>, or <code>SpatRaster</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a <code>sf</code>, <code>sfc</code>, <code>SpatialPolygonsDataFrame</code>, or <code>SpatialPolygons</code>
object with polygonal geometries</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>an optional function or character vector, as described below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to pass to <code>fun</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a weighting raster to be used with the <code>weighted_mean</code>
and <code>weighted_sum</code> summary operations or a user-defined
summary function. When <code>weights</code> is set to <code>'area'</code>, the
cell areas of <code>x</code> will be calculated and used as weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>append_cols</code></td>
<td>
<p>when <code>fun</code> is not <code>NULL</code>, an optional character vector
of columns from <code>y</code> to be included in returned data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coverage_area</code></td>
<td>
<p>if <code>TRUE</code>, output pixel <code>coverage_area</code>
instead of <code>coverage_fraction</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default_value</code></td>
<td>
<p>an optional value to use instead of <code>NA</code> in <code>x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default_weight</code></td>
<td>
<p>an optional value to use instead of <code>NA</code> in <code>weights</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_area</code></td>
<td>
<p>if <code>TRUE</code>, and <code>fun</code> is <code>NULL</code>, augment
the data frame for each feature with a column
for the cell area. If the units of the raster CRS are
degrees, the area in square meters will be calculated
based on a spherical approximation of Earth. Otherwise,
a Cartesian area will be calculated (and will be the
same for all pixels.) If <code>TRUE</code> and <code>fun</code> is
not <code>NULL</code>, add <code>area</code> to the data frame passed
to <code>fun</code> for each feature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_cell</code></td>
<td>
<p>if <code>TRUE</code>, and <code>fun</code> is <code>NULL</code>, augment
the data frame for each feature with a column
for the cell index (<code>cell</code>). If <code>TRUE</code> and
<code>fun</code> is not <code>NULL</code>, add <code>cell</code> to the
data frame passed to <code>fun</code> for each feature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_cols</code></td>
<td>
<p>an optional character vector of column names in
<code>y</code> to be added to the data frame for each
feature that is either returned (when <code>fun</code> is
<code>NULL</code>) or passed to <code>fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_xy</code></td>
<td>
<p>if <code>TRUE</code>, and <code>fun</code> is <code>NULL</code>, augment
the returned data frame for each feature with columns
for cell center coordinates (<code>x</code> and <code>y</code>). If
<code>TRUE</code> and <code>fun</code> is not <code>NULL</code>, add
<code>x</code> and <code>y</code> to the data frame passed to <code>fun</code>
for each feature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force_df</code></td>
<td>
<p>always return a data frame instead of a vector, even if
<code>x</code> has only one layer and <code>fun</code> has length 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full_colnames</code></td>
<td>
<p>include the names of <code>x</code> and <code>weights</code> in
the names of the data frame for each feature, even if
<code>x</code> or <code>weights</code> has only one layer.
This is useful when the results of multiple
calls to <code>exact_extract</code> are combined with
<code>cbind</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stack_apply</code></td>
<td>
<p>if <code>TRUE</code>, apply <code>fun</code> independently to
each layer or <code>x</code> (and its corresponding layer
of <code>weights</code>, if provided.) The number of
layers in <code>x</code> and <code>weights</code> must equal
each other or <code>1</code>, in which case the
single layer raster will be recycled.
If <code>FALSE</code>, apply <code>fun</code> to all layers of
<code>x</code> (and <code>weights</code>) simultaneously.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summarize_df</code></td>
<td>
<p>pass values, coverage fraction/area, and weights to
<code>fun</code> as a single data frame instead of
separate arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>quantiles to be computed when <code>fun = 'quantile'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>if <code>TRUE</code>, display a progress bar during processing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_cells_in_memory</code></td>
<td>
<p>the maximum number of raster cells to load at
a given time when using a named summary operation
for <code>fun</code> (as opposed to a function defined using
R code). If a polygon covers more than <code>max_cells_in_memory</code>
raster cells, it will be processed in multiple chunks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_compat_tol</code></td>
<td>
<p>require value and weight grids to align within
<code>grid_compat_tol</code> times the smaller of the two
grid resolutions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colname_fun</code></td>
<td>
<p>an optional function used to construct column names.
Should accept arguments <code>values</code> (name of value layer),
<code>weights</code> (name of weight layer), <code>fun_name</code> (value of
<code>fun</code>), <code>fun_value</code> (value associated with <code>fun</code>, for
<code style="white-space: pre;">⁠fun %in% c('quantile', 'frac', 'weighted_frac)⁠</code>
<code>nvalues</code> (number of value layers), <code>weights</code>
(number of weight layers)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>exact_extract</code> extracts the values of cells in a raster that are covered
by polygonal features in a simple feature collection (<code>sf</code> or <code>sfc</code>) or
<code>SpatialPolygonDataFrame</code>, as well as the fraction or area of each cell that
is covered by the feature. Pixels covered by all parts of the polygon are
considered. If an (invalid) multipart polygon covers the same pixels more
than once, the pixel may have a coverage fraction greater than one.
</p>
<p>The function can either return pixel values directly to the caller, or can
return the result of a predefined summary operation or user-defined R
function applied to the values. These three approaches are described in the
subsections below.
</p>


<h4>Returning extracted values directly</h4>

<p>If <code>fun</code> is not specified, <code>exact_extract</code> will return a list with
one data frame for each feature in the input feature collection. The data
frame will contain a column with cell values from each layer in the input
raster (and optional weighting raster) and a column indicating
the fraction or area of the cell that is covered by the polygon.
</p>
<p>If the input rasters have only one layer, the value and weight columns in the
data frame will be named <code>values</code> or <code>weights</code>. When the input rasters have
more than one layer, the columns will be named according to <code>names(x)</code> and
<code>names(weights)</code>. The column containing pixel coverage will be called
<code>coverage_fraction</code> when <code>coverage_area = FALSE</code>, or <code>coverage_area</code> when
<code>coverage_area = TRUE</code>. Additional columns can be added to the returned data
frames with the <code>include_area</code>, <code>include_cell</code>, and <code>include_xy</code> arguments.
</p>
<p>If the output data frames for multiple features are to be combined (e.g.,
with <code>rbind</code>), it may be useful to include identifying column(s) from the
input features in the returned data frames using <code>include_cols</code>.
</p>



<h4>Predefined summary operations</h4>

<p>Often the individual pixel values are not needed; only one or more summary
statistics (e.g., mean, sum) is required for each feature. Common summary
statistics can be calculated by <code>exact_extract</code> directly using a predefined
summary operation. Where possible, this approach is advantageous because it
allows the package to calculate the statistics incrementally, avoiding the
need to store all pixel values in memory at the same time. This allows the
package to process arbitrarily large data with a small amount of memory. (The
<code>max_pixels_in_memory</code> argument can be used to fine-tune the amount of memory
made available to <code>exact_extract</code>.)
</p>
<p>To summarize pixel values using a predefined summary option, <code>fun</code> should be
set to a character vector of one or more operation names. If the input raster
has a single layer and a single summary operation is specified,
<code>exact_extract</code> will return a vector with the result of the summary operation
for each feature in the input. If the input raster has multiple layers, or if
multiple summary operations are specified, <code>exact_extract</code> will return a data
frame with a row for each feature and a column for each summary operation /
layer combination. (The <code>force_df</code> option can be used to always return a data
frame instead of a vector.)
</p>
<p>The following summary operations are supported:
</p>

<ul>
<li> <p><code>min</code> - the minimum non-<code>NA</code> value in any raster cell wholly or
partially covered by the polygon
</p>
</li>
<li> <p><code>max</code> - the maximum non-<code>NA</code> value in any raster cell wholly or
partially covered by the polygon
</p>
</li>
<li> <p><code>count</code> - the sum of fractions of raster cells with non-<code>NA</code>
values covered by the polygon
</p>
</li>
<li> <p><code>sum</code>   - the sum of non-<code>NA</code> raster cell values, multiplied by
the fraction of the cell that is covered by the polygon
</p>
</li>
<li> <p><code>mean</code> - the mean cell value, weighted by the fraction of each cell
that is covered by the polygon
</p>
</li>
<li> <p><code>median</code> - the median cell value, weighted by the fraction of each cell
that is covered by the polygon
</p>
</li>
<li> <p><code>quantile</code> - arbitrary quantile(s) of cell values, specified in
<code>quantiles</code>, weighted by the fraction of each cell that is
covered by the polygon
</p>
</li>
<li> <p><code>mode</code> - the most common cell value, weighted by the fraction of
each cell that is covered by the polygon. Where multiple
values occupy the same maximum number of weighted cells,
the largest value will be returned.
</p>
</li>
<li> <p><code>majority</code> - synonym for <code>mode</code>
</p>
</li>
<li> <p><code>minority</code> - the least common cell value, weighted by the fraction
of each cell that is covered by the polygon. Where
multiple values occupy the same minimum number of
weighted cells, the smallest value will be returned.
</p>
</li>
<li> <p><code>variety</code> - the number of distinct values in cells that are wholly or
partially covered by the polygon.
</p>
</li>
<li> <p><code>variance</code> - the population variance of cell values, weighted by the
fraction of each cell that is covered by the polygon.
</p>
</li>
<li> <p><code>stdev</code> - the population standard deviation of cell values, weighted by
the fraction of each cell that is covered by the polygon.
</p>
</li>
<li> <p><code>coefficient_of_variation</code> - the population coefficient of variation of
cell values, weighted by the fraction of each
cell that is covered by the polygon.
</p>
</li>
<li> <p><code>weighted_mean</code> - the mean cell value, weighted by the product of
the fraction of each cell covered by the polygon
and the value of a second weighting raster provided
as <code>weights</code>
</p>
</li>
<li> <p><code>weighted_sum</code> - the sum of defined raster cell values, multiplied by
the fraction of each cell that is covered by the polygon
and the value of a second weighting raster provided
as <code>weights</code>
</p>
</li>
<li> <p><code>weighted_stdev</code> - the population standard deviation of cell values,
weighted by the product of the fraction of each cell
covered by the polygon and the value of a second
weighting raster provided as <code>weights</code>
</p>
</li>
<li> <p><code>weighted_variance</code> - the population variance of cell values, weighted by
the product of the fraction of each cell covered by
the polygon and the value of a second weighting
raster provided as <code>weights</code>
</p>
</li>
<li> <p><code>frac</code> - returns one column for each possible value of <code>x</code>, with the
the fraction of defined raster cells that are equal to that
value.
</p>
</li>
<li> <p><code>weighted_frac</code> - returns one column for each possible value of <code>x</code>,
with the fraction of defined cells that are equal
to that value, weighted by <code>weights.</code>
</p>
</li>
</ul>
<p>In all of the summary operations, <code>NA</code> values in the the primary raster (<code>x</code>)
raster are ignored (i.e., <code>na.rm = TRUE</code>.) If <code>NA</code> values occur in the
weighting raster, the result of the weighted operation will be <code>NA</code>. <code>NA</code>
values in both <code>x</code> and <code>weights</code> can be replaced on-the-fly using the
<code>default_value</code> and <code>default_weight</code> arguments.
</p>



<h4>User-defined summary functions</h4>

<p>If no predefined summary operation is suitable, a user-defined R function may
be provided as <code>fun</code>. The function will be called once for each feature and
must return either a single value or a data frame. The results of the
function for each feature will be combined and returned by <code>exact_extract</code>.
</p>
<p>The simplest way to write a summary function is to set
argument <code>summarize_df = TRUE</code>. (For backwards compatibility, this is not the
default.) In this mode, the summary function takes the signature
<code style="white-space: pre;">⁠function(df, ...)⁠</code> where <code>df</code> is the same data frame that would be returned
by <code>exact_extract</code> with <code>fun = NULL</code>.
</p>
<p>With <code>summarize_df = FALSE</code>, the function must have the signature
<code style="white-space: pre;">⁠function(values, coverage_fractions, ...)⁠</code> when weights are not used, and
<code style="white-space: pre;">⁠function(values, coverage_fractions, weights, ...)⁠</code> when weights are used.
If the value and weight rasters each have a single layer, the function arguments
will be vectors; if either has multiple layers, the function arguments will
be data frames, with column names taken from the names of the value/weight
rasters. Values brought in through the <code>include_xy</code>, <code>include_area</code>,
<code>include_cell</code>, and <code>include_cols</code> arguments will be added to the <code>values</code>
data frame. For most applications, it is simpler to set <code>summarize_df = TRUE</code>
and work with all inputs in a single data frame.
</p>



<h3>Value</h3>

<p>a vector, data frame, or list of data frames, depending on the type
of <code>x</code> and the value of <code>fun</code> (see Details)
</p>


<h3>Examples</h3>

<pre><code class="language-R">rast &lt;- raster::raster(matrix(1:100, ncol=10), xmn=0, ymn=0, xmx=10, ymx=10)
poly &lt;- sf::st_as_sfc('POLYGON ((2 2, 7 6, 4 9, 2 2))')

# named summary operation on RasterLayer, returns vector
exact_extract(rast, poly, 'mean')

# two named summary operations on RasterLayer, returns data frame
exact_extract(rast, poly, c('min', 'max'))

# named summary operation on RasterStack, returns data frame
stk &lt;- raster::stack(list(a=rast, b=sqrt(rast)))
exact_extract(stk, poly, 'mean')

# named weighted summary operation, returns vector
weights &lt;- raster::raster(matrix(runif(100), ncol=10), xmn=0, ymn=0, xmx=10, ymx=10)
exact_extract(rast, poly, 'weighted_mean', weights=weights)

# custom summary function, returns vector
exact_extract(rast, poly, function(value, cov_frac) length(value[cov_frac &gt; 0.9]))

</code></pre>


</div>