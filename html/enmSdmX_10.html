<div class="container">

<table style="width: 100%;"><tr>
<td>coordImprecision</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate the precision of a geographic coordinate</h2>

<h3>Description</h3>

<p>This function calculates the imprecision of geographic coordinates due to rounded coordinate values. See <em>Details</em> for an explanation of how this is calculated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">coordImprecision(x, dms = FALSE, epsilon = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Spatial points represented as a <code>SpatVector</code> or <code>sf</code> object. Alternatively, this can also be a data frame or matrix, in which the first two columns must represent longitude and latitude (in that order). If <code>x</code> is a matrix or data frame, the coordinates are assumed to be unprojected (WGS84).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dms</code></td>
<td>
<p>Logical, if <code>FALSE</code> (default), it is assumed that the original format in which coordinate were reported is in decimal notation. If <code>TRUE</code>, then it will be calculated assuming the coordinate were originally in degrees-minutes-seconds format.  If you do not know the original format, the less presumptive approach is to calculate coordinate imprecision twice with or without <code>dm = TRUE</code>, and use the larger of the two values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Zero or positive integer, number of digits to which to round seconds value if <code>dms</code> is <code>TRUE</code>. Ignored if <code>dms</code> is <code>FALSE</code>. This is used to accommodate inexact integer values when converting from DMS to decimal. For example, -108.932222 converted to DMS format is 108deg 55min 7.9992sec, but if <code>epsilon</code> = 2 then it would be converted to 108deg 55min 08sec.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For coordinates originally reported in decimal notation, coordinate imprecision is <em>half</em> the distance between the two opposing corners on a bounding box whose size is based on the number of significant digits in the coordinates. This box is defined by 1) finding the maximum number of significant digits after the decimal in the longitude/latitude pair; 2) adding/subtracting 5 to the decimal place that falls just after this; and 3) calculating the distance between these points then dividing by 2. For example, if longitude is 82.37 and latitude 45.8 then the number of significant digits after the decimal place is 2 and 1, respectively so 2 is used on the assumption that latitude is measured to the nearest 100th degree. The precision is then the distance between the point pairs (82.37 - 0.05 = 82.365, 45.8 - 0.05 = 45.795) and (82.37 + 0.05 = 82.375, 45.8 + 0.05 = 45.805). <br><br></p>
<p>For coordinates originally reported in degree-minus-second (DMS) format, the bounding box is defined by adding/subtracting 0.5 units (degrees, minutes, or seconds, depending on the smallest non-zero unit reported) from the coordinate. For example, if longitude is 90deg 00min 00sec and latitude is 37deg 37min 37sec, then the bounding box will be defined by adding/subtracting 0.5 arcsec to the coordinates.
</p>


<h3>Value</h3>

<p>Numeric values (by default in units of meters).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# coarse-precision cases
long &lt;-	c(45, 45.1, 45.1)
lat &lt;-  c(45, 45.1, 45)
ll &lt;- cbind(long, lat)
precision_m &lt;- coordImprecision(ll)
cbind(ll, precision_m)

# fine-precision cases
long &lt;-	rep(45, 8)
lat &lt;-  c(45, 45.1, 45.11, 45.111, 45.1111, 45.11111, 45.111111, 45.1111111)
ll &lt;- cbind(long, lat)
precision_m &lt;- coordImprecision(ll)
cbind(ll, precision_m)

# precision varies with latitude
long &lt;- rep(45, 181)
lat &lt;- seq(-90, 90)
ll &lt;- cbind(long, lat)
precision_m &lt;- coordImprecision(ll)
cbind(ll, precision_m)
plot(lat, precision_m / 1000, xlab='Latitude', ylab='Precision (km)')

# dateline/polar cases
long &lt;-	c(0, 180, 45, 45)
lat &lt;-  c(45, 45, 90, -90)
ll &lt;- cbind(long, lat)
precision_m &lt;- coordImprecision(ll)
cbind(ll, precision_m)

# original coordinates in degrees-minutes-seconds format
longDD &lt;- c(90, 90, 90, 90, 90, 90)
longMM &lt;- c(0, 0, 0, 11, 11, 0)
longSS &lt;- c(0, 0, 0, 0, 52, 52)
latDD &lt;- c(38, 38, 38, 38, 38, 38)
latMM &lt;- c(0, 37, 37, 37, 37, 0)
latSS &lt;- c(0, 0, 38, 38, 38, 0)
longHemis &lt;- rep('W', 6)
latHemis &lt;- rep('N', 6)
longDec &lt;- dmsToDecimal(longDD, longMM, longSS, longHemis)
latDec &lt;- dmsToDecimal(latDD, latMM, latSS, latHemis)
decimal &lt;- cbind(longDec, latDec)
(decImp &lt;- coordImprecision(decimal))
(dmsImp &lt;- coordImprecision(decimal, dms=TRUE))

# What if we do not know if coordinates were originally reported in
# decimal or degrees-minutes-seconds format? Most conservative option
# is to use maximum:
pmax(decImp, dmsImp)

if (FALSE) {
  # known error when longitude is negative and latitude is -90
  long &lt;- -45
  lat &lt;- -90
  ll &lt;- cbind(long, lat)
  coordImprecision(ll)
}

</code></pre>


</div>