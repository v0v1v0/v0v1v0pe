<div class="container">

<table style="width: 100%;"><tr>
<td>gray_scale</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to get a grayscale image from a color image (Funcao para a obtencao
de uma imagem em escala de cinza a partir de uma imagem colorida)</h2>

<h3>Description</h3>

<p>Function to get a grayscale image from a color image (Esta
funcao permite a obtencao de uma imagem em escala de cinza a partir de uma
imagem colorida).
</p>


<h3>Usage</h3>

<pre><code class="language-R">gray_scale(im,method="r",normalize=TRUE,plot=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>im</code></td>
<td>
<p>:This object must contain an image in EBImage format (Este
objeto deve conter uma imagem no formato do EBImage).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>: Indicates the method for obtaining the gray scale (Este
objeto indica o metodo para a obtencao da escala de cinza).:<br>
"r" = extrair a banda de vermelho<br>
"g" = extrair a banda de verde<br>
"b" = extrair a banda de azul<br>
"rg" = considera a media da banda de vermelho e verde: (r+g)/2<br>
"rb" = considera a media da banda de vermelho e azul: (r+b)/2<br>
"gb" = considera a media da banda de verde e azul: (g+b)/2<br>
"rgb" = considera a media das 3 bandas: (r+g+b)/3<br>
"r/g"=r/g<br>
"r/b"=r/b<br>
"g/r"=g/r<br>
"g/b"=g/b<br>
"b/r"=b/r<br>
"b/g"=b/g<br>
"S"=((R+G+B)-3*B)/(R+G+B)
"BI"=sqrt((r^2+g^2+b^2)/3)<br>
"BIM"=sqrt((2r+2g+2b)/3)<br>
"SCI"=(r-g)/(r+g)<br>
"GLI"=(2g-r-b)/(2g+r+b)<br>
"HI"=(2r-g-b)/(g-b)<br>
"NGRDI"=(g-r)/(g+r)<br>
"SI"=(r-b)/(r+b)<br>
"VARI"=(g-r)/(g+r-b)<br>
"HUE"=atan(2(b-g-r)/30.5(g-r))<br>
"MGVRI"=(g^2-r^2)/(g^2+r^2)<br>
"GLI"=(2g-r-b)/(2g+r+b)<br>
"MPRI"=(g-r)/(g+r)<br>
"RGVBI"=(g-(br))/(g^2(br))<br>
"ExG"=(2*g-r-b)<br>
"VEG"=(g/(g^0.66667*b^0.66667))<br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>Logic value, if true, the pixel values will be corrected to vary between 0 and 1
(Valor logico, se for verdadeiro os valores dos pixels sera corrigido para variar entre 0 e 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>:This object must contain an image in EBImage format (Indica
se sera apresentada (TRUE) ou nao (FALSE) (default) a imagem segmentada).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns an image with text over each object in the image (Retorna uma
imagem com um texto sobreposto a cada objeto na imagem)
</p>


<h3>See Also</h3>

<p><code>segmentation_logit</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#Carregar imagem de exemplo
im=read_image(example_image(2))
##mostrar imagem
plot_image(im)


#Extraindo as camadas R, G e B
r=gray_scale(im,method = "r",plot=TRUE)
g=gray_scale(im,method = "g",plot=TRUE)
b=gray_scale(im,method = "b",plot=TRUE)

</code></pre>


</div>