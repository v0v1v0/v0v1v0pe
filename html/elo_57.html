<div class="container">

<table style="width: 100%;"><tr>
<td>players</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Details on <code>elo</code> formulas and the specials therein</h2>

<h3>Description</h3>

<p>Details on <code>elo</code> functions and the special functions allowed in them to change functions' behaviors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">players(..., weights = NULL)

multiteam(...)

k(x, y = NULL)

adjust(x, adjustment)

regress(x, to, by, regress.unused = TRUE)

group(x)

neutral(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Vectors to be coerced to character, which comprise of the players of a team.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>A vector giving the weights of Elo updates for the players in <code>...</code>. Ignored for
<code>elo.glm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>A vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjustment</code></td>
<td>
<p>A single value or a vector of the same length as <code>x</code>: how much to adjust the Elos in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>Numeric: what Elo to regress to. Can be a single value or named vector the same length
as the number of teams.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>Numeric: by how much should Elos be regressed toward <code>to</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regress.unused</code></td>
<td>
<p>Logical: whether to continue regressing teams which have stopped playing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the functions in this package, <code>formula</code> is usually of the form <code>wins.A ~ elo.A + elo.B</code>,
where <code>elo.A</code> and <code>elo.B</code> are vectors of Elos, and <code>wins.A</code> is between 0 and 1,
denoting whether team A (Elo A) won or lost (or something between). <code>elo.prob</code> also allows
<code>elo.A</code> and <code>elo.B</code> to be character or factors, denoting which team(s) played. <code>elo.run</code>
requires <code>elo.A</code> to be a vector of teams or a players matrix from <code>players()</code>
(sometimes denoted by <code>"team.A"</code>), but <code>elo.B</code> can be either a vector of teams or
players matrix (<code>"team.B"</code>) or else a numeric column (denoting a fixed-Elo opponent).
<code>elo.glm</code> requires both to be a vector of teams or players matrix. <code>elo.markovchain</code>
requires both to be a vector of teams.
</p>
<p><code>formula</code> accepts six special functions in it:
</p>
<p><code>k()</code> allows for complicated Elo updates. For
constant Elo updates, use the <code>k = </code> argument instead of this special function.
Note that <code>elo.markovchain</code> uses this function (or argument) as a convenient
way of specifying transition probabilities. <code>elo.colley</code> uses this to indicate
the fraction of a win to be assigned to the winning team.
</p>
<p><code>adjust()</code> allows for Elos to be adjusted for, e.g., home-field advantage. The second argument
to this function can be a scalar or vector of appropriate length. This can also be used in
<code>elo.glm</code> and <code>elo.markovchain</code> as an adjuster to the logistic regressions.
</p>
<p><code>regress()</code> can be used to regress Elos back to a fixed value
after certain matches. Giving a logical vector identifies these matches after which to
regress back to the mean. Giving any other kind of vector regresses after the appropriate
groupings (see, e.g., <code>duplicated(..., fromLast = TRUE)</code>). The other three arguments determine
what Elo to regress to (<code>to = </code>), by how much to regress toward that value
(<code>by = </code>), and whether to continue regressing teams which have stopped playing (<code>regress.unused</code>,
default = <code>TRUE</code>).
</p>
<p><code>group()</code> is used to group matches (by, e.g., week). For <code>elo.run</code>, Elos are not updated until
the group changes. It is also fed to <code>as.matrix.elo.run</code>, giving the number of rows to return.
to produce only certain rows of matrix output. It also determines how many models to run (and on what data)
for <code>elo.glm</code> and <code>elo.markovchain</code> when <code>running=TRUE</code>.
</p>
<p><code>neutral()</code> is used in <code>elo.glm</code> and <code>elo.markovchain</code> to determine the intercept.
In short, the intercept is <code>1 - neutral()</code>, denoting home-field advantage. Therefore, the column
passed should be 0 (denoting home-field advantange) or 1 (denoting a neutral game). If omitted, all matches
are assumed to have home field advantage.
</p>
<p><code>players()</code> is used for multiple players on a team contributing to an overall Elo. The Elo updates
are then assigned based on the specified weights. The weights are ignored in <code>elo.glm</code>.
</p>
<p><code>multiteam()</code> is used for matchups consisting of multiple teams and is only valid in <code>elo.run.multiteam</code>.
</p>


</div>