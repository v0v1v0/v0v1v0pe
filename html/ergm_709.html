<div class="container">

<table style="width: 100%;"><tr>
<td>predict.formula</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ERGM-based tie probabilities</h2>

<h3>Description</h3>

<p>Calculate model-predicted <strong>conditional</strong> and <strong>unconditional</strong> tie
probabilities for dyads in the given network. Conditional probabilities of a
dyad given the state of all the remaining dyads in the graph are computed
exactly. Unconditional probabilities are computed through simulating networks
using the given model. Currently there are two methods implemented:
</p>

<ul>
<li>
<p> Method for formula objects requires (1) an ERGM model formula with an existing
network object on the left hand side and model terms on the right hand side, and
(2) a vector of corresponding parameter values.
</p>
</li>
<li>
<p> Method for <code>ergm</code> objects, as returned by <code>ergm()</code>, takes both the formula
and parameter values from the fitted model object.
</p>
</li>
</ul>
<p>Both methods can limit calculations to specific set of dyads of interest.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'formula'
predict(
  object,
  theta,
  conditional = TRUE,
  type = c("response", "link"),
  nsim = 100,
  output = c("data.frame", "matrix"),
  ...
)

## S3 method for class 'ergm'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a formula or a fitted ERGM model object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>numeric vector of ERGM model parameter values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditional</code></td>
<td>
<p>logical whether to compute conditional or unconditional
predicted probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character element, one of <code>"response"</code> (default) or <code>"link"</code> -
whether the returned predictions are on the probability scale or on the
scale of linear predictor. This is similar to <code>type</code> argument of <code>predict.glm()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>integer, number of simulated networks used for computing
unconditional probabilities. Defaults to 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>character, type of object returned. Defaults to <code>"data.frame"</code>.
See section Value below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed to/from other methods. For the <code>predict.formula</code> method, if
<code>conditional=TRUE</code> arguments are passed to <code>ergmMPLE()</code>. If <code>conditional=FALSE</code> arguments
are passed to <code>simulate_formula()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Type of object returned depends on the argument <code>output</code>. If
<code>output="data.frame"</code> the function will return a data frame with columns:
</p>

<ul>
<li> <p><code>tail</code>, <code>head</code> – indices of nodes identifying a dyad
</p>
</li>
<li> <p><code>p</code> – predicted conditional tie probability
</p>
</li>
</ul>
<p>If <code>output="matrix"</code> the function will return an "adjacency matrix" with the
predicted probabilities. Diagonal values are 0s.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># A three-node empty directed network
net &lt;- network.initialize(3, directed=TRUE)

# In homogeneous Bernoulli model with odds of a tie of 1/5 all ties are
# equally likely
predict(net ~ edges, log(1/5))

# Let's add a tie so that `net` has 1 tie out of possible 6 (so odds of 1/5)
net[1,2] &lt;- 1

# Fit the model
fit &lt;- ergm(net ~ edges)

# The p's should be identical
predict(fit)
</code></pre>


</div>