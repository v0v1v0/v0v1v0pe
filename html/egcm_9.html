<div class="container">

<table style="width: 100%;"><tr>
<td>bvr.test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Unit root test based upon Breitung's variance ratio
</h2>

<h3>Description</h3>

<p>Unit root test based upon Breitung's variance ratio
</p>


<h3>Usage</h3>

<pre><code class="language-R">bvr.test(Y, detrend = FALSE)
bvr_rho(Y, detrend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>A vector or zoo-vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detrend</code></td>
<td>
<p>A boolean, which if TRUE, indicates that the test should
be performed after removing a linear trend from <code>Y</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Breitung's variance ratio is given by the formula:
</p>
<p style="text-align: center;"><code class="reqn">\rho_T = \frac{T^{-2} \sum_{t=1}^T Y_t^2}{T^{-1} \sum_{t=1}^T y_t^2}</code>
</p>

<p>where <code class="reqn">T</code> is the length of the vector <code class="reqn">Y</code>.  (See equation (5) 
of his paper.)
</p>
<p>The advantage of Breitung's variance ratio is that, in contrast to
the Dickey-Fuller test and other related tests, it is a nonparametric
statistic.  In simulations, it seems to perform favorably with respect
to the Hurst exponent.
</p>
<p>Simulation has been used to determine the distribution of the statistic,
and table lookup is used to determine p-values.
</p>
<p>If <code>detrend=TRUE</code>, then a linear trend is removed from the data
prior to computing the estimator <code class="reqn">\rho_{T}</code>.  A separate table has been
computed of the distribution of values of <code class="reqn">\rho_{T}</code> after detrending.
</p>


<h3>Value</h3>

<p><code>bvr_rho</code> returns the value <code class="reqn">\rho_{T}</code> of Breitung's variance
ratio.
</p>
<p><code>bvr.test</code> returns a list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p>the truncation lag parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matthew Clegg <a href="mailto:matthewcleggphd@gmail.com">matthewcleggphd@gmail.com</a></p>


<h3>References</h3>

<p>Breitung, J. (2002). 
Nonparametric tests for unit roots and cointegration. 
<em>Journal of econometrics</em>, 108(2), 343-363.
</p>
<p>Breitung, J. and Taylor, A.M.R. (2003)
Corrigendum to "Nonparametric tests for unit roots and cointegration"
[J. Econom. 108 (2002) 343-363]
<em>Journal of econometrics</em>, 117(2), 401-404.
</p>


<h3>See Also</h3>

<p><code>hurstexp</code>
<code>egcm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The following should produce a low p-value
bvr_rho(rnorm(100))
bvr.test(rnorm(100))

# The following should produce a high p-value
bvr_rho(cumsum(rnorm(100)))
bvr.test(cumsum(rnorm(100)))

# Test with an autoregressive sequence where rho = 0.8
bvr.test(rar1(100, a1=0.8))

# If there is a linear trend, bvr.test with detrend=FALSE
# is likely to find a unit root when there is none:
bvr.test(1:100 + rnorm(100))
bvr.test(1:100 + rnorm(100), detrend=TRUE)

# Display the power of the test for various values of rho and n:
bvr_power(a1=0.8, n=100, nrep=100)
bvr_power(a1=0.9, n=250, nrep=100)
bvr_power(a1=0.95, n=250, nrep=100)

# This is to be compared to the power of the adf.test at this level:
adf_power(a1=0.8, n=100, nrep=100)
adf_power(a1=0.9, n=250, nrep=100)
adf_power(a1=0.95, n=250, nrep=100)
</code></pre>


</div>