<div class="container">

<table style="width: 100%;"><tr>
<td>filter_precedence</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter Precedence Relations</h2>

<h3>Description</h3>

<p>Filters cases based on the precedence relations between two sets of activities.
</p>


<h3>Usage</h3>

<pre><code class="language-R">filter_precedence(
  log,
  antecedents,
  consequents,
  precedence_type = c("directly_follows", "eventually_follows"),
  filter_method = c("all", "one_of", "none"),
  reverse = FALSE,
  eventlog = deprecated()
)

## S3 method for class 'log'
filter_precedence(
  log,
  antecedents,
  consequents,
  precedence_type = c("directly_follows", "eventually_follows"),
  filter_method = c("all", "one_of", "none"),
  reverse = FALSE,
  eventlog = deprecated()
)

## S3 method for class 'grouped_log'
filter_precedence(
  log,
  antecedents,
  consequents,
  precedence_type = c("directly_follows", "eventually_follows"),
  filter_method = c("all", "one_of", "none"),
  reverse = FALSE,
  eventlog = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p><code>log</code>: Object of class <code>log</code> or derivatives (<code>grouped_log</code>, <code>eventlog</code>, <code>activitylog</code>, etc.).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>antecedents, consequents</code></td>
<td>
<p><code>character</code> vector: The set of antecendent and consequent activities.
Both are <code>character</code> vectors containing at least one activity identifier. All pairs of antecedents and consequents are turned into seperate precedence rules.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precedence_type</code></td>
<td>
<p><code>character</code> (default <code>"directly_follows"</code>): When <code>"directly_follows"</code>,
the consequent activity should happen immediately after the antecedent activities.<br>
When <code>"eventually_follows"</code>, other events are allowed to happen in between.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter_method</code></td>
<td>
<p><code>character</code> (default <code>"all"</code>): When <code>"all"</code>, only cases where all the relations are valid are preserved.<br>
When <code>"one_of"</code>, all the cases where at least one of the conditions hold, are preserved.<br>
When <code>"none"</code>, none of the relations are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p><code>logical</code> (default <code>FALSE</code>): Indicating whether the selection should be reversed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eventlog</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a>; please use <code>log</code> instead.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In order to extract a subset of an event log which conforms with a set of precedence rules, one can use the <code>filter_precedence</code> method.
There are two types of precendence relations which can be tested: activities that should directly follow (<code>"directly_follows"</code>) each other,
or activities that should eventually follow (<code>"eventually_follows"</code>) each other. The type can be set with the <code>precedence_type</code> argument.
</p>
<p>Further, the filter requires a vector of one or more <code>antecedents</code> (containing activity labels), and one or more <code>consequents</code>.
</p>
<p>Finally, a <code>filter_method</code> argument can be set. This argument is relevant when there is more than one antecedent or consequent.
In such a case, you can specify that all possible precedence combinations must be present (<code>"all"</code>),
at least one of them (<code>"one_of"</code>), or none (<code>"none"</code>).
</p>


<h3>Value</h3>

<p>When given an object of type <code>log</code>, it will return a filtered <code>log</code>.
When given an object of type <code>grouped_log</code>, the filter will be applied in a stratified way (i.e. each separately for each group).
The returned log will be grouped on the same variables as the original log.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>filter_precedence(log)</code>: Filters cases for a <code>log</code>.
</p>
</li>
<li> <p><code>filter_precedence(grouped_log)</code>: Filters cases for a <code>grouped_log</code>.
</p>
</li>
</ul>
<h3>References</h3>

<p>Swennen, M. (2018). Using Event Log Knowledge to Support Operational Exellence Techniques (Doctoral dissertation). Hasselt University.
</p>


<h3>See Also</h3>

<p>Other filters: 
<code>filter_activity_frequency()</code>,
<code>filter_activity_instance()</code>,
<code>filter_activity_presence()</code>,
<code>filter_activity()</code>,
<code>filter_case_condition()</code>,
<code>filter_case()</code>,
<code>filter_endpoints_condition()</code>,
<code>filter_endpoints()</code>,
<code>filter_flow_time()</code>,
<code>filter_idle_time()</code>,
<code>filter_infrequent_flows()</code>,
<code>filter_lifecycle_presence()</code>,
<code>filter_lifecycle()</code>,
<code>filter_precedence_condition()</code>,
<code>filter_precedence_resource()</code>,
<code>filter_processing_time()</code>,
<code>filter_resource_frequency()</code>,
<code>filter_resource()</code>,
<code>filter_throughput_time()</code>,
<code>filter_time_period()</code>,
<code>filter_trace_frequency()</code>,
<code>filter_trace_length()</code>,
<code>filter_trace()</code>,
<code>filter_trim_lifecycle()</code>,
<code>filter_trim()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
eventdataR::patients %&gt;%
	filter_precedence(antecedents = "Triage and Assessment",
					  consequents = "Blood test",
					  precedence_type = "directly_follows") %&gt;%
	bupaR::traces()

eventdataR::patients %&gt;%
	filter_precedence(antecedents = "Triage and Assessment",
					  consequents = c("Blood test", "X-Ray", "MRI SCAN"),
					  precedence_type = "eventually_follows",
					  filter_method = "one_of") %&gt;%
	bupaR::traces()

</code></pre>


</div>