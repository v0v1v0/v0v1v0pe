<div class="container">

<table style="width: 100%;"><tr>
<td>boxcoxCensored</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Boxcox Power Transformation for Type I Censored Data
</h2>

<h3>Description</h3>

<p>Compute the value(s) of an objective for one or more Box-Cox power transformations, 
or to compute an optimal power transformation based on a specified objective, based on 
Type I censored data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  boxcoxCensored(x, censored, censoring.side = "left", 
    lambda = {if (optimize) c(-2, 2) else seq(-2, 2, by = 0.5)}, optimize = FALSE, 
    objective.name = "PPCC", eps = .Machine$double.eps, 
    include.x.and.censored = TRUE, prob.method = "michael-schucany", 
    plot.pos.con = 0.375) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a numeric vector of positive numbers.  
Missing (<code>NA</code>), undefined (<code>NaN</code>), and infinite (<code>-Inf, Inf</code>) 
values are allowed but will be removed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>censored</code></td>
<td>

<p>numeric or logical vector indicating which values of <code>x</code> are censored.  This must be the 
same length as <code>x</code>.  If the mode of <code>censored</code> is <code>"logical"</code>, <code>TRUE</code> values 
correspond to elements of <code>x</code> that are censored, and <code>FALSE</code> values correspond to 
elements of <code>x</code> that are not censored.  If the mode of <code>censored</code> is <code>"numeric"</code>, 
it must contain only <code>1</code>'s and <code>0</code>'s; <code>1</code> corresponds to <code>TRUE</code> and 
<code>0</code> corresponds to <code>FALSE</code>.  Missing (<code>NA</code>) values are allowed but will be removed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>censoring.side</code></td>
<td>

<p>character string indicating on which side the censoring occurs.  The possible values are 
<code>"left"</code> (the default) and <code>"right"</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>numeric vector of finite values indicating what powers to use for the 
Box-Cox transformation.  When <code>optimize=FALSE</code>, the default value is <br><code>lambda=seq(-2, 2, by=0.5)</code>.  When <code>optimize=TRUE</code>, <code>lambda</code> 
must be a vector with two values indicating the range over which the 
optimization will occur and the range of these two values must include 1.  
In this case, the default value is <code>lambda=c(-2, 2)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimize</code></td>
<td>

<p>logical scalar indicating whether to simply evalute the objective function at the 
given values of <code>lambda</code> (<code>optimize=FALSE</code>; the default), or to compute 
the optimal power transformation within the bounds specified by 
<code>lambda</code> (<code>optimize=TRUE</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objective.name</code></td>
<td>

<p>character string indicating what objective to use. The possible values are
<code>"PPCC"</code> (probability plot correlation coefficient; the default), 
<code>"Shapiro-Wilk"</code> (the Shapiro-Wilk goodness-of-fit statistic), and 
<code>"Log-Likelihood"</code> (the log-likelihood function). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>finite, positive numeric scalar.  When the absolute value of <code>lambda</code> is less 
than <code>eps</code>, lambda is assumed to be 0 for the Box-Cox transformation.  
The default value is <code>eps=.Machine$double.eps</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.x.and.censored</code></td>
<td>

<p>logical scalar indicating whether to include the finite, non-missing values of 
the argument <code>x</code> and the corresponding values of <code>censored</code> with the 
returned object.  The default value is <code>include.x.and.censored=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.method</code></td>
<td>

<p>for multiply censored data, 
character string indicating what method to use to compute the plotting positions 
(empirical probabilities) when <br><code>objective.name="PPCC"</code>.  Possible values are: <br></p>
<p><code>"kaplan-meier"</code> (product-limit method of Kaplan and Meier (1958)), <br><code>"modified kaplan-meier"</code> (same as <code>"kaplan-meier"</code> with the maximum value included), <br><code>"nelson"</code> (hazard plotting method of Nelson (1972)), <br><code>"michael-schucany"</code> (generalization of the product-limit method due to Michael and Schucany (1986)), and <br><code>"hirsch-stedinger"</code> (generalization of the product-limit method due to Hirsch and Stedinger (1987)). <br></p>
<p>The default value is <code>prob.method="michael-schucany"</code>. <br></p>
<p>The <code>"nelson"</code> method is only available for <code>censoring.side="right"</code>, and 
the <code>"modified kaplan-meier"</code> is only available for <code>censoring.side="left"</code>.  
See the DETAILS section for more explanation.
</p>
<p>This argument is ignored if <code>objective.name</code> is not equal to <code>"PPCC"</code> 
and/or the data are singly censored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.pos.con</code></td>
<td>

<p>for multiply censored data, 
numeric scalar between 0 and 1 containing the value of the plotting position 
constant when <code>objective.name="PPCC"</code>.  
The default value is <code>plot.pos.con=0.375</code>.  See the DETAILS section 
for more information.  
This argument is used only if <code>prob.method</code> is equal to 
<code>"michael-schucany"</code> or <code>"hirsch-stedinger"</code>.
</p>
<p>This argument is ignored if <code>objective.name</code> is not equal to <code>"PPCC"</code> 
and/or the data are singly censored.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Two common assumptions for several standard parametric hypothesis tests are:
</p>

<ol>
<li>
<p> The observations all come from a normal distribution.
</p>
</li>
<li>
<p> The observations all come from distributions with the same variance.
</p>
</li>
</ol>
<p>For example, the standard one-sample t-test assumes all the observations 
come from the same normal distribution, and the standard two-sample t-test 
assumes that all the observations come from a normal distribution with the same 
variance, although the mean may differ between the two groups.  
</p>
<p>When the original data do not satisfy the above assumptions, data transformations 
are often used to attempt to satisfy these assumptions.  
Box and Cox (1964) presented a formalized method for deciding on a data 
transformation.  Given a random variable <code class="reqn">X</code> from some distribution with 
only positive values, the Box-Cox family of power transformations is defined as:
</p>

<table>
<tr>
<td style="text-align: left;">
  <code class="reqn">Y</code> </td>
<td style="text-align: left;"> = </td>
<td style="text-align: left;"> <code class="reqn">\frac{X^\lambda - 1}{\lambda}</code> </td>
<td style="text-align: left;"> <code class="reqn">\lambda \ne 0</code> </td>
</tr>
<tr>
<td style="text-align: left;">
          </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;">                                     </td>
<td style="text-align: left;">                     </td>
</tr>
<tr>
<td style="text-align: left;">
          </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code class="reqn">log(X)</code>                        </td>
<td style="text-align: left;"> <code class="reqn">\lambda = 0 \;\;\;\;\;\; (1)</code>
  </td>
</tr>
</table>
<p>where <code class="reqn">Y</code> is assumed to come from a normal distribution.  This transformation is 
continuous in <code class="reqn">\lambda</code>.  Note that this transformation also preserves ordering.  
See the help file for <code>boxcoxTransform</code> for more information on data 
transformations.
</p>
<p>Box and Cox (1964) proposed choosing the appropriate value of <code class="reqn">\lambda</code> based on 
maximizing the likelihood function.  Alternatively, an appropriate value of 
<code class="reqn">\lambda</code> can be chosen based on another objective, such as maximizing the 
probability plot correlation coefficient or the Shapiro-Wilk goodness-of-fit 
statistic.
</p>
<p>Shumway et al. (1989) investigated extending the method of Box and Cox (1964) to 
the case of Type I censored data, motivated by the desire to produce estimated 
means and confidence intervals for air monitoring data that included censored 
values.
</p>
<p>In the case when <code>optimize=TRUE</code>, the function <code>boxcoxCensored</code> calls the 
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>nlminb</code> to minimize the negative value of the 
objective (i.e., maximize the objective) over the range of possible values of 
<code class="reqn">\lambda</code> specified in the argument <code>lambda</code>.  The starting value for 
the optimization is always <code class="reqn">\lambda=1</code> (i.e., no transformation).
</p>
<p>The next section explains assumptions and notation, and the section after that 
explains how the objective is computed for the various options for 
<code>objective.name</code>. 
<br></p>
<p><b>Assumptions and Notation</b> <br>
Let <code class="reqn">\underline{x}</code> denote a random sample of <code class="reqn">N</code> observations from 
some continuous distribution.  Assume <code class="reqn">n</code> (<code class="reqn">0 &lt; n &lt; N</code>) of these 
observations are known and <code class="reqn">c</code> (<code class="reqn">c=N-n</code>) of these observations are 
all censored below (left-censored) or all censored above (right-censored) at 
<code class="reqn">k</code> fixed censoring levels
</p>
<p style="text-align: center;"><code class="reqn">T_1, T_2, \ldots, T_K; \; K \ge 1 \;\;\;\;\;\; (2)</code>
</p>

<p>For the case when <code class="reqn">K \ge 2</code>, the data are said to be Type I 
<b><em>multiply censored</em></b>.  For the case when <code class="reqn">K=1</code>, 
set <code class="reqn">T = T_1</code>.  If the data are left-censored 
and all <code class="reqn">n</code> known observations are greater 
than or equal to <code class="reqn">T</code>, or if the data are right-censored and all <code class="reqn">n</code> 
known observations are less than or equal to <code class="reqn">T</code>, then the data are 
said to be Type I <b><em>singly censored</em></b> (Nelson, 1982, p.7), otherwise 
they are considered to be Type I multiply censored.
</p>
<p>Let <code class="reqn">c_j</code> denote the number of observations censored below or above censoring 
level <code class="reqn">T_j</code> for <code class="reqn">j = 1, 2, \ldots, K</code>, so that
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^K c_j = c \;\;\;\;\;\; (3)</code>
</p>

<p>Let <code class="reqn">x_{(1)}, x_{(2)}, \ldots, x_{(N)}</code> denote the “ordered” observations, 
where now “observation” means either the actual observation (for uncensored 
observations) or the censoring level (for censored observations).  For 
right-censored data, if a censored observation has the same value as an 
uncensored one, the uncensored observation should be placed first.  
For left-censored data, if a censored observation has the same value as an 
uncensored one, the censored observation should be placed first.
</p>
<p>Note that in this case the quantity <code class="reqn">x_{(i)}</code> does not necessarily represent 
the <code class="reqn">i</code>'th “largest” observation from the (unknown) complete sample.
</p>
<p>Finally, let <code class="reqn">\Omega</code> (omega) denote the set of <code class="reqn">n</code> subscripts in the 
“ordered” sample that correspond to uncensored observations, and let 
<code class="reqn">\Omega_j</code> denote the set of <code class="reqn">c_j</code> subscripts in the “ordered” 
sample that correspond to the censored observations censored at censoring level 
<code class="reqn">T_j</code> for <code class="reqn">j = 1, 2, \ldots, k</code>.
</p>
<p>We assume that there exists some value of <code class="reqn">\lambda</code> such that the transformed 
observations
</p>

<table>
<tr>
<td style="text-align: left;">
  <code class="reqn">y_i</code> </td>
<td style="text-align: left;"> = </td>
<td style="text-align: left;"> <code class="reqn">\frac{x_i^\lambda - 1}{\lambda}</code> </td>
<td style="text-align: left;"> <code class="reqn">\lambda \ne 0</code> </td>
</tr>
<tr>
<td style="text-align: left;">
            </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;">                                       </td>
<td style="text-align: left;">                     </td>
</tr>
<tr>
<td style="text-align: left;">
            </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code class="reqn">log(x_i)</code>                        </td>
<td style="text-align: left;"> <code class="reqn">\lambda = 0 \;\;\;\;\;\; (4)</code>
  </td>
</tr>
</table>
<p>(<code class="reqn">i = 1, 2, \ldots, n</code>) form a random sample of Type I censored data from a 
normal distribution.
</p>
<p>Note that for the censored observations, Equation (4) becomes:
</p>

<table>
<tr>
<td style="text-align: left;">
  <code class="reqn">y_{(i)} = T_j^*</code> </td>
<td style="text-align: left;"> = </td>
<td style="text-align: left;"> <code class="reqn">\frac{T_j^\lambda - 1}{\lambda}</code> </td>
<td style="text-align: left;"> <code class="reqn">\lambda \ne 0</code> </td>
</tr>
<tr>
<td style="text-align: left;">
                        </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;">                                       </td>
<td style="text-align: left;">                     </td>
</tr>
<tr>
<td style="text-align: left;">
                        </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code class="reqn">log(T_j)</code>                        </td>
<td style="text-align: left;"> <code class="reqn">\lambda = 0 \;\;\;\;\;\; (5)</code>
  </td>
</tr>
</table>
<p>where <code class="reqn">i \in \Omega_j</code>.
<br></p>
<p><b>Computing the Objective</b> <br></p>
<p><em>Objective Based on Probability Plot Correlation Coefficient</em> (<code>objective.name="PPCC"</code>) <br>
When <code>objective.name="PPCC"</code>, the objective is computed as the value of the 
normal probability plot correlation coefficient based on the transformed data 
(see the description of the Probability Plot Correlation Coefficient (PPCC) 
goodness-of-fit test in the help file for <code>gofTestCensored</code>).  That is, 
the objective is the correlation coefficient for the normal 
quantile-quantile plot for the transformed data.  
Large values of the PPCC tend to indicate a good fit to a normal distribution.
<br></p>
<p><em>Objective Based on Shapiro-Wilk Goodness-of-Fit Statistic</em> (<code>objective.name="Shapiro-Wilk"</code>) <br>
When <code>objective.name="Shapiro-Wilk"</code>, the objective is computed as the value of 
the Shapiro-Wilk goodness-of-fit statistic based on the transformed data 
(see the description of the Shapiro-Wilk test in the help file for 
<code>gofTestCensored</code>).  Large values of the Shapiro-Wilk statistic tend to 
indicate a good fit to a normal distribution.
<br></p>
<p><em>Objective Based on Log-Likelihood Function</em> (<code>objective.name="Log-Likelihood"</code>) <br>
When <code>objective.name="Log-Likelihood"</code>, the objective is computed as the value 
of the log-likelihood function.  Assuming the transformed observations in 
Equation (4) above come from a normal distribution with mean <code class="reqn">\mu</code> and 
standard deviation <code class="reqn">\sigma</code>, we can use the change of variable formula to 
write the log-likelihood function as follows.
</p>
<p>For Type I left censored data, the likelihood function is given by:
</p>
<p style="text-align: center;"><code class="reqn">log[L(\lambda, \mu, \sigma)] = log[{N \choose c_1 c_2 \ldots c_k n}] + \sum_{j=1}^k c_j log[F(T_j^*)] + \sum_{i \in \Omega} log\{f[y_{(i)}]\} + (\lambda - 1) \sum_{i \in \Omega} log[x_{(i)}] \;\;\;\;\;\; (6)</code>
</p>

<p>where <code class="reqn">f</code> and <code class="reqn">F</code> denote the probability density function (pdf) and 
cumulative distribution function (cdf) of the population. That is,
</p>
<p style="text-align: center;"><code class="reqn">f(t) = \phi(\frac{t-\mu}{\sigma}) \;\;\;\;\;\; (7)</code>
</p>

<p style="text-align: center;"><code class="reqn">F(t) = \Phi(\frac{t-\mu}{\sigma}) \;\;\;\;\;\; (8)</code>
</p>

<p>where <code class="reqn">\phi</code> and <code class="reqn">\Phi</code> denote the pdf and cdf of the standard normal 
distribution, respectively (Shumway et al., 1989).  For left singly 
censored data, Equation (6) simplifies to:
</p>
<p style="text-align: center;"><code class="reqn">log[L(\lambda, \mu, \sigma)] = log[{N \choose c}] + c log[F(T^*)] + \sum_{i = c+1}^N log\{f[y_{(i)}]\} + (\lambda - 1) \sum_{i = c+1}^N log[x_{(i)}] \;\;\;\;\;\; (9)</code>
</p>

<p>Similarly, for Type I right censored data, the likelihood function is given by:
</p>
<p style="text-align: center;"><code class="reqn">log[L(\lambda, \mu, \sigma)] = log[{N \choose c_1 c_2 \ldots c_k n}] + \sum_{j=1}^k c_j log[1 - F(T_j^*)] + \sum_{i \in \Omega} log\{f[y_{(i)}]\} + (\lambda - 1) \sum_{i \in \Omega} log[x_{(i)}] \;\;\;\;\;\; (10)</code>
</p>

<p>and for right singly censored data this simplifies to:
</p>
<p style="text-align: center;"><code class="reqn">log[L(\lambda, \mu, \sigma)] = log[{N \choose c}] + c log[1 - F(T^*)] + \sum_{i = 1}^n log\{f[y_{(i)}]\} + (\lambda - 1) \sum_{i = 1}^n log[x_{(i)}] \;\;\;\;\;\; (11)</code>
</p>

<p>For a fixed value of <code class="reqn">\lambda</code>, the log-likelihood function 
is maximized by replacing <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> with their maximum likelihood 
estimators (see the section <em>Maximum Likelihood Estimation</em> in the help file 
for <code>enormCensored</code>).  
</p>
<p>Thus, when <code>optimize=TRUE</code>, Equation (6) or (10) is maximized by iteratively 
solving for <code class="reqn">\lambda</code> using the MLEs for <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>.  
When <code>optimize=FALSE</code>, the value of the objective is computed by using 
Equation (6) or (10), using the values of <code class="reqn">\lambda</code> specified in the 
argument <code>lambda</code>, and using the MLEs of <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>.
</p>


<h3>Value</h3>

<p><code>boxcoxCensored</code> returns a list of class <code>"boxcoxCensored"</code> 
containing the results.  
See the help file for <code>boxcoxCensored.object</code> for details.
</p>


<h3>Note</h3>

<p>Data transformations are often used to induce normality, homoscedasticity, 
and/or linearity, common assumptions of parametric statistical tests and 
estimation procedures.  Transformations are not “tricks” used by the 
data analyst to hide what is going on, but rather useful tools for 
understanding and dealing with data (Berthouex and Brown, 2002, p.61).  
Hoaglin (1988) discusses “hidden” transformations that are used everyday, 
such as the pH scale for measuring acidity.  Johnson and Wichern (2007, p.192) 
note that "Transformations are nothing more than a reexpression of the data 
in different units."
</p>
<p>Shumway et al. (1989) investigated extending the method of Box and Cox (1964) to 
the case of Type I censored data, motivated by the desire to produce estimated 
means and confidence intervals for air monitoring data that included censored values.  
</p>
<p>Stoline (1991) compared the goodness-of-fit of Box-Cox transformed data (based on 
using the “optimal” power transformation from a finite set of values between 
-1.5 and 1.5) with log-transformed data for 17 groundwater chemistry variables.  
Using the Probability Plot Correlation Coefficient statistic for censored data as a 
measure of goodness-of-fit (see <code>gofTest</code>), Stoline (1991) found that 
only 6 of the variables were adequately modeled by a Box-Cox transformation 
(p &gt;0.10 for these 6 variables).  Of these variables, five were adequately modeled 
by a a log transformation.  Ten of variables were “marginally” fit by an 
optimal Box-Cox transformation, and of these 10 only 6 were marginally fit by a 
log transformation.  Based on these results, Stoline (1991) recommends checking 
the assumption of lognormality before automatically assuming environmental data fit 
a lognormal distribution.
</p>
<p>One problem with data transformations is that translating results on the 
transformed scale back to the original scale is not always straightforward.  
Estimating quantities such as means, variances, and confidence limits in the 
transformed scale and then transforming them back to the original scale 
usually leads to biased and inconsistent estimates (Gilbert, 1987, p.149; 
van Belle et al., 2004, p.400).  For example, exponentiating the confidence 
limits for a mean based on log-transformed data does not yield a 
confidence interval for the mean on the original scale.  Instead, this yields 
a confidence interval for the median (see the help file for 
<code>elnormAltCensored</code>).  
It should be noted, however, that quantiles (percentiles) and rank-based 
procedures are invariant to monotonic transformations 
(Helsel and Hirsch, 1992, p.12).
</p>
<p>Finally, there is no guarantee that a Box-Cox tranformation based on the 
“optimal” value of <code class="reqn">\lambda</code> will provide an adequate transformation 
to allow the assumption of approximate normality and constant variance.  Any 
set of transformed data should be inspected relative to the assumptions you 
want to make about it (Johnson and Wichern, 2007, p.194).
</p>


<h3>Author(s)</h3>

<p>Steven P. Millard (<a href="mailto:EnvStats@ProbStatInfo.com">EnvStats@ProbStatInfo.com</a>)
</p>


<h3>References</h3>

<p>Berthouex, P.M., and L.C. Brown. (2002). 
<em>Statistics for Environmental Engineers, Second Edition</em>. 
Lewis Publishers, Boca Raton, FL.
</p>
<p>Box, G.E.P., and D.R. Cox. (1964).  An Analysis of Transformations 
(with Discussion).  <em>Journal of the Royal Statistical Society, Series B</em> 
<b>26</b>(2), 211–252.
</p>
<p>Cohen, A.C. (1991).  Truncated and Censored Samples.  <em>Marcel Dekker</em>, 
New York, New York, pp.50–59.
</p>
<p>Draper, N., and H. Smith. (1998). <em>Applied Regression Analysis</em>. Third Edition. 
John Wiley and Sons, New York, pp.47-53.
</p>
<p>Gilbert, R.O. (1987). <em>Statistical Methods for Environmental Pollution 
Monitoring</em>. Van Nostrand Reinhold, NY.
</p>
<p>Helsel, D.R., and R.M. Hirsch. (1992).  
<em>Statistical Methods in Water Resources Research</em>. 
Elsevier, New York, NY.
</p>
<p>Hinkley, D.V., and G. Runger. (1984).  The Analysis of Transformed Data 
(with Discussion).  <em>Journal of the American Statistical Association</em> 
<b>79</b>, 302–320.
</p>
<p>Hoaglin, D.C., F.M. Mosteller, and J.W. Tukey, eds. (1983).  
<em>Understanding Robust and Exploratory Data Analysis</em>.  
John Wiley and Sons, New York, Chapter 4.
</p>
<p>Hoaglin, D.C. (1988).  Transformations in Everyday Experience. 
<em>Chance</em> <b>1</b>, 40–45.
</p>
<p>Johnson, N. L., S. Kotz, and A.W. Kemp. (1992).  <em>Univariate 
Discrete Distributions, Second Edition</em>.  John Wiley and Sons, New York, 
p.163.
</p>
<p>Johnson, R.A., and D.W. Wichern. (2007).  
<em>Applied Multivariate Statistical Analysis, Sixth Edition</em>.  
Pearson Prentice Hall, Upper Saddle River, NJ, pp.192–195.
</p>
<p>Shumway, R.H., A.S. Azari, and P. Johnson. (1989).  
Estimating Mean Concentrations Under Transformations for Environmental 
Data With Detection Limits.  <em>Technometrics</em> <b>31</b>(3), 347–356.
</p>
<p>Stoline, M.R. (1991).  An Examination of the Lognormal and Box and Cox 
Family of Transformations in Fitting Environmental Data.  
<em>Environmetrics</em> <b>2</b>(1), 85–106.
</p>
<p>van Belle, G., L.D. Fisher, Heagerty, P.J., and Lumley, T. (2004). 
<em>Biostatistics: A Methodology for the Health Sciences, 2nd Edition</em>. 
John Wiley &amp; Sons, New York.
</p>
<p>Zar, J.H. (2010). <em>Biostatistical Analysis</em>. 
Fifth Edition. Prentice-Hall, Upper Saddle River, NJ, 
Chapter 13.
</p>


<h3>See Also</h3>

<p><code>boxcoxCensored.object</code>, <code>plot.boxcoxCensored</code>, 
<code>print.boxcoxCensored</code>, 
<code>boxcox</code>, Data Transformations, Goodness-of-Fit Tests.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Generate 15 observations from a lognormal distribution with 
  # mean=10 and cv=2 and censor the observations less than 2.  
  # Then generate 15 more observations from this distribution and 
  # censor the observations less than 4.  
  # Then Look at some values of various objectives for various transformations.  
  # Note that for both the PPCC objective the optimal value is about -0.3, 
  # whereas for the Log-Likelihood objective it is about 0.3.
  # (Note: the call to set.seed simply allows you to reproduce this example.)

  set.seed(250) 

  x.1 &lt;- rlnormAlt(15, mean = 10, cv = 2) 
  censored.1 &lt;- x.1 &lt; 2
  x.1[censored.1] &lt;- 2

  x.2 &lt;- rlnormAlt(15, mean = 10, cv = 2) 
  censored.2 &lt;- x.2 &lt; 4
  x.2[censored.2] &lt;- 4

  x &lt;- c(x.1, x.2)
  censored &lt;- c(censored.1, censored.2)

  #--------------------------
  # Using the PPCC objective:
  #--------------------------

  boxcoxCensored(x, censored) 

  #Results of Box-Cox Transformation
  #Based on Type I Censored Data
  #---------------------------------
  #
  #Objective Name:                  PPCC
  #
  #Data:                            x
  #
  #Censoring Variable:              censored
  #
  #Censoring Side:                  left
  #
  #Censoring Level(s):              2 4 
  #
  #Sample Size:                     30
  #
  #Percent Censored:                26.7%
  #
  # lambda      PPCC
  #   -2.0 0.8954683
  #   -1.5 0.9338467
  #   -1.0 0.9643680
  #   -0.5 0.9812969
  #    0.0 0.9776834
  #    0.5 0.9471025
  #    1.0 0.8901990
  #    1.5 0.8187488
  #    2.0 0.7480494


  boxcoxCensored(x, censored, optimize = TRUE)

  #Results of Box-Cox Transformation
  #Based on Type I Censored Data
  #---------------------------------
  #
  #Objective Name:                  PPCC
  #
  #Data:                            x
  #
  #Censoring Variable:              censored
  #
  #Censoring Side:                  left
  #
  #Censoring Level(s):              2 4 
  #
  #Sample Size:                     30
  #
  #Percent Censored:                26.7%
  #
  #Bounds for Optimization:         lower = -2
  #                                 upper =  2
  #
  #Optimal Value:                   lambda = -0.3194799
  #
  #Value of Objective:              PPCC = 0.9827546


  #-----------------------------------
  # Using the Log-Likelihodd objective
  #-----------------------------------

  boxcoxCensored(x, censored, objective.name = "Log-Likelihood") 

  #Results of Box-Cox Transformation
  #Based on Type I Censored Data
  #---------------------------------
  #
  #Objective Name:                  Log-Likelihood
  #
  #Data:                            x
  #
  #Censoring Variable:              censored
  #
  #Censoring Side:                  left
  #
  #Censoring Level(s):              2 4 
  #
  #Sample Size:                     30
  #
  #Percent Censored:                26.7%
  #
  # lambda Log-Likelihood
  #   -2.0      -95.38785
  #   -1.5      -84.76697
  #   -1.0      -75.36204
  #   -0.5      -68.12058
  #    0.0      -63.98902
  #    0.5      -63.56701
  #    1.0      -66.92599
  #    1.5      -73.61638
  #    2.0      -82.87970


  boxcoxCensored(x, censored, objective.name = "Log-Likelihood", 
    optimize = TRUE) 

  #Results of Box-Cox Transformation
  #Based on Type I Censored Data
  #---------------------------------
  #
  #Objective Name:                  Log-Likelihood
  #
  #Data:                            x
  #
  #Censoring Variable:              censored
  #
  #Censoring Side:                  left
  #
  #Censoring Level(s):              2 4 
  #
  #Sample Size:                     30
  #
  #Percent Censored:                26.7%
  #
  #Bounds for Optimization:         lower = -2
  #                                 upper =  2
  #
  #Optimal Value:                   lambda = 0.3049744
  #
  #Value of Objective:              Log-Likelihood = -63.2733

  #----------

  # Plot the results based on the PPCC objective
  #---------------------------------------------
  boxcox.list &lt;- boxcoxCensored(x, censored)
  dev.new()
  plot(boxcox.list)

  #Look at QQ-Plots for the candidate values of lambda
  #---------------------------------------------------
  plot(boxcox.list, plot.type = "Q-Q Plots", same.window = FALSE) 

  #==========

  # Clean up
  #---------
  rm(x.1, censored.1, x.2, censored.2, x, censored, boxcox.list)
  graphics.off()
</code></pre>


</div>