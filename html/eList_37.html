<div class="container">

<table style="width: 100%;"><tr>
<td>helpers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Helpers for Vector Comprehension</h2>

<h3>Description</h3>

<p>These functions help to create sequences for use in vector comprehension.
</p>


<h3>Usage</h3>

<pre><code class="language-R">items(x)

vals(x)

enum(x)

rows(x, ...)

cols(x, ...)

zip(..., fill = NA, longest = TRUE)

lrep(x, n = 2, axis = 0)

transpose(x, fill = NA, longest = TRUE)

slice(x, start, end, by = 1L)

roll(x, n = 2, fill = NULL, head = TRUE, ...)

unroll(x)

lagg(x, k = 1, fill = NA, axis = 0)

groups(x, g)

chars(x)

chain(x)

separate(x, n = 2, fill = NA)

first(x)

rest(x)

splitn(x, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>list, environment, or other vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>vectors to combine</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>object with which to fill the vector when operating on elements with varying lengths or shifts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longest</code></td>
<td>
<p>logical; should the longest item be used to determine the new length or shortest? Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>size of window for <code>roll</code> and <code>separate</code>, or position of item in which to split each element in <code>splitn</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axis</code></td>
<td>
<p>which axis to perform different operations? <code>axis=0</code>, the default, performs operations on each element in the list (columns), while <code>axis=1</code> performs operations on each object within the elements of a list (rows).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start, end, by</code></td>
<td>
<p>integers of length 1 describing the sequence for slicing the vector. If missing, they will default to the start or end of the vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>head</code></td>
<td>
<p>logical; should <code>fill</code> be at the head of the vector or the tail?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of elements to shift right. Negative values of <code>k</code> shift to the left</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>vector of objects used to define groups</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions transform vectors or other objects into lists, by adding elements,
grouping objects, extracting certain elements, and so forth. These can be used
in conjunction with vector <code>comprehension</code> to develop quick and
readable code.
</p>
<p>An example of how each of these can be used is seen here. Let <code>x</code> and <code>y</code>
be given as follows.
</p>
<p><code>x = list(a = 2, b = 4, c = 8)</code>
<code>y = list(1:2, 2:3, 3:4)</code>
</p>
<p>Then the various helper functions will have the following effect.
</p>

<ul>
<li> <p><code>chain(y) =&gt; [1, 2, 2, 3, 3, 4]</code>
</p>
</li>
<li> <p><code>chars("hello") =&gt; ['h', 'e', 'l', 'l', 'o']</code>
</p>
</li>
<li> <p><code>enum(x) =&gt; [[1, 2], [2, 4], [3, 8]]</code>
</p>
</li>
<li> <p><code>first(y) =&gt; [1, 2, 3]</code>
</p>
</li>
<li> <p><code>groups(x, c("z", "w", "z")) =&gt; [["z", [2, 8]], ["w", [4]]]</code>
</p>
</li>
<li> <p><code>items(x) =&gt; [["a", 2], ["b", 4], ["c", 8]]</code>
</p>
</li>
<li> <p><code>lagg(x, 2) =&gt; [[2, 4, 8], [NA, 2, 4], [NA, NA, 2]]</code>
</p>
</li>
<li> <p><code>lrep(x, 3) =&gt; [[2, 4, 8], [2, 4, 8], [2, 4, 8]]</code>
</p>
</li>
<li> <p><code>rest(y) =&gt; [[2], [3], [4]]</code>
</p>
</li>
<li> <p><code>roll(x, 2) =&gt; [[2, 4] [4, 8]]</code>
</p>
</li>
<li> <p><code>separate(x, 2) =&gt; [[2, 4], [8, NA]]</code>
</p>
</li>
<li> <p><code>slice(x,1,,2) =&gt; [2, 8]</code>
</p>
</li>
<li> <p><code>splitn(y) =&gt; [[[1], [2]], [[2], [3]], [[3], [4]]]</code>
</p>
</li>
<li> <p><code>transpose(y) =&gt; [[1, 2, 3], [2, 3, 4]]</code>
</p>
</li>
<li> <p><code>unroll(y) =&gt; [1, 2, 3, 4]</code>
</p>
</li>
<li> <p><code>vals(x) =&gt; [2, 4, 8]</code>
</p>
</li>
<li> <p><code>zip(x, 1:3) =&gt; [[2, 1], [4, 2], [8, 3]]</code>
</p>
</li>
</ul>
<h3>Value</h3>

<p>list or other vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>items</code>: Create a list containing the name of each element of <code>x</code> and its value.
</p>
</li>
<li> <p><code>vals</code>: Extract the values of x without their names.
</p>
</li>
<li> <p><code>enum</code>: Create a list containing the index of each element of <code>x</code> and its value.
</p>
</li>
<li> <p><code>rows</code>: Create a list containing the rows of a data.frame or matrix
</p>
</li>
<li> <p><code>cols</code>: Create a list containing the columns of a data.frame or matrix
</p>
</li>
<li> <p><code>zip</code>: Merge two or more vectors into a list with each index containing values from each vector at that index.
</p>
</li>
<li> <p><code>lrep</code>: Repeat <code>x</code>, <code>n</code> times, with each repetition being an item in a list.
</p>
</li>
<li> <p><code>transpose</code>: Transpose a list or other object into a list. Opposite of <code>zip</code>.
</p>
</li>
<li> <p><code>slice</code>: Subset an object by a sequence: <code>start</code>, <code>end</code>, <code>by</code>. If <code>start</code> is missing, it is assumed to be 1. If <code>end</code> is missing, it is assumed to be the length of the object.
</p>
</li>
<li> <p><code>roll</code>: Create a list of objects containing <code>n</code> items from <code>x</code>, with <code>n-1</code> elements overlapping in a chain. Opposite of <code>unroll</code>.
</p>
</li>
<li> <p><code>unroll</code>: Flatten a list by combining the unique elements between each group of two elements. Opposite of <code>roll</code>.
</p>
</li>
<li> <p><code>lagg</code>: Create a list containing an object and each the first <code>k</code> lags of an object.
</p>
</li>
<li> <p><code>groups</code>: Create a list where each element is a list with the first element equal to a unique value in <code>g</code> and the other element is a list containing all values of <code>x</code> at the same indices as the value of <code>g</code>.
</p>
</li>
<li> <p><code>chars</code>: Convert a character string into a vector of single character values.
</p>
</li>
<li> <p><code>chain</code>: Combine each object in a list. Opposite of <code>separate</code>.
</p>
</li>
<li> <p><code>separate</code>: Separate vector into a list of objects with length <code>n</code>. Opposite of <code>chain</code>.
</p>
</li>
<li> <p><code>first</code>: Take the first element of each item in a list.
</p>
</li>
<li> <p><code>rest</code>: Remove the first element of each item in a list.
</p>
</li>
<li> <p><code>splitn</code>: Split each element in a list into two parts: one with the first <code>n</code> elements and the second with the rest.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">x &lt;- 1:10
y &lt;- 32:35

n &lt;- Num(for (i.j in zip(x,y)) i+j)
# Note that the result is different from x+y since the shortest does not repeat
mean(n[1:4])

e &lt;- new.env()
e$a &lt;- 1:5
e$b &lt;- 6:10

e2 &lt;- Env(for (key.val in items(e)) key = sqrt(val))
e2$a

# row product
mat &lt;- matrix(1:9, nrow=3)
Num(for (i in rows(mat)) prod(i))
</code></pre>


</div>