<div class="container">

<table style="width: 100%;"><tr>
<td>net_dep</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Implement a number of modifications to the linear-in-means model to obtain different weighted versions of Katz-Bonacich centrality.</h2>

<h3>Description</h3>

<p>Implement a number of modifications to the linear-in-means model to obtain different weighted versions of Katz-Bonacich centrality.
</p>


<h3>Usage</h3>

<pre><code class="language-R">net_dep(
  formula = formula(),
  data = list(),
  G = list(),
  model = c("model_A", "model_B"),
  estimation = c("NLLS", "MLE"),
  hypothesis = c("lim", "het", "het_l", "het_r", "par", "par_split_with",
    "par_split_btw", "par_split_with_btw"),
  endogeneity = FALSE,
  correction = NULL,
  first_step = NULL,
  z = NULL,
  formula_first_step = NULL,
  exclusion_restriction = NULL,
  start.val = NULL,
  to_weight = NULL,
  time_fixed_effect = NULL,
  ind_fixed_effect = NULL,
  mle_controls = NULL,
  kappa = NULL,
  delta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class <code>formula</code>: a symbolic description of the model to be fitted. The constant (i.e. intercept) and the autogressive parameter needs not to be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an object of class <code>data.frame</code> containing the variables in the model. If data are longitudinal, observations must be ordered by time period and then by individual.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>an object of class <code>Matrix</code> representing the social network. Row and column names must be specified and match the order of the observations in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>string. One of <code>c("model_A","model_B")</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimation</code></td>
<td>
<p>string. One of <code>c("NLLS","MLE")</code>. They are used to implement respectively a non-linear least square and a Maximum Likelihood estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hypothesis</code></td>
<td>
<p>string. One of <code>c("lim","het", "het_l", "het_r", "par", "par_split_with", "par_split_btw", "par_split_with_btw")</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endogeneity</code></td>
<td>
<p>logical. Default is <code>FALSE</code>. If <code>TRUE</code>, <code>net_dep</code> implements a two-step correction procedure to control for the endogeneity of the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>
<p>Default is <code>NULL</code>. If <code>endogeneity = TRUE</code>, it is required to specify if the main regression should use an instrumental variable ("iv") or Heckman ("heckman") approach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first_step</code></td>
<td>
<p>Default is NULL. If <code>endogeneity = TRUE</code>, it requires to specify one of <code>c("standard","fe", "shortest", "coauthors", "degree")</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>numeric vector. It specifies the source of heterogeneity for peer effects when <code>hypothesis</code> is equal to <code>"het"</code>, <code>"het_l"</code>, or <code>"het_r"</code>. Alternatively, it specifies the groups in which the network should be partitioned when <code>hypothesis</code> is equal to <code>"par"</code>, <code>"par_split_with"</code>, <code>"par_split_btw"</code>, or <code>"par_split_with_btw")</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula_first_step</code></td>
<td>
<p>an optional object of class <code>formula</code>. If provided, it is used to implement the first step of the estimation when <code>endogeneity = TRUE</code>. The name of the dependent variable must be the same used in the field  <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclusion_restriction</code></td>
<td>
<p>an object of class <code>Matrix</code> representing the exogenous matrix used to instrument the endogenous social network, if <code>endogeneity = TRUE</code>.  Row and column names must be specified and match the order of the observations in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.val</code></td>
<td>
<p>an optional list containing the starting values for the estimations. Object names must match the names provided in <code>formula</code>. It is also required to specify the value of both the constant and the decay parameter(s). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to_weight</code></td>
<td>
<p>an optional vector of weights to be used in the fitting process to indicate that different observations have different variances. Should be <code>NULL</code> or a numeric vector. If non-<code>NULL</code>, it can be used to fit a weighted non-linear least squares (<code>estimation = "NLLS"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_fixed_effect</code></td>
<td>
<p>an optional string. It indicates the name of the time index used in formula. It is used for models with longitudinal data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind_fixed_effect</code></td>
<td>
<p>an optional string. Default is <code>NULL</code>. It indicates the name of the individual index contained in the data. If provided, individual fixed effects are automatically added to the <code>formula</code> of the main equation. If <code>endogeneity = TRUE</code>, the field <code>first_step</code> is overridden, and automatically set equal to <code>"fe"</code>. It is used for models with longitudinal data. Observe that inclusion of individual fixed effects is in its beta version. When <code>estimation == "MLE"</code>, <code>net_dep</code> is guaranteed to work only if <code>hypothesis == "lim"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mle_controls</code></td>
<td>
<p>a list allowing the user to set upper and lower bounds for control variables in MLE estimation and the variance for the ML estimator. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>a normalization level with default equals 1 used in MLE estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Default is <code>NULL</code>. To be used when <code>estimation = "NLLS"</code>. It has to be a number between zero (included) and one (excluded). When used, <code>econet</code> performs a constrained NLLS estimation. In this case, the estimated peer effect parameter, taken in absolute value, is forced to be between the spectral radius of <code>G</code> and its opposite value. Specifically, <code>delta</code> is a penalizing factor, decreasing the goodness of fit of the NLLS estimation, when the peer effect parameter approaches one of the two bounds. Observe that very high values of <code>delta</code> may cause NLLS estimation not to converge.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Agent's parameter-dependent centrality is obtained as a function of </p>

<ul>
<li>
<p> the agent's characteristics and the performance of its socially connected peers, as in Battaglini, Leone Sciabolazza, Patacchini (2020), if <code>model = "model_B"</code>;
</p>
</li>
<li> <p>the performance of its socially connected peers, as in Battaglini, Patacchini (2018), if <code>model = "model_A"</code>.
</p>
</li>
</ul>
<p>Peer effects are assumed to be homogenous if <code>hypothesis = "lim"</code>. They are assumed to be heterogenous by setting:</p>

<ul>
<li> <p><code>hypothesis = "het"</code>, when peers' performance is susceptible to agent's characteristics and <code>model = "model_A"</code>.
</p>
</li>
<li> <p><code>hypothesis = "het_l"</code>, when peers' performance is susceptible to agent's characteristics and <code>model = "model_B"</code>.
</p>
</li>
<li> <p><code>hypothesis = "het_r"</code>, when agent's performance is susceptible to peers' characteristics and <code>model = "model_B"</code>.
</p>
</li>
<li> <p><code>hypothesis = "par"</code>, when <code>model = "model_B"</code>, if the network is formed by interactions between and within two different groups.
</p>
</li>
<li> <p><code>hypothesis = "par_split_with"</code>, when <code>model = "model_B"</code>, if the network is formed by interactions between and within two different groups, and interactions within each group are different from the other.
</p>
</li>
<li> <p><code>hypothesis = "par_split_btw"</code>, when <code>model = "model_B"</code>, if the network is formed by interactions between and within two different groups, and interactions between groups are different according to their direction.
</p>
</li>
<li> <p><code>hypothesis = "par_split_with_btw"</code>, when <code>model = "model_B"</code>, if the network is formed by interactions between and within two different groups, interactions within each group are different from the other, and interactions between groups are different according to their direction.
</p>
</li>
</ul>
<p>When <code>hypothesis</code> is equal to <code>"het"</code>, <code>"het_l"</code>, or <code>"het_r"</code>, the argument <code>z</code> is used to specify the source of heterogeneity: i.e. the attribute affecting the ability of the agent to influence or be influenced by peers.
When <code>hypothesis</code> is equal to <code>"par"</code>, <code>"par_split_with"</code>, <code>"par_split_btw"</code>, or <code>"par_split_with_btw"</code> the argument <code>"z"</code> is used to partition observations in two groups: e.g. the generic element <em>i</em> of vector <code>z</code> takes the value 1 if agent <em>i</em> is member of the first group, and it takes 2 otherwise. <br><br>
If <code>endogeneity = TRUE</code>, a two-step estimation is implemented to control for network endogeneity. The argument <code>first_step</code> is used to control for the specification of the first-step model, e.g.:
</p>

<ul>
<li> <p><code>first_step = "standard"</code> is used when agents' connection are predicted by the differences in their characteristics (i.e. those on the right hand side of <code>formula</code>), and an <code>exclusion_restriction</code>: i.e., their connections in a different network.
</p>
</li>
<li> <p><code>first_step = "fe"</code> adds to the <code>standard</code> model, individual fixed effects, as in Graham (2017).
</p>
</li>
<li> <p><code>first_step = "shortest"</code> adds to the <code>standard</code> model, the shortest distance between <em>i</em> and <em>j</em>, excluding the link between <em>i</em> and <em>j</em> itself, as in Fafchamps et al (2010).
</p>
</li>
<li> <p><code>first_step = "coauthor"</code> adds to the <code>standard</code> model, the number of shared connections between <em>i</em> and <em>j</em>, as in Graham (2015).
</p>
</li>
<li> <p><code>first_step = "degree"</code> adds to the <code>standard</code> model, the difference in the degree centrality of <em>i</em> and <em>j</em>.
</p>
</li>
</ul>
<p>The argument <code>start.val</code> is used to specify starting estimates. This can be done with a named list. If a factor is present, a value for each <code>treatment contrast</code> must be provided. Labels of <code>treatment contrast</code>s must be assigned following R model design standards: e.g., a number is appended to contrast names as in <code>contrasts()</code>. <br>
The starting value referring to the intercept (constant) must be labelled as "alpha". The label(s) for decay parameter(s) must be:
</p>

<ul>
<li> <p><code>"phi"</code>, if <code>hypothesis="lim"</code> or  <code>hypothesis="het"</code>
</p>
</li>
<li> <p><code>"theta_0","theta_1"</code>, if <code>hypothesis="het_l"</code>
</p>
</li>
<li> <p><code>"eta_0","eta_1"</code>, if <code>hypothesis="het_r"</code>
</p>
</li>
<li> <p><code>"phi_within","phi_between"</code>, if <code>hypothesis="par"</code>
</p>
</li>
<li> <p><code>"phi_within_0","phi_within_1","phi_between"</code>, if <code>hypothesis="par_split_with"</code>
</p>
</li>
<li> <p><code>"phi_within","phi_between_0","phi_between_1"</code>, if <code>hypothesis="par_split_btw"</code>
</p>
</li>
<li> <p><code>"phi_within_0","phi_within_1","phi_between_0","phi_between_1"</code>, if <code>hypothesis="par_split_with_btw"</code>
</p>
</li>
</ul>
<p>The interaction term when <code>hypothesis="het"</code> must be labelled  <code>"gamma"</code>. The label to be used for unobservables when <code>endogeneity = TRUE</code> is <code>"unobservables"</code>. When <code>estimation = "MLE"</code>, it is required to set also the starting value for the variance of the ML estimator. This should be labelled as "sigma". <br>
The argument <code>mle_controls</code> takes a list of two objects. The first is a named numeric vector used to set upper and lower bounds for control variables. The second object is a vector used to set upper (first value) and lower (second value) bounds for the variance of the Maximum Likelihood estimator.<br>
Names in <code>mle_controls</code> must be equal to those used in <code>start.val</code>.
For additional details, see the vignette (doi:10.18637/jss.v102.i08).
</p>


<h3>Value</h3>

<p>A list of three objects: i) Estimates of the main regression; ii) The vector of agents' parameter-dependent centrality; iii) Estimates of the first-step regression (if <code>endogeneity = TRUE</code>)
</p>


<h3>References</h3>

<p>Battaglini M., E. Patacchini (2018), "Influencing Connected Legislators," Journal of Political Economy, 126(6): 2277-2322. <br>
Battaglini M., V. Leone Sciabolazza, E. Patacchini (2020), "Effectiveness of Connected Legislators,"  American Journal of Political Science, forthcoming. <br>
Battaglini M., V. Leone Sciabolazza, E. Patacchini, S. Peng (2020), "Econet: An R package for the Estimation of parameter-dependent centrality measures", Mimeo. <br>
Fafchamps, M., M. J. Leij and S. Goyal (2010), “Matching and network effects,” Journal of the European Economic Association, 8(1): 203-231. <br>
Graham B. (2015), “Methods of identification in social networks,” Annual Review of Economics, 7, 465 - 485. <br>
Graham B. (2017), “An econometric model of network formation with degree heterogeneity,” Econometrica 85 (4), 1033 - 1063. <br></p>


<h3>Examples</h3>

<pre><code class="language-R">
# Model A

# Load data
data("a_db_alumni")
data("a_G_alumni_111")
db_model_A &lt;- a_db_alumni
G_model_A &lt;- a_G_alumni_111
are_factors &lt;- c("party", "gender", "nchair", "isolate")
db_model_A[are_factors] &lt;- lapply(db_model_A[are_factors] ,factor)
db_model_A$PAC &lt;- db_model_A$PAC/1e+06

# Specify formula
f_model_A &lt;- formula("PAC ~ gender + party + nchair + isolate")

# Specify starting values
starting &lt;- c(alpha = 0.47325,
              beta_gender1 = -0.26991,
              beta_party1 = 0.55883,
              beta_nchair1 = -0.17409,
              beta_isolate1 = 0.18813,
              phi = 0.21440)

# Fit Linear-in-means model
lim_model_A &lt;- net_dep(formula = f_model_A, data = db_model_A,
                       G = G_model_A, model = "model_A", estimation = "NLLS",
                       hypothesis = "lim", start.val = starting)

summary(lim_model_A)
lim_model_A$centrality

# Test Heterogeneity

# Heterogeneous factor
z &lt;- as.numeric(as.character(db_model_A$gender))

# Specify formula
f_het_model_A &lt;- formula("PAC ~ party + nchair + isolate")

# Specify starting values
starting &lt;- c(alpha = 0.44835,
              beta_party1 = 0.56004,
              beta_nchair1 = -0.16349,
              beta_isolate1 = 0.21011,
              beta_z = -0.26015,
              phi = 0.34212,
              gamma = -0.49960)

# Fit model
het_model_A &lt;- net_dep(formula = f_het_model_A, data = db_model_A,
                       G = G_model_A, model = "model_A", estimation = "NLLS",
                       hypothesis = "het", z = z, start.val = starting)

summary(het_model_A)
het_model_A$centrality

# Model B

# Load data
data("db_cosponsor")
data("G_alumni_111")
db_model_B &lt;- db_cosponsor
G_model_B &lt;- G_cosponsor_111
G_exclusion_restriction &lt;- G_alumni_111
are_factors &lt;- c("party", "gender", "nchair")
db_model_B[are_factors] &lt;- lapply(db_model_B[are_factors], factor)

# Specify formula
f_model_B &lt;- formula("les ~ gender + party + nchair")

# Specify starting values
starting &lt;- c(alpha = 0.23952,
              beta_gender1 = -0.22024,
              beta_party1 = 0.42947,
              beta_nchair1 = 3.09615,
              phi = 0.40038,
              unobservables = 0.07714)

# Fit Linear-in-means model
lim_model_B &lt;- net_dep(formula = f_model_B, data = db_model_B,
                       G = G_model_B, model = "model_B", estimation = "NLLS",
                       hypothesis = "lim", endogeneity = TRUE,
                       correction = "heckman", first_step = "standard",
                       exclusion_restriction = G_exclusion_restriction,
                       start.val = starting)

summary(lim_model_B)
lim_model_B$centrality
summary(lim_model_B, print = "first.step")

# Test Heterogeneity

# Heterogeneous factor (node -level)
z &lt;- as.numeric(as.character(db_model_B$gender))

# Specify formula
f_het_model_B &lt;- formula("les ~ party + nchair")

# Specify starting values
starting &lt;- c(alpha = 0.23952,
              beta_party1 = 0.42947,
              beta_nchair1 = 3.09615,
              beta_z = -0.12749,
              theta_0 = 0.42588,
              theta_1 = 0.08007)

# Fit model
het_model_B_l &lt;- net_dep(formula = f_het_model_B,
                         data = db_model_B,
                         G = G_model_B, model = "model_B", estimation = "NLLS",
                         hypothesis = "het_l", z = z, start.val = starting)

# Store and print results
summary(het_model_B_l)
het_model_B_l$centrality

# Specify starting values
starting &lt;- c(alpha = 0.04717,
              beta_party1 = 0.51713,
              beta_nchair1 = 3.12683,
              beta_z = 0.01975,
              eta_0 = 1.02789,
              eta_1 = 2.71825)

# Fit model
het_model_B_r &lt;- net_dep(formula = f_het_model_B,
                         data = db_model_B,
                         G = G_model_B, model = "model_B", estimation = "NLLS",
                         hypothesis = "het_r", z = z, start.val = starting)

# Store and print results
summary(het_model_B_r)
het_model_B_r$centrality

# Heterogeneous factor (edge -level)
z &lt;- as.numeric(as.character(db_model_B$party))

# Specify starting values
starting &lt;- c(alpha = 0.242486,
              beta_gender1 = -0.229895,
              beta_party1 = 0.42848,
              beta_nchair1 = 3.0959,
              phi_within  = 0.396371,
              phi_between = 0.414135)

# Fit model
party_model_B &lt;- net_dep(formula = f_model_B, data = db_model_B,
                         G = G_model_B, model = "model_B",
                         estimation = "NLLS", hypothesis = "par",
                         z = z, start.val = starting)

# Store and print results
summary(party_model_B)
party_model_B$centrality

# WARNING, This toy example is provided only for runtime execution.
# Please refer to previous examples for sensible calculations.
data("db_alumni_test")
data("G_model_A_test")
db_model_A &lt;- db_alumni_test
G_model_A &lt;- G_model_A_test
f_model_A &lt;- formula("les ~ dw")
lim_model_A_test &lt;- net_dep(formula = f_model_A, data = db_model_A,
                       G = G_model_A, model = "model_A", estimation = "NLLS",
                       hypothesis = "lim", start.val = c(alpha = 0.09030594,
                                                         beta_dw = 1.21401940,
                                                         phi = 1.47140647))
summary(lim_model_A_test)
</code></pre>


</div>