<div class="container">

<table style="width: 100%;"><tr>
<td>workhorses</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>elisr's quadriga</h2>

<h3>Description</h3>

<p>The four workhorses inside <code>elisr</code>'s user functions
<code>disjoint()</code> and <code>overlap()</code>.
</p>
<p><code>disj_pci()</code> is a loop which runs through the following
steps: (1) Set up a (first) scale. (2) Find the two items with the highest
positive correlation in the data set. (3) If the absolute value of this
correlation is greater than the pre-specified lower bound
(<code>mrit_min</code>), add up the two items to build the core of the emerging
scale. (4) As long as the value of the correlation between the sum-score
and a remaining item in the data frame is greater than <code>mrit_min</code>,
flavor the scale with the appropriate item. (5) If there are at least two
leftovers in the data frame that meet the inclusion criterion, start over
again.
</p>
<p><code>disj_nci()</code> is almost identical to <code>disj_pci()</code>,
though step (4) varies slightly from above. To take negative correlations
into account, <code>disj_nci()</code> flavors the scale with appropriate item as
long as the <em>absolute</em> value of the correlation between the sum-score
and a remaining items in the data frame is greater than <code>mrit_min</code>.
</p>
<p><code>ovlp_pci()</code> takes a disjointedly built scale fragment and
tries to extend it with those items in the data set, which are not yet
built into the fragment (aka., its counterpart). Because <code>ovlp_pci()</code>
does this for every disjointedly built scale fragment it is a multiple
one-dimensional extension of <code>disj_pci()</code>.
</p>
<p>The only difference to <code>ovlp_pci()</code> is that
<code>ovlp_nci()</code> can handle reversed items. The extension algorithm
remains almost the same; <code>ovlp_nci()</code> flavors <em>each</em> scale
fragment with appropriate items from its counterpart as long as the
<em>absolute</em> value of the correlation between the sum-score and a
remaining item is greater than <code>mrit_min</code>. Thus, it is a multiple
one-dimensional extension of <code>disj_nci()</code>:
</p>


<h3>Usage</h3>

<pre><code class="language-R">disj_pci(df, mrit_min, use)

disj_nci(df, mrit_min, sclvals, use)

ovlp_pci(msdf, mrit_min, overlap_with, use)

ovlp_nci(msdf, mrit_min, overlap_with, sclvals, use)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>a data frame object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mrit_min</code></td>
<td>
<p>a numerical constant to specify the marginal corrected item
total correlation. The value must be in the range of 0-1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use</code></td>
<td>
<p>an optional string to specify how missing values will enter the
analysis. See <code>use</code> in <code>cor</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sclvals</code></td>
<td>
<p>a numerical vector of length 2 indicating the start- and
endpoint of a scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msdf</code></td>
<td>
<p>a multiple scaled data frame (built with <code>disjoint()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overlap_with</code></td>
<td>
<p>a string telling <code>overlap()</code> the set of items for
the extension. To build up on all variables of a fragment use
<code>fragment</code>, for the core-only option type <code>core</code>. The default is
set to "fragment".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All functions are internal functions.
</p>
<p>The <code>use</code> argument specifies how to set up a correlation matrix in the
presence of missing values. In a typical scaling process this happens at
least twice. First, when determining the core items (the two items in the
correlation matrix with the highest linear relationship). Second, when an
item is proposed for an emerging scale.
</p>
<p>Note that all functions use <code>cor</code>'s default method
<code>pearson</code>.
</p>


<h3>Value</h3>

<p><code>disj_pci()</code> and <code>disj_nci()</code> both return a list of data
frames which result from applying the above-mentioned algorithm.
</p>
<p><code>ovlp_pci()</code> and <code>ovlp_nci()</code> often return an
<em>extended</em> a list of data frames.
</p>


<h3>References</h3>

<p>Müller-Schneider, T. (2001). Multiple Skalierung nach dem
Kristallisationsprinzip / Multiple Scaling According to the Principle of
Crystallization. Zeitschrift für Soziologie, 30(4), 305-315.
https://doi.org/10.1515/zfsoz-2001-0404
</p>


</div>