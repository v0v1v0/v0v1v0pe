<div class="container">

<table style="width: 100%;"><tr>
<td>trapply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A method of the generic function by for objects of class 'trackdata'</h2>

<h3>Description</h3>

<p>A given function 'FUN' is applied to the data corresponding to each segment
of data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">trapply(trackdata, fun, ..., simplify = FALSE, returntrack = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>trackdata</code></td>
<td>
<p>a track data object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>a function that is applied to each segment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments of the function fun</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>simplify = TRUE , output is a matrix; simplify = FALSE a
list is returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returntrack</code></td>
<td>
<p>returntrack = FALSE , return a trackdata object</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>trapply() applies a function iteratively to each segment of a trackdata
object without the need for using a for-loop. It can be used to calculate,
for example, the mean value of the data values of each segment separately.
Any function that can be applied sensibly to trackdata[j]$data where j is
a segment number can be used as the fun argument to trapply(). It is also
possible to write your own function and use trapply() to apply it
separately to each segment. Care needs to be taken in using trapply() in
the following two ways. Firstly, the argument simplify=TRUE should only be set
if it can be guaranteed that a vector of the same length or matrix of the
same number of rows as the number of segments in the trackdata object is
returned. For example, simplify=TRUE can be used in calculating the mean per
segment of a trackdata object, because there will only be one value (the
mean) per segment. However, simplify should be set to FALSE in calculating the
range because here two values are returned per segment. Similarly use
simplify=FALSE n smoothing the data in which the number of values returned per
segment is different.  Secondly, trapply() only applies a function to a
single parameter; the function can be used to apply to a function to
multi-parameter trackdata such as F1-F4, but then the function needs to be
put inside apply() - see examples below.
</p>


<h3>Value</h3>

<p>list or vector or matrix
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code>apply</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# mean f0 one value per segment
m = trapply(vowlax.fund, mean, simplify=TRUE)
# mean F1 - F4
m = trapply(vowlax.fdat, apply, 2, mean, simplify=TRUE)
# make a logical vector of any segments that have an F1 value
# between their start time and end time greater than n Hz
pfun &lt;- function(x, n=1000) any(x &gt; n)
# greater than 1100 Hz
temp = trapply(vowlax.fdat[,1], pfun, 1100, simplify=TRUE)
# get the F2-range per segment
r = trapply(vowlax.fdat[,2], range)
# F2-range of 20th segment
r[[20]]
# DCT-smooth F2 with 10 coeffs
# get the first 4 DCT coefficients
f2.dct = trapply(vowlax.fdat[,2], dct, 3, simplify=TRUE)
# dct-smooth F2 with the first 5 DCT coeffs
f2sm = trapply(vowlax.fdat[,2], dct, 4, TRUE,  returntrack=TRUE)
# Make new F2 trackdata such that each segment has
# F2 divided by its F2 range
pfun &lt;- function(x) x/(diff(abs(range(x))))
newf2 = trapply(vowlax.fdat[,2], pfun, returntrack=TRUE)

</code></pre>


</div>