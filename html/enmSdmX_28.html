<div class="container">

<table style="width: 100%;"><tr>
<td>geoFold</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Assign geographically-distinct k-folds</h2>

<h3>Description</h3>

<p>This function generates geographically-distinct cross-validation folds, or "geo-folds" ("g-folds" for short). Points are grouped by proximity to one another. Folds can be forced to have at least a minimum number of points in them. Results are deterministic (i.e., the same every time for the same data). <br><br>
More specifically, g-folds are created using this process:
</p>

<ul>
<li>
<p> To start, all pairwise distances between points are calculated. These are used in a clustering algorithm to create a dendrogram of relationships by distance. The dendrogram is then "cut" so it has <code>k</code> groups (folds). If each fold has at least the minimum desired number of points (<code>minIn</code>), then the process stops and fold assignments are returned.
</p>
</li>
<li>
<p> However, if at least one fold has fewer than the desired number of points, a series of steps is executed.
</p>

<ul>
<li>
<p> First, the fold with a centroid that is farthest from all others is selected. If it has sufficient points, then the next-most distant fold is selected, and so on.
</p>
</li>
<li>
<p> Once a fold is identified that has fewer than the desired number of points, it is grown by adding to it the points closest to its centroid, one at a time. Each time a point is added, the fold centroid is calculated again. The fold is grown until it has the desired number of points. Call this "fold #1". From hereafter, these points are considered "assigned" and not eligible for re-assignment.
</p>
</li>
<li>
<p> The remaining "unassigned" points are then clustered again, but this time into <code>k - 1</code> folds. And again, the most-distant group found that has fewer than the desired number of points is found. This fold is then grown as before, using only unassigned points. This fold then becomes "fold #2."
</p>
</li>
<li>
<p> The process repeats iteratively until there are <code>k</code> folds assigned, each with at least the desired number of points. 
</p>
</li>
</ul>
</li>
</ul>
<p>The potential downside of this approach is that the last fold is assigned the remainder of points, so will be the largest. One way to avoid gross imbalance is to select the value of <code>minIn</code> such that it divides the points into nearly equally-sized groups.<br><br></p>


<h3>Usage</h3>

<pre><code class="language-R">geoFold(x, k, minIn = 1, longLat = 1:2, method = "complete", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A "spatial points" object of class <code>SpatVector</code>, <code>sf</code>, <code>data.frame</code>, or <code>matrix</code>. If <code>x</code> is a <code>data.frame</code> or <code>matrix</code>, then the points will be assumed to have the WGS84 coordinate system (i.e., unprojected).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Numeric: Number of folds to create.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minIn</code></td>
<td>
<p>Numeric: Minimum number of points required to be in a fold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longLat</code></td>
<td>
<p>Character or integer vector: This is ignored if <code>x</code> is a <code>SpatVector</code> or <code>sf</code> object. However, if <code>x</code> is a <code>data.frame</code> or <code>matrix</code>, then this should be a character or integer vector specifying the columns in <code>x</code> corresponding to longitude and latitude (in that order). For example, <code>c('long', 'lat')</code> or <code>c(1, 2)</code>. The default is to assume that the first two columns in <code>x</code> represent coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character: Method used by <code>hclust</code> to cluster points. By default, this is <code>'single'</code>, but in some cases this may result in strange clustering (especially when there is a large number of points). The <code>'complete'</code> method (or others) may give more reasonable results in these cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments (unused)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that in general it is probably mathematically impossible to cluster points in 2-dimensional space into <code>k</code> groups, each with at least <code>minIn</code> points, in a manner that seems "reasonable" to the eye in all cases. In experimentation, "unreasonable" results often appear when the number of groups is high.
</p>


<h3>Value</h3>

<p>A vector of integers the same length as the number of points in <code>x</code>. Each integer indicates which fold a point in <code>x</code> belongs to.
</p>


<h3>See Also</h3>

<p><code>geoFoldContrast</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(sf)
library(terra)

# lemur occurrence data
data(mad0)
data(lemurs)
crs &lt;- getCRS('WGS84')
ll &lt;- c('longitude', 'latitude')

# use occurrences of all species... easier to see on map
occs &lt;- st_as_sf(lemurs, coords = ll, crs = getCRS('WGS84'))

# create 100 background points
mad0 &lt;- vect(mad0)
bg &lt;- spatSample(mad0, 100)

### assign 3 folds to occurrences and to background sites
k &lt;- 3
minIn &lt;- floor(nrow(occs) / k) # maximally spread between folds

presFolds &lt;- geoFold(occs, k = k, minIn = minIn)
bgFolds &lt;- geoFoldContrast(bg, pres = occs, presFolds = presFolds)

# number of sites per fold
table(presFolds)
table(bgFolds)

# map
plot(mad0, border = 'gray', main = paste(k, 'geo-folds'))
plot(bg, pch = 3, col = bgFolds + 1, add = TRUE)
plot(st_geometry(occs), pch = 20 + presFolds, bg = presFolds + 1, add = TRUE)

legend(
	'bottomright',
	legend = c(
		'presence fold 1',
		'presence fold 2',
		'presence fold 3',
		'background fold 1',
		'background fold 2',
		'background fold 3'
	),
	pch = c(21, 22, 23, 3, 3),
	col = c(rep('black', 3), 2, 3),
	pt.bg = c(2, 3, 4, NA, NA)
)
</code></pre>


</div>