<div class="container">

<table style="width: 100%;"><tr>
<td>Lexis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a Lexis object of follow-up</h2>

<h3>Description</h3>

<p>Create an object of class <code>Lexis</code> to represent follow-up in
multiple states on multiple time scales.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Lexis( entry,
        exit,
    duration,
entry.status = 0,
 exit.status = 0,
          id,
        data,
       merge = TRUE,
      states,
       notes = TRUE,
         tol = .Machine$double.eps^0.5,
keep.dropped = FALSE)
## S3 method for class 'Lexis'
print(x, ...,
                      td = 2,
                      nd = 3,
                    rnam = FALSE,
                     org = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>entry</code></td>
<td>
<p>a named list of entry times. Each element of the list is
a numeric variable representing the entry time on the named time
scale. The name of the elements of the list will appear as names of
variables designated as timescales in the resulting object. All time
scales must have the same units (e.g. years). 
The names of the timescales must be different from any column name in
<code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exit</code></td>
<td>
<p>a named list of exit times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>duration</code></td>
<td>
<p>a numeric vector giving the duration of follow-up.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>entry.status</code></td>
<td>
<p>a vector or a factor giving the status at
entry</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exit.status</code></td>
<td>
<p>a vector or factor giving status at exit. Any
change in status during follow-up is assumed to take place exactly
at the exit time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>a vector giving a unique identity value for each person
represented in the Lexis object. Defaults to <code>1:nrow(data)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list, or environment containing
the variables. If  not found in <code>data</code>, the variables are
taken from the environment from which <code>Lexis</code> was called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge</code></td>
<td>
<p>a logical flag. If <code>TRUE</code> then the <code>data</code>
argument will be coerced to a data frame and then merged with
the resulting <code>Lexis</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>states</code></td>
<td>
<p>A vector of labels for the states. If given, the state
variables <code>lex.Cst</code> and <code>lex.Xst</code> are returned as factors with
identical levels attributes equal to <code>states</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notes</code></td>
<td>
<p>Logical. Should notes on entry states and time be given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Numerical tolerance for follow-up time. Rows with duration
less than this value are automatically dropped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.dropped</code></td>
<td>
<p>Logical. Should dropped rows from <code>data</code> be
saved as an attribute with the object for inspection?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>Lexis</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>td</code></td>
<td>
<p>Number of digits after the decimal separator used for
timescales and <code>lex.dur</code> when printing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nd</code></td>
<td>
<p>Number of digits after the decimal separator used for other
numerical variables in the <code>Lexis</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rnam</code></td>
<td>
<p>Logical, should row names be printed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>org</code></td>
<td>
<p>Logical, should columns be printed in the original order?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> ... </code></td>
<td>
<p>Other parameters passed on to <code>print.data.frame</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The analysis of long-term population-based follow-up studies typically
requires multiple time scales to be taken into account, such as
age, calendar time, or time since an event. A <code>Lexis</code> object is
a data frame with additional attributes that allows these multiple time
dimensions of follow-up to be managed.
</p>
<p>Separate variables for current end exit state allows representation of
multistate data.
</p>
<p>Lexis objects are named after the German demographer Wilhelm
Lexis (1837-1914), who is credited with the invention of the
"Lexis diagram" for representing population dynamics simultaneously
by several timescales in the book
"Einleitung in die Theorie der Bevolkerungsstatistik" from 1875. 
</p>
<p>The <code>Lexis</code> function can create a minimal <code>Lexis</code> object
with only those variables required to define the follow-up history in
each row. Additional variables can be merged into the <code>Lexis</code>
object using the <code>merge</code> method for <code>Lexis</code> objects. The
latter is the default.
</p>
<p>The <code>print</code> method prints the time-scale variables and other
numerical variables rounded, possibly differently. Reorders columns so
the Lexis-specific variables comes first. Returns (invisibly) a character
vector with the (re)ordering of the columns in the object, even if
<code>org = TRUE</code> is set.
</p>
<p>There are also <code>merge</code>, <code>subset</code>, <code>transform</code> and many
other methods for <code>Lexis</code> objects. They work as the corresponding
methods for data-frames but ensures that the result is a <code>Lexis</code>
object.
</p>


<h3>Value</h3>

<p>An object of class <code>Lexis</code>. This is represented as a data frame
with a column for each time scale (with names equal to the union of
the names of <code>entry</code> and <code>exit</code>), and additional columns with the
following names:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lex.id</code></td>
<td>
<p>Identification of the persons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lex.dur</code></td>
<td>
<p>Duration of follow-up.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lex.Cst</code></td>
<td>
<p>Entry status (<code>C</code>urrent <code>st</code>ate),
i.e. the state in which the follow up takes place.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lex.Xst</code></td>
<td>
<p>Exit status (e<code>X</code>it <code>st</code>ate),
i.e. that state taken up after <code>dur</code> in <code>lex.Cst</code>.</p>
</td>
</tr>
</table>
<p>If <code>merge=TRUE</code> (the default) then the <code>Lexis</code> object will
also contain all variables from the <code>data</code> argument.
</p>


<h3>Note</h3>

<p>Only two of the three arguments <code>entry</code>, <code>exit</code> and
<code>duration</code> need to be given.  If the third parameter is missing,
it is imputed.
</p>
<p><code>entry</code>, <code>exit</code> must be numeric, using  <code>Date</code>
variables will cause some of the utilities to crash. Transformation by
<code>cal.yr</code> is recommended.
</p>
<p>If only either <code>exit</code> or <code>duration</code> are supplied it is
assumed that <code>entry</code> is 0. This is only meaningful (and therefore
checked) if there is only one timescale.
</p>
<p>If any of <code>entry.status</code> or <code>exit.status</code> are of mode character,
they will both be converted to factors.
</p>
<p>If <code>entry.status</code> is not given, then its class is automatically
set to that of <code>exit.status</code>. If <code>exit.status</code> is a
character or factor, the value of <code>entry.status</code> is set to the
first level. This may be highly undesirable, and therefore noted. For
example, if <code>exit.status</code> is character the first level will be
the first in the alphabetical ordering; slightly unfortunate if values
are <code>c("Well","Diseased")</code>. If <code>exit.status</code> is logical, the
value of <code>entry.status</code> set to <code>FALSE</code>. If
<code>exit.status</code> is numeric, the value of <code>entry.status</code> set to
0.
</p>
<p>If <code>entry.status</code> or <code>exit.status</code> are factors or character,
the corresponding state variables in the returned <code>Lexis</code> object,
<code>lex.Cst</code> and <code>lex.Xst</code> will be (unordered) factors with
identical set of levels, namely the union of the levels of
<code>entry.status</code> and <code>exit.status</code>.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer with contributions from Bendix Carstensen</p>


<h3>See Also</h3>

<p><code>plot.Lexis</code>,
<code>splitLexis</code>,
<code>cutLexis</code>,
<code>mcutLexis</code>,
<code>rcutLexis</code>,
<code>addCov.Lexis</code>,



<code>merge.Lexis</code>,
<code>subset.Lexis</code>,
<code>cbind.Lexis</code>,
<code>rbind.Lexis</code>,
<code>transform.Lexis</code>,
<code>summary.Lexis</code>,
<code>unLexis</code>,
<code>timeScales</code>,
<code>timeBand</code>,
<code>entry</code>,
<code>exit</code>,
<code>transient</code>,
<code>absorbing</code>,
<code>dur</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># A small bogus cohort
xcoh &lt;- structure(list( id = c("A", "B", "C"),
                     birth = c("14/07/1952", "01/04/1954", "10/06/1987"),
                     entry = c("04/08/1965", "08/09/1972", "23/12/1991"),
                      exit = c("27/06/1997", "23/05/1995", "24/07/1998"),
                      fail = c(1, 0, 1) ),
                    .Names = c("id", "birth", "entry", "exit", "fail"),
                 row.names = c("1", "2", "3"),
                     class = "data.frame")

# Convert the character dates into numerical variables (fractional years)
xcoh &lt;- cal.yr(xcoh, format="%d/%m/%Y", wh=2:4)
# xcoh &lt;- cal.yr(xcoh, format="%d/%m/%Y", wh=2:4)

# See how it looks
xcoh
str( xcoh )

# Define a Lexis object with timescales calendar time and age
Lcoh &lt;- Lexis(entry = list(per = entry ),
               exit = list(per = exit,
                           age = exit - birth),
        exit.status = fail,
               data = xcoh)

# Using character states may have undesired effects:
xcoh$Fail &lt;- c("Dead","Well","Dead")
xcoh
L1 &lt;- Lexis(entry = list(per = entry),
             exit = list(per = exit,
                         age = exit - birth),
      exit.status = Fail,
             data = xcoh)
L1
# people start being dead!

# ...unless you order the levels sensibly
xcoh$Fail &lt;- factor(xcoh$Fail, levels = c("Well", "Dead"))
L2 &lt;- Lexis(entry = list(per = entry),
             exit = list(per = exit,
                         age = exit - birth),
      exit.status = Fail,
             data = xcoh)
L2
# behaviour of print method:
L2[,1:6]
L2[,6:1]
print(L2[,6:1], org=TRUE)
(print(L2[,-3]))
</code></pre>


</div>