<div class="container">

<table style="width: 100%;"><tr>
<td>evalMultiAUC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate multivariate weighted AUC</h2>

<h3>Description</h3>

<p>This function calculates a multivariate version of the area under the receiver-operator characteristic curve (AUC). The multivariate version is simply the mean AUC across all possible pairwise AUCs for all cases (Hand &amp; Till 2001). For example, if we have predictions that can be classified into three groups of expectation, say A, B, and C, where we expect predictions assigned to group A are &gt; those in B and C, and predictions in group B are expected to be &gt; those in group C, the multivariate AUC for this situation is <code>mean(wAB * auc_mean(A, B), wAC * auc_mean(A, C), wBC * auc_mean(B, C))</code>, where <code>auc_mean(X, Y)</code>, is the AUC calculated between cases <code>X</code> and <code>Y</code>, and <code>wXY</code> is a weight for that case-comparison.
</p>


<h3>Usage</h3>

<pre><code class="language-R">evalMultiAUC(..., weightBySize = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>A set of two or more numeric vectors <em>or</em> two or more 2-column matrices or data frames. The objects must be listed in order of <em>expected</em> probability. For example, you might have a set of predictions for objects you expect to have a low predicted probability (e.g., long-term absences of an animal), a set that you expect to have middle levels of probability (e.g., sites that were recently vacated), and a set for which you expect a high level of predicted probability (e.g., sites that are currently occupied). In this case you should list the cases in order: low, middle, high. If a 2-column matrix or data frame is supplied, then the first column is assumed to represent predictions and the second assumed to represent site-level weights (see <code>evalAUC</code>). Note that site-level weighting is different from case-level weighting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightBySize</code></td>
<td>
<p>Logical, if <code>FALSE</code> (default) then the multivariate measure of AUC will treat all comparisons as equal (e.g., low versus middle will weigh as much as middle versus high), and so will simply be the mean AUC across all possible comparisons. If <code>TRUE</code> then multivariate AUC is the weighted mean across all possible comparisons where weights are the number of comparisons between each of the two cases. For example, if a set of "low" predictions ("low") has 10 data points, "middle" has 10, and "high" has 20, then the multivariate AUC will be (10 * low + 10 * middle + 20 * high) / (10 + 10 + 20).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Logical. If <code>TRUE</code> then remove any cases in <code>...</code> that are <code>NA</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Named numeric vector. The names will appear as <code>case2_over_case1</code> (which in this example means the AUC of item #1 in the <code>...</code> when compared to the second item in <code>...</code>), plus <code>multivariate</code> (which is the multivariate AUC).
</p>


<h3>References</h3>

<p>Hand, DJ and Till, RJ. 2001. A simple generalisation of the area under the ROC curve for multiple class classification problems. <em>Machine Learning</em> 45:171-186 <a href="https://doi.org/10.1023/A%3A1010920819831">doi:10.1023/A:1010920819831</a>.
</p>


<h3>See Also</h3>

<p><code>pa_evaluate</code>, <code>evalAUC</code>, <code>evalContBoyce</code>, <code>evalThreshold</code>, <code>evalThresholdStats</code>, <code>evalTjursR2</code>, <code>evalTSS</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(123)

# no weights
low &lt;- runif(10)^2
middle &lt;- runif(10)
high &lt;- sqrt(runif(20))

evalMultiAUC(low, middle, high)

# equal weights
low &lt;- matrix(c(low, rep(1, length(low))), ncol=2)
middle &lt;- matrix(c(middle, rep(1, length(middle))), ncol=2)
high &lt;- matrix(c(high, rep(1, length(high))), ncol=2)
evalMultiAUC(low, middle, high)

# equal weights with weighting by number of comparisons
evalMultiAUC(low, middle, high, weightBySize=TRUE)

# unequal weights
middle[ , 2] &lt;- ifelse(middle[ , 1] &gt; 0.5, 0.1, 1)
evalMultiAUC(low, middle, high)

# unequal weights with weighting by number of comparisons
evalMultiAUC(low, middle, high, weightBySize=TRUE)
</code></pre>


</div>