<div class="container">

<table style="width: 100%;"><tr>
<td>joint_tests</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute joint tests of the terms in a model</h2>

<h3>Description</h3>

<p>This function produces an analysis-of-variance-like table based on linear
functions of predictors in a model or <code>emmGrid</code> object. Specifically,
the function constructs, for each combination of factors (or covariates
reduced to two or more levels), a set of (interaction) contrasts via
<code>contrast</code>, and then tests them using <code>test</code> with
<code>joint = TRUE</code>. Optionally, one or more of the predictors may be used as
<code>by</code> variable(s), so that separate tables of tests are produced for
each combination of them.
</p>


<h3>Usage</h3>

<pre><code class="language-R">joint_tests(object, by = NULL, show0df = FALSE, showconf = TRUE,
  cov.reduce = make.meanint(1), ...)

make.meanint(delta)

meanint(x)

make.symmint(ctr, delta)

symmint(ctr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted model, <code>emmGrid</code>, or <code>emm_list</code>. If the
latter, its first element is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>character names of <code>by</code> variables. Separate sets of tests are
run for each combination of these.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show0df</code></td>
<td>
<p>logical value; if <code>TRUE</code>, results with zero numerator
degrees of freedom are displayed, if <code>FALSE</code> they are skipped</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showconf</code></td>
<td>
<p>logical value.
When we have models with estimability issues (e.g., missing cells), then with
<code>showconf = TRUE</code>, we test any remaining effects that are not purely
due to contrasts of a single term. If found, they are labeled
<code>(confounded)</code>. See
<code>vignette("xplanations")</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.reduce</code></td>
<td>
<p>a function.
If <code>object</code> is a fitted model, it is
replaced by <code>ref_grid(object, cov.reduce = cov.reduce, ...)</code>.
For this purpose, the functions <code>meanint</code> and <code>symmint</code> are
available for returning an interval around the mean or around zero,
respectively. Se the section below on covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>ref_grid</code> and <code>emmeans</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta, ctr</code></td>
<td>
<p>arguments for <code>make.meanint</code> and <code>make.symmint</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>argument for <code>meanint</code> and <code>symmint</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In models with only factors, no covariates, these tests correspond to
“type III” tests a la <span class="pkg">SAS</span>, as long as equal-weighted averaging
is used and there are no estimability issues. When covariates are present and
they interact with factors, the results depend on how the covariate is
handled in constructing the reference grid. See the section on covariates
below. The point that one must always remember is that <code>joint_tests</code>
always tests contrasts among EMMs, in the context of the reference grid,
whereas type III tests are tests of model coefficients – which may or may
not have anything to do with EMMs or contrasts.
</p>


<h3>Value</h3>

<p>a <code>summary_emm</code> object (same as is produced by 
<code>summary.emmGrid</code>). All effects for which there are no
estimable contrasts are omitted from the results. 
There may be an additional row named <code>(confounded)</code> which accounts
for additional degrees of freedom for effects not accounted for in the 
preceding rows.
</p>
<p>The returned object also includes an <code>"est.fcns"</code> attribute, which is a
named list containing the linear functions associated with each joint test. 
No estimable functions are included for confounded effects.
</p>
<p><code>make.meanint</code> returns the function 
<code>function(x) mean(x) + delta * c(-1, 1)</code>,
and <code>make.symmint(ctr, delta)</code> returns the function
<code>function(x) ctr + delta * c(-1, 1)</code>
(which does not depend on <code>x</code>).
The cases with <code>delta = 1</code>, <code>meanint = make.meanint(1)</code> 
and <code>symmint(ctr) = make.symmint(ctr, 1)</code>
are retained for back-compatibility reasons.
These functions are available primarily for use with <code>cov.reduce</code>.
</p>


<h3>Dealing with covariates</h3>

<p>A covariate (or any other predictor) must have <em>more than one value in 
the reference grid</em> in order to test its effect and be included in the results.
Therefore, when <code>object</code> is a model, we default to <code>cov.reduce = meanint</code>
which sets each covariate at a symmetric interval about its mean. But
when <code>object</code> is an existing reference grid, it often has only one value 
for covariates, in which case they are excluded from the joint tests.
</p>
<p>Covariates present further complications in that their values in the
reference grid can affect the joint tests of <em>other</em> effects. When
covariates are centered around their means (the default), then the tests we
obtain can be described as joint tests of covariate-adjusted means; and that
is our intended use here. However, some software such as <span class="pkg">SAS</span> and
<code>car::Anova</code> adopt the convention of centering covariates around zero;
and for that purpose, one can use <code>cov.reduce = symmint(0)</code> when calling
with a model object (or in constructing a reference grid). However, adjusted
means with covariates set at or around zero do not make much sense in the
context of interpreting estimated marginal means, unless the covariate means
really are zero.
</p>
<p>See the examples below with the <code>toy</code> dataset.
</p>


<h3>See Also</h3>

<p><code>test</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">pigs.lm &lt;- lm(log(conc) ~ source * factor(percent), data = pigs)

(jt &lt;- joint_tests(pigs.lm))             ## will be same as type III ANOVA

### Estimable functions associated with "percent"
attr(jt, "est.fcns") $ "percent"

joint_tests(pigs.lm, weights = "outer")  ## differently weighted

joint_tests(pigs.lm, by = "source")      ## separate joint tests of 'percent'

### Comparisons with type III tests in SAS
toy = data.frame(
    treat = rep(c("A", "B"), c(4, 6)),
    female = c(1, 0, 0, 1,   0, 0, 0, 1, 1, 0 ),
    resp = c(17, 12, 14, 19, 28, 26, 26, 34, 33, 27))
toy.fac = lm(resp ~ treat * factor(female), data = toy)
toy.cov = lm(resp ~ treat * female, data = toy)
# (These two models have identical fitted values and residuals)

# -- SAS output we'd get with toy.fac --
## Source          DF    Type III SS    Mean Square   F Value   Pr &gt; F
## treat            1    488.8928571    488.8928571    404.60   &lt;.0001
## female           1     78.8928571     78.8928571     65.29   0.0002
## treat*female     1      1.7500000      1.7500000      1.45   0.2741
# 
# -- SAS output we'd get with toy.cov --
## Source          DF    Type III SS    Mean Square   F Value   Pr &gt; F
## treat            1    252.0833333    252.0833333    208.62   &lt;.0001
## female           1     78.8928571     78.8928571     65.29   0.0002
## female*treat     1      1.7500000      1.7500000      1.45   0.2741

joint_tests(toy.fac)
joint_tests(toy.cov)   # female is regarded as a 2-level factor by default

## Treat 'female' as a numeric covariate (via cov.keep = 0)
## ... then tests depend on where we center things

# Center around the mean
joint_tests(toy.cov, cov.keep = 0, cov.reduce = make.meanint(delta = 1))
# Center around zero (like SAS's results for toy.cov)
joint_tests(toy.cov, cov.keep = 0, cov.reduce = make.symmint(ctr = 0, delta = 1))
# Center around 0.5 (like SAS's results for toy.fac)
joint_tests(toy.cov, cov.keep = 0, cov.reduce = range)

### Example with empty cells and confounded effects
low3 &lt;- unlist(attr(ubds, "cells")[1:3]) 
ubds.lm &lt;- lm(y ~ A*B*C, data = ubds, subset = -low3)

# Show overall joint tests by C:
ref_grid(ubds.lm, by = "C") |&gt; contrast("consec") |&gt; test(joint = TRUE)

# Break each of the above into smaller components:
joint_tests(ubds.lm, by = "C")

</code></pre>


</div>