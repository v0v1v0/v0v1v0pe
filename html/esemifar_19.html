<div class="container">

<table style="width: 100%;"><tr>
<td>tsmoothlm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Advanced Data-driven Nonparametric Regression for the Trend in Equidistant
Time Series</h2>

<h3>Description</h3>

<p>This function runs an iterative plug-in algorithm to find the optimal
bandwidth for the estimation of the nonparametric trend in equidistant
time series (with long-memory errors) and then employs the resulting
bandwidth via either local polynomial or kernel regression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tsmoothlm(
  y,
  pmin = c(0, 1, 2, 3, 4, 5),
  pmax = c(0, 1, 2, 3, 4, 5),
  qmin = c(0, 1, 2, 3, 4, 5),
  qmax = c(0, 1, 2, 3, 4, 5),
  p = c(1, 3),
  mu = c(0, 1, 2, 3),
  InfR = c("Opt", "Nai", "Var"),
  bStart = 0.15,
  bb = c(0, 1),
  cb = 0.05,
  method = c("lpr", "kr")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a numeric vector that contains the time series ordered from past to
present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>an integer <code>1</code> (local linear regression) or <code>3</code> (local
cubic regression); represents the order of polynomial within the local
polynomial regression (see also the 'Details' section); is set to <code>1</code> by
default; is automatically set to <code>1</code> if <code>method = "kr"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function and thus defines the kernel
function that will be used within the local polynomial regression; is set to
<code>1</code> by default.
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Number</strong> </td>
<td style="text-align: left;"> <strong>Kernel</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>0</code> </td>
<td style="text-align: left;"> Uniform Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>1</code> </td>
<td style="text-align: left;"> Epanechnikov Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>2</code> </td>
<td style="text-align: left;"> Bisquare Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>3</code> </td>
<td style="text-align: left;"> Triweight Kernel
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>InfR</code></td>
<td>
<p>a character object that represents the inflation
rate in the form <code class="reqn">h_d = h^a</code> for the bandwidth in the estimation of
<code class="reqn">I[m^{(k)}]</code> (see also the 'Details' section); is set to
<code>"Opt"</code> by default.
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Inflation rate</strong> </td>
<td style="text-align: left;"> <strong>Description</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"Opt"</code> </td>
<td style="text-align: left;"> Optimal inflation rate <code class="reqn">a_{p,O}</code>
(<code class="reqn">(5-2d)/(7-2d)</code> for <code>p = 1</code>; <code class="reqn">(9-2d)/(11-2d)</code> for
<code>p = 3</code>)</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"Nai"</code> </td>
<td style="text-align: left;"> Naive inflation rate <code class="reqn">a_{p,N}</code>
(<code class="reqn">(5-2d)/(9-2d)</code> for <code>p = 1</code>; <code class="reqn">(9-2d)/(13-2d)</code> for
<code>p = 3</code>)</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"Var"</code> </td>
<td style="text-align: left;"> Stable inflation rate <code class="reqn">a_{p,S}</code> (<code class="reqn">1/2</code> for
<code>p = 1</code> and <code>p = 3</code>)
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bStart</code></td>
<td>
<p>a numeric object that indicates the starting value of the
bandwidth for the iterative process; should be <code class="reqn">&gt; 0</code>; is set to
<code>0.15</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bb</code></td>
<td>
<p>can be set to <code>0</code> or <code>1</code>; the parameter controlling the
bandwidth used at the boundary; is set to <code>1</code> by default.
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Number (<code>bb</code>)</strong> </td>
<td style="text-align: left;"> <strong>Estimation procedure at boundary
points</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>0</code> </td>
<td style="text-align: left;"> Fixed bandwidth on one side with possible large
bandwidth on the other side at the boundary</td>
</tr>
<tr>
<td style="text-align: center;">
<code>1</code> </td>
<td style="text-align: left;"> The <code class="reqn">k</code>-nearest neighbor method will be used
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cb</code></td>
<td>
<p>a numeric value that indicates the percentage of omitted
observations on each side of the observation period for the automated
bandwidth selection; is set to <code>0.05</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the final smoothing approach; <code>"lpr"</code> represents the local
polynomial regression, whereas <code>"kr"</code> implements a kernel regression;
is set to <code>"lpr"</code> by default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The trend is estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series, <code class="reqn">x_t</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function and <code class="reqn">\epsilon_t</code> are stationary errors with
<code class="reqn">E(\epsilon_t) = 0</code> and is assumed to follow a FARIMA(<code class="reqn">p, d, q</code>)
model (see also Beran and Feng, 2002a, Beran and Feng, 2002b and Beran
and Feng, 2002c).
</p>
<p>The iterative-plug-in (IPI) algorithm, which numerically minimizes the
Asymptotic Mean Squared Error (AMISE), is based on the proposal of Beran
and Feng (2002a).
</p>
<p>The function calculates suitable estimates for <code class="reqn">c_f</code>, the variance
factor, and <code class="reqn">I[m^{(k)}]</code> over different iterations. In each
iteration, a bandwidth is obtained in accordance with the AMISE that once
more serves as an input for the following iteration. The process repeats
until either convergence or the 40th iteration is reached. For further
details on the asymptotic theory or the algorithm, please see Letmathe et
al., 2023.
</p>
<p>To apply the function, the following arguments are needed: a data input
<code>y</code>, an order of polynomial <code>p</code>, a kernel weighting function
defined by the smoothness parameter <code>mu</code>, an inflation rate setting
<code>InfR</code> (see also Beran and Feng, 2002b), a starting value for the
relative bandwidth <code>bStart</code>, a
boundary method <code>bb</code>, a boundary cut-off percentage <code>cb</code> and a
final smoothing method <code>method</code>. In fact, aside from the input vector
<code>y</code>, every argument has a default setting that can be adjusted for the
individual case. Theoretically, the initial bandwidth does not affect the
selected optimal bandwidth. However, in practice local minima of the AMISE
might exist and influence the selected bandwidth. Therefore, the default
setting is <code>bStart = 0.15</code>. In the rare
case of a clearly unsuitable optimal bandwidth, a starting bandwidth that
differs from the default value is a first possible approach to obtain a
better result. Other argument adjustments can be tried as well. For more
specific information on the input arguments consult the section
<em>Arguments</em>.
</p>
<p>When applying the function, an optimal bandwidth is obtained based on a
strongly modified version of the IPI algorithm of Beran and Feng (2002a). In
a second step, the nonparametric trend of the series is calculated with
respect to the chosen bandwidth and the selected regression method (<code>lpf</code>
or <code>kr</code>). Please note that <code>method = "lpf"</code> is strongly recommended
by the authors. Moreover, it is notable that <code>p</code> is automatically set to
<code>1</code> for <code>method = "kr"</code>. The output object is then a list that
contains, among other components, the original time series, the estimated
trend values and the series without the trend.
</p>
<p>The default print method for this function delivers only key numbers such as
the iteration steps and the generated optimal bandwidth rounded to the fourth
decimal. The exact numbers and results such as the estimated nonparametric
trend series are saved within the output object and can be addressed via the
<code>$</code> sign.
</p>


<h3>Value</h3>

<p>The function returns a list with different components:
</p>

<dl>
<dt>FARIMA.BIC</dt>
<dd>
<p>the Bayesian Information Criterion of the optimal
FARIMA(<code class="reqn">p,d,q</code>) model.</p>
</dd>
<dt>cb</dt>
<dd>
<p>the percentage of omitted observations on each side of the
observation period.</p>
</dd>
<dt>b0</dt>
<dd>
<p>the optimal bandwidth chosen by the IPI-algorithm.</p>
</dd>
<dt>bb</dt>
<dd>
<p>the boundary bandwidth method used within the IPI; always equal to
1.</p>
</dd>
<dt>bStart</dt>
<dd>
<p>the starting value of the (relative) bandwidth; input
argument.</p>
</dd>
<dt>cf0</dt>
<dd>
<p>the estimated variance factor; in contrast to the definitions
given in the <em>Details</em> section, this object actually contains an
estimated value of <code class="reqn">2\pi c_f</code>, i.e. it corresponds to the estimated sum
of autocovariances.</p>
</dd>
<dt>d.BIC</dt>
<dd>
<p>the long-memory parameter of the optimal FARIMA(<code class="reqn">p,d,q</code>)
model.</p>
</dd>
<dt>FARMA.BIC</dt>
<dd>
<p>the model fit of the selected FARIMA(<code class="reqn">p,d,q</code> model.</p>
</dd>
<dt>I2</dt>
<dd>
<p>the estimated value of <code class="reqn">I[m^{(k)}]</code>.</p>
</dd>
<dt>InfR</dt>
<dd>
<p>the setting for the inflation rate according to the chosen
algorithm.</p>
</dd>
<dt>iterations</dt>
<dd>
<p>the bandwidths of the single iterations steps</p>
</dd>
<dt>mu</dt>
<dd>
<p>the smoothness parameter of the second order kernel; input
argument.</p>
</dd>
<dt>n</dt>
<dd>
<p>the number of observations.</p>
</dd>
<dt>niterations</dt>
<dd>
<p>the total number of iterations until convergence.</p>
</dd>
<dt>orig</dt>
<dd>
<p>the original input series; input argument.</p>
</dd>
<dt>p.BIC</dt>
<dd>
<p>the order p of the optimal FARIMA(<code class="reqn">p,d,q</code>) model.</p>
</dd>
<dt>p</dt>
<dd>
<p>the order of polynomial used in the IPI-algorithm; also used for the
final smoothing, if <code>method = "lpr"</code>; input argument.</p>
</dd>
<dt>q.BIC</dt>
<dd>
<p>the order <code class="reqn">q</code> of the optimal FARIMA(<code class="reqn">p,d,q</code>)
model.</p>
</dd>
<dt>res</dt>
<dd>
<p>the estimated residual series.</p>
</dd>
<dt>v</dt>
<dd>
<p>the considered order of derivative of the trend; is always zero for
this function.</p>
</dd>
<dt>ws</dt>
<dd>
<p>the weighting system matrix used within the local polynomial
regression; this matrix is a condensed version of a complete weighting system
matrix; in each row of <code>ws</code>, the weights for conducting the smoothing
procedure at a specific observation time point can be found; the first
<code class="reqn">[nb + 0.5]</code> rows, where <code class="reqn">n</code> corresponds to the number of
observations, <code class="reqn">b</code> is the bandwidth considered for smoothing and
<code class="reqn">[.]</code> denotes the integer part, contain the weights at the
<code class="reqn">[nb + 0.5]</code> left-hand boundary points; the weights in row
<code class="reqn">[nb + 0.5] + 1</code> are representative for the estimation at all
interior points and the remaining rows contain the weights for the right-hand
boundary points; each row has exactly <code class="reqn">2[nb + 0.5] + 1</code> elements,
more specifically the weights for observations of the nearest
<code class="reqn">2[nb + 0.5] + 1</code> time points; moreover, the weights are normalized,
i.e. the weights are obtained under consideration of the time points
<code class="reqn">x_t = t/n</code>, where <code class="reqn">t = 1, 2, ..., n</code>.</p>
</dd>
<dt>ye</dt>
<dd>
<p>the nonparametric estimates of the trend.</p>
</dd>
</dl>
<h3>Author(s)</h3>


<ul>
<li>
<p> Yuanhua Feng (Department of Economics, Paderborn University), <br>
Author of the Algorithms <br>
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li>
<p> Sebastian Letmathe (Scientific Employee) (Department of Economics,
Paderborn University), <br>
Package Creator and Maintainer
</p>
</li>
<li>
<p> Dominik Schulz (Scientific Employee) (Department of Economics,
Paderborn University), <br>
Author
</p>
</li>
</ul>
<h3>References</h3>

<p>Beran, J. and Y. Feng (2002a). Iterative plug-in algorithms for SEMIFAR
models - definition, convergence, and asymptotic properties. Journal of
Computational and Graphical Statistics 11(3), 690-713.
</p>
<p>Beran, J. and Feng, Y. (2002b). Local polynomial fitting with long-memory,
short-memory and antipersistent errors. Annals of the Institute of
Statistical Mathematics, 54(2), 291-311.
</p>
<p>Beran, J. and Feng, Y. (2002c). SEMIFAR models - a semiparametric approach
to modelling trends, longrange dependence and nonstationarity. Computational
Statistics &amp; Data Analysis 40(2), 393-419.
</p>
<p>Letmathe, S., Beran, J. and Feng, Y. (2023). An extended exponential SEMIFAR
model with application in R. Communications in Statistics - Theory and Methods:
1-13.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

### Example 1: G7-GDP ###

# Logarithm of test data
# -&gt; the logarithm of the data is assumed to follow the additive model
test_data &lt;- gdpG7
y &lt;- log(test_data$gdp)
n &lt;- length(y)

# Applied tsmooth function for the trend
result &lt;- tsmoothlm(y, p = 1, pmax = 1, qmax = 1, InfR = "Opt")
trend1 &lt;- result$ye

# Plot of the results
t &lt;- seq(from = 1962, to = 2020, length.out = n)
plot(t, y, type = "l", xlab = "Year", ylab = "log(G7-GDP)", bty = "n",
 lwd = 1, lty = 3,
 main = "Estimated trend for log-quarterly G7-GDP, Q1 1962 - Q4 2019")
points(t, trend1, type = "l", col = "red", lwd = 1)
title(sub = expression(italic("Figure 1")), col.sub = "gray47",
 cex.sub = 0.6, adj = 0)
result



</code></pre>


</div>