<div class="container">

<table style="width: 100%;"><tr>
<td>distance</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Calculate dissimilarity/distance metrics </h2>

<h3>Description</h3>

<p>This function calculates a variety of dissimilarity or distance metrics. Although it duplicates the functionality of dist() and bcdist(), it is written in such a way that new metrics can easily be added.
distance() was written for extensibility and understandability, and is not necessarily an efficient choice for use with large matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">distance(x, method = "euclidean", sprange=NULL, spweight=NULL, icov, inverted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> matrix or data frame with rows as samples and columns as variables (such as
species). Distances will be calculated for each pair of rows. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> Currently 7 dissimilarity metrics can be calculated: "euclidean", "bray-curtis", "manhattan", "mahalanobis" (squared Mahalanobis distance), "jaccard", "difference", "sorensen", "gower", "modgower10" (modified Gower, base 10), "modgower2" (modified Gower, base 2). Partial matching will work for selecting a method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sprange</code></td>
<td>
<p>Gower dissimilarities offer the option of dividing by the species range. If sprange=NULL no range is used. If sprange is a vector of length nrow(x) it is used for standardizing the dissimilarities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spweight</code></td>
<td>
<p>Euclidean, Manhattan, and Gower dissimilarities allow weighting. If spweight=NULL, no weighting is used. If spweight="absence", then W=0 if both species are absent and 1 otherwise, thus deleting joint absences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>icov</code></td>
<td>
<p>Optional covariance matrix; only used if method="mahalanobis" since Mahalanobis distance requires calculating the variance-covariance matrix for the entire dataset. Providing icov directly makes it possible to calculate distances for a subset of the full dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inverted</code></td>
<td>
<p>If TRUE, the optional covariance matrix for method="mahalanobis" is not inverted before solving. Providing an inverted matrix may speed up calculations.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a lower-triangular distance matrix as an object of class "dist".
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code>dist</code>,  <code>bcdist</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">data(iris)
iris.bc &lt;- distance(iris[, 1:4], "bray-curtis")

# The effect of specifying icov:

# calculate Mahalanobis distance for the full iris dataset
iris.md &lt;- full(distance(iris[, 1:4], "mahal"))
iris.md[1, 2] # Mahalanobis distance between samples 1 and 2 

# calculate Mahalanobis for just one species
setosa.md &lt;- full(distance(iris[iris$Species == "setosa", 1:4], "mahal"))
setosa.md[1, 2] # Mahalanobis distance between samples 1 and 2 

# use the covariance matrix for the full dataset to scale for one species
setosa.scaled.md &lt;- full(distance(iris[iris$Species == "setosa", 1:4],
  "mahal", icov=var(iris[,1:4])))
setosa.scaled.md[1, 2] # Mahalanobis distance between samples 1 and 2 

</code></pre>


</div>