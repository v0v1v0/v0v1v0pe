<div class="container">

<table style="width: 100%;"><tr>
<td>interpPairs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
interpolate between pairs of vectors in a list
</h2>

<h3>Description</h3>

<p>This does two things:  
</p>

<ol>
<li>
<p> Computes a <code>.proportion</code> 
interpolation between <code>pairs</code> by passing
each pair with <code>.proportion</code> to 
<code>interpChar</code>.  
<code>interpChar</code> does standard linear 
interpolation with numerics and interpolates 
based on the number of characters with 
non-numerics.  
</p>
</li>
<li>
<p> Discards rows of interpolants for which 
<code>.proportion</code> is outside 
<code>validProportion</code>.  If <code>object</code> is 
a <code>list</code>, corresponding rows of other
vectors of the same length are also discarded.  
</p>
<p>NOTE:  There are currently discrepancies 
between the documentation and the code over
defaults when one but not both elements of a
pair are provided.  The code returns an answer.
If that's not acceptable, provide the other 
half of the pair.  After some experience is
gathered, the question of defaults will be
revisited and the code or the documentation 
will change.  
</p>
</li>
</ol>
<h3>Usage</h3>

<pre><code class="language-R">interpPairs(object, ...) 
## S3 method for class 'call'
interpPairs(object, 
    nFrames=1, iFrame=nFrames, 
    endFrames=round(0.2*nFrames), 
    envir = parent.frame(), 
    pairs=c('1'='\\.0$', '2'='\\.1$', 
        replace0='', replace1='.2', 
        replace2='.3'),     
    validProportion=0:1, message0=character(0), ...)
## S3 method for class 'function'
interpPairs(object, 
    nFrames=1, iFrame=nFrames, 
    endFrames=round(0.2*nFrames), 
    envir = parent.frame(), 
    pairs=c('1'='\\.0$', '2'='\\.1$', 
    replace0='', replace1='.2', replace2='.3'),     
    validProportion=0:1, message0=character(0), ...)
## S3 method for class 'list'
interpPairs(object, 
    .proportion, envir=list(), 
        pairs=c('1'='\\.0$', '2'='\\.1$',
        replace0='', replace1='.2', 
        replace2='.3'), validProportion=0:1,
        message0=character(0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>A <code>call</code>, <code>function</code>, 
<code>list</code> or <code>data.frame</code> with names
possibly matching <code>pairs[1:2]</code>.  
</p>
<p>When names matching both of <code>pairs[1:2]</code>,
they are converted to potentially common names
using <code>sub(pairs[i], pairs[3], ...)</code>.  
When matches are found among the potentially
common names, they are passed with 
<code>.proportion</code> to <code>interpChar</code>
to compute an interpolation.  The matches are
removed and replaced with the interpolant,
shortened by excluding any rows for which 
<code>.proportion</code> is outside 
<code>validProportion</code>.  
</p>
<p>Elements with "common names" that do not have 
a match are replaced by elements with the 
common names that have been shortened by
omitting rows with <code>.proportion</code> outside
<code>validProportion</code>.  Thus, if <code>x.0</code> 
is found without <code>x.1</code>, <code>x.0</code> is
removed and replaced by <code>x</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nFrames</code></td>
<td>

<p>number of distinct plots to create.


</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iFrame</code></td>
<td>

<p>integer giving the index of the single frame 
to create.  Default = <code>nFrames</code>.
</p>
<p>An error is thrown if both <code>iFrame</code> and
<code>.proportion</code> are not <code>NULL</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endFrames</code></td>
<td>

<p>Number of frames to hold constant at the end.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.proportion</code></td>
<td>

<p>a numeric vector assumed to lie between 0 and 
1 specifying how far to go from 
<code>suffixes[1]</code> to <code>suffixes[2]</code>.  
For example, if <code>x.0</code> and <code>x.1</code> are
found and are numeric, <code>x</code> = 
<code>x.0 + .proportion * (x.1 - x.0)</code>.  
Rows of <code>x</code> and any other element 
of <code>object</code> of the same length are dropped
for any <code>.proportion</code> outside 
<code>validProportion</code>.
</p>
<p>An error is thrown if both <code>iFrame</code> and
<code>.proportion</code> are not <code>NULL</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>

<p>environment / list to use with codeobject,
which can optionally provide other variables to
compute what gets plotted;  see the example
below using this argument.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairs</code></td>
<td>

<p>a character vector of two regular expressions 
to identify elements of <code>object</code> between
which to interpolate and three replacements.  
</p>
<p>(1) The first of the three replacements is used
in <code>sub</code> to convert each 
<code>pairs[1:2]</code> name found to the desired 
name of the interpolate.  Common names found 
are then passed with <code>.proportion</code> to 
<code>interpChar</code>, which does the actual 
interpolation. 
</p>
<p>(2, 3) <code>interpPairs</code> also calls 
<code>checkNames(object, avoid = 
    pairs[c(1, 3, 2, 5)])</code>.  
This confirms that <code>object</code> has 
<code>names</code>, and all such names are
unique.  If <code>object</code> does not have names 
or has some duplicate names, the 
<code>make.names</code> is called to fix 
that problem, and any new names that match
<code>pairs[1:2]</code> are modified using 
<code>sub</code> to avoid creating a new match.  
If the modification still matches 
<code>pairs[1:2]</code>, it generates an error.      
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validProportion</code></td>
<td>

<p>Range of values of <code>.proportion</code> to 
retain, as noted with the discussion of the
<code>object</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message0</code></td>
<td>

<p>a character string passed to 
<code>interpChar</code> to improve the value 
of diagnostic messages  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> optional arguments for 
<code>sub</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>*** FUNCTION *** 
</p>
<p>First <code>interpPairs.function</code> looks for
arguments <code>firstFrame</code>, <code>lastFrame</code>, 
and <code>Keep</code>.  If any of these are found, 
they are stored locally and removed from the
function.  If <code>iFrame</code> is provided, it is 
used with with these arguments plus 
<code>nFrames</code> and <code>endFrames</code> to compute
<code>.proportion</code>.  
</p>
<p>If <code>.proportion</code> is outside 
<code>validProportion</code>, <code>interpPairs</code> does
nothing, returning <code>enquote(NULL)</code>.  
</p>
<p>If <code>any(.proportion)</code> is inside 
<code>validProportion</code>, 
<code>interpPairs.function</code> next uses 
<code>grep</code> to look for arguments with
names matching <code>pairs[1:2]</code>.  If any are
found, they are passed with <code>.proportion</code> 
to <code>interpChar</code>.  The result is 
stored in the modified <code>object</code> with the
common name obtained from 
<code>sub(pairs[i], pairs[3], ...)</code>, <code>i</code> = 
1, 2.  
</p>
<p>The result is then evaluated and then returned.  
</p>
<p>*** LIST *** 
</p>
<p>1.  <code>ALL.OUT:  
  if(none(0&lt;=.proportion&lt;=1))</code>return 
<code>'no.op' = list(fun='return', value=NULL)</code> 
</p>
<p>2.  <code>FIND PAIRS</code>:  Find names matching
<code>pairs[1:2]</code> using <code>grep</code>.  
For example, names like <code>x.0</code> match the
default <code>pairs[1]</code>, and names like 
<code>x.1</code> match the default <code>pairs[1]</code>.  
</p>
<p>3.  <code>MATCH PAIRS</code>:  Use 
<code>sub(pairs[i], pairs[3], ...)</code> for 
i = 1:2, to translate each name matching 
<code>pairs[1:2]</code> into something else for 
matching.  For example, the default <code>pairs</code> 
thus translates, e.g., <code>x.0</code> and 
<code>x.1</code> both into <code>x</code>.  In the output, 
<code>x.0</code> and <code>x.1</code> are dropped, replaced 
by <code>x</code> = <code>interpChar(x.0, x.1, 
  .proportion, ...)</code>.  Rows with 
<code>.proportion</code> outside <code>validProportion</code> 
are dropped in <code>x</code>.  Drop similar rows of 
any numeric or character vector or 
<code>data.frame</code> with the same number of 
rows as <code>x</code> or <code>.proportion</code>.  
</p>
<p>4.  Add component <code>.proportion</code> to 
<code>envir</code> to make it available to 
<code>eval</code> any <code>language</code> component
of <code>object</code> in the next step.  
</p>
<p>5.  Loop over all elements of <code>object</code> to 
create <code>outList</code>, evaluating any 
expressions and computing the desired 
interpolation using <code>interpChar</code>. 
Computing <code>xleft</code> in this way allows
<code>xright</code> to be specified later as 
<code>quote(xleft + xinch(0.6))</code>, for example. 
This can be used with a call to 
<code>rasterImageAdj</code>.  
</p>
<p>6.  Let <code>N</code> = the maximum number of rows of
elements of <code>outList</code> created by 
interpolation in the previous step.  If 
<code>.proportion</code> is longer, set <code>N</code> = 
<code>length(.proportion)</code>.  Find all vectors and 
<code>data.frame</code>s in <code>outList</code> with
<code>N</code> rows and delete any rows for which 
<code>.proportion</code> is outside 
<code>validProportion</code>.  
</p>
<p>7.  Delete the raw pairs found in steps 1-3,
retaining the element with the target name
computed in steps 4 and 5 above.  For other
elements of <code>object</code> modified in the 
previous step, retain the shortened form. 
Otherwise, retain the original, unevaluated
element.    
</p>


<h3>Value</h3>

<p>a <code>list</code> with elements containing the 
interpolation results.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>See Also</h3>

<p><code>interpChar</code> for details on 
interpolation.  
<code>compareLengths</code> for how lengths 
are checked and messages composed and written.  

<code>enquote</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">###
###
### 1.  interpPairs.function
###
###

##
## 1.1.  simple 
##
plot0 &lt;- quote(plot(0))
plot0. &lt;- interpPairs(plot0)
# check 

all.equal(plot0, plot0.)


##
## 1.2.  no op 
##
noop &lt;- interpPairs(plot0, iFrame=-1)
# check

all.equal(noop, enquote(NULL))


##
## 1.3.  a more typical example
## example function for interpPairs 
tstPlot &lt;- function(){
  plot(1:2, 1:2, type='n')
  lines(firstFrame=1:3, 
        lastFrame=4, 
        x.1=seq(1, 2, .5), 
        y.1=x, 
        z.0=0, z.1=1, 
        txt.1=c('CRAN is', 'good', '...'), 
        col='red')
}
tstbo &lt;- body(tstPlot)
iPlot &lt;- interpPairs(tstbo[[2]])
# check 
iP &lt;- quote(plot(1:2, 1:2, type='n'))

all.equal(iPlot, iP)


iLines &lt;- interpPairs(tstbo[[3]], nFrames=5, iFrame=2)
# check:  
# .proportion = (iFrame-firstFrame)/(lastFrame-firstFrame)
#  = c(1/3, 0, -1/3)




# if x.0 = 0 and y.0 = 0 by default:  
iL &lt;- quote(linex(x=c(1/3, 0), y=c(1/9, 0), z=c(1/3, 0), 
           tst=c('CR', '')))
##
##**** This example seems to give the wrong answer
##**** 2014-06-03:  Ignore for the moment 
##           

#all.equal(iLines, iL)


##
## 1.4.  Don't throw a cryptic error with NULL 
##
ip0 &lt;- interpPairs(quote(text(labels.1=NULL)))
  
  
###
###
### 2.  interpPairs.list
###
###

##
## 2.1.  (x.0, y.0, x.1, y.1) -&gt; (x,y)
##
tstList &lt;- list(x.0=1:5, y.0=5:9, y.1=9:5, x.1=9,
                ignore=letters, col=1:5)
xy &lt;- interpPairs(tstList, 0.1)
# check 
xy. &lt;- list(ignore=letters, col=1:5, 
            x=1:5 + 0.1*(9-1:5), 
            y=5:9 + 0.1*(9:5-5:9) )
# New columns, 'x' and 'y', come after 
# columns 'col' and 'ignore' already in tstList 

all.equal(xy, xy.)


##
## 2.2.  Select the middle 2:  
##      x=(1-(0,1))*3:4+0:1*0=(3,0)
##
xy0 &lt;- interpPairs(tstList[-4], c(-Inf, -1, 0, 1, 2) )
# check 
xy0. &lt;- list(ignore=letters, col=3:4, x=c(3,0), y=7:6)


all.equal(xy0, xy0.)

##
## 2.3.  Null interpolation because of absence of y.1 and x.0  
##
xy02 &lt;- interpPairs(tstList[c(2, 4)], 0.1)
# check 
#### NOT the current default answer;  revisit later.  
xy02. &lt;- list(y=5:9, x=9)

# NOTE:  length(x) = 1 = length(x.1) in testList

#all.equal(xy02, xy02.)


##
## 2.4.  Select an empty list (make sure this works)
##
x0 &lt;- interpPairs(list(), 0:1)
# check 
x0. &lt;- list()
names(x0.) &lt;- character(0)

all.equal(x0, x0.)


##
## 2.5.  subset one vector only 
##
xyz &lt;- interpPairs(list(x=1:4), c(-1, 0, 1, 2))
# check 
xyz. &lt;- list(x=2:3)

all.equal(xyz, xyz.)


##
## 2.6.  with elements of class call
##
xc &lt;- interpPairs(list(x=1:3, y=quote(x+sin(pi*x/6))), 0:1)
# check
xc. &lt;- list(x=1:3, y=quote(x+sin(pi*x/6)))

all.equal(xc, xc.)


##
## 2.7. text
##
#  2 arguments 
j.5 &lt;- interpPairs(list(x.0='', x.1=c('a', 'bc', 'def')), 0.5)
# check  
j.5. &lt;- list(x=c('a', 'bc', ''))

all.equal(j.5, j.5.)


##
##  2.8.  text, 1 argument as a list 
##
j.50 &lt;- interpPairs(list(x.1=c('a', 'bc', 'def')), 0.5)
# check  

all.equal(j.50, j.5.)


##
## 2.9.  A more complicated example with elements to eval
##
logo.jpg &lt;- paste(R.home(), "doc", "html", "logo.jpg",
                  sep = .Platform$file.sep)
if(require(jpeg)){
  Rlogo &lt;- try(readJPEG(logo.jpg))
  if(!inherits(Rlogo, 'try-error')){
# argument list for a call to rasterImage or rasterImageAdj   
    RlogoLoc &lt;- list(image=Rlogo,
      xleft.0 = c(NZ=176.5,CH=172,US=171,  
                  CN=177,RU= 9.5,UK= 8),
      xleft.1 = c(NZ=176.5,CH=  9,US=-73.5,
                  CN=125,RU= 37, UK= 2),
      ybottom.0=c(NZ=-37,  CH=-34,US=-34,  
                  CN=-33,RU= 48, UK=47),
      ybottom.1=c(NZ=-37,  CH= 47,US= 46,  
                  CN= 32,RU=55.6,UK=55),
      xright=quote(xleft+xinch(0.6)),
      ytop = quote(ybottom+yinch(0.6)),
      angle.0 =0,
      angle.1 =c(NZ=0,CH=3*360,US=5*360, 
                 CN=2*360,RU=360,UK=360)
    )

    RlogoInterp &lt;- interpPairs(RlogoLoc, 
            .proportion=rep(c(0, -1), c(2, 4)) )
# check 

  all.equal(names(RlogoInterp), 
      c('image', 'xright', 'ytop', 
        'xleft', 'ybottom', 'angle'))
 

# NOTE:  'xleft', and 'ybottom' were created in interpPairs, 
# and therefore come after 'xright' and 'ytop', which were 
# already there.  

##
## 2.10.  using envir
##
    RlogoDiag &lt;- list(x0=quote(Rlogo.$xleft), 
                  y0=quote(Rlogo.$ybottom), 
                  x1=quote(Rlogo.$xright), 
                  y1=quote(Rlogo.$ytop) ) 

    RlogoD &lt;- interpPairs(RlogoDiag, .p=1, 
                    envir=list(Rlogo.=RlogoInterp) ) 



    all.equal(RlogoD, RlogoDiag)

  }
}
##
## 2.11.  assign;  no interp but should work   
##
tstAsgn &lt;- as.list(quote(op &lt;- (1:3)^2))
intAsgn &lt;- interpPairs(tstAsgn, 1)

# check 
intA. &lt;- tstAsgn 
names(intA.) &lt;- c('X', 'X.3', 'X.2')

all.equal(intAsgn, intA.)


#   op &lt;- par(...)
tstP &lt;- quote(op &lt;- par(mar=c(5, 4, 2, 2)+0.1))
tstPar &lt;- as.list(tstP)
intPar &lt;- interpPairs(tstPar, 1)

# check 
intP. &lt;- list(quote(`&lt;-`), quote(op), 
              quote(par(mar=c(5, 4, 2, 2)+0.1)) )
names(intP.) &lt;- c("X", 'X.3', 'X.2')

all.equal(intPar, intP.)


intP. &lt;- interpPairs(tstP)

all.equal(intP., tstP)


##
## NULL 
## 

all.equal(interpPairs(NULL), quote(NULL)) 

</code></pre>


</div>