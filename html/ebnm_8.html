<div class="container">

<table style="width: 100%;"><tr>
<td>ebnm_generalized_binary</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solve the EBNM problem using generalized binary priors</h2>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
nonnegative distributions consisting of mixtures where one component is a
point mass at zero and the other is a truncated normal distribution with
lower bound zero and nonzero mode. Typically, the mode is positive, with
the ratio of the mode to the standard deviation taken to be large, so that
posterior estimates are strongly shrunk towards one of two values (zero or
the mode of the normal component).
Identical to function <code>ebnm</code> with argument
<code>prior_family = "generalized_binary"</code>.
For details, see Liu et al. (2023), cited in <strong>References</strong> below.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ebnm_generalized_binary(
  x,
  s = 1,
  mode = "estimate",
  scale = 0.1,
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>A scalar specifying the mode of the truncated normal component,
or <code>"estimate"</code> if the mode is to be estimated from the data (the
location of the point mass is fixed at zero).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A scalar specifying the ratio of the (untruncated) standard
deviation of the normal component to its mode. This ratio must be
fixed in advance (i.e., it is not possible to set <code>scale = "estimate"</code>
when using generalized binary priors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the "true" <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. When
supplied, <code>g_init</code> should be an object of class
<code>tnormalmix</code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>tnormalmix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control parameters to be passed to function
<code>optim</code>, where <code>method</code> has been set to
<code>"L-BFGS-B"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>The following additional arguments act as control parameters for
the outer EM loops in the fitting algorithm. Each loop iteratively updates
parameters <code class="reqn">w</code> (the
mixture proportion corresponding to the truncated normal component) and
<code class="reqn">\mu</code> (the mode of the truncated normal component):
</p>

<dl>
<dt><code>wlist</code></dt>
<dd>
<p>A vector defining intervals of <code class="reqn">w</code> for which
optimal solutions will separately be found. For example, if
<code>wlist = c(0, 0.5, 1)</code>, then two optimal priors will be found:
one such that <code class="reqn">w</code> is constrained to be less than 0.5 and one
such that it is constrained to be greater than 0.5.</p>
</dd>
<dt><code>maxiter</code></dt>
<dd>
<p>A scalar specifying the maximum number of
iterations to perform in each outer EM loop.</p>
</dd>
<dt><code>tol</code></dt>
<dd>
<p>A scalar specifying the convergence tolerance
parameter for each outer EM loop.</p>
</dd>
<dt><code>mu_init</code></dt>
<dd>
<p>A scalar specifying the initial value of <code class="reqn">\mu</code>
to be used in each outer EM loop.</p>
</dd>
<dt><code>mu_range</code></dt>
<dd>
<p>A vector of length two specifying lower and
upper bounds for possible values of <code class="reqn">\mu</code>.</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt>
<dd>
<p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt>
<dd>
<p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt>
<dd>
<p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt>
<dd>
<p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt>
<dd>
<p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>
<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>References</h3>

<p>Yusha Liu, Peter Carbonetto, Jason Willwerscheid, Scott A Oakes, Kay F Macleod,
and Matthew Stephens (2023). Dissecting tumor transcriptional heterogeneity
from single-cell RNA-seq data by generalized binary covariance decomposition.
bioRxiv 2023.08.15.553436.
</p>


<h3>See Also</h3>

<p>See <code>ebnm</code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code>coef.ebnm</code>,
<code>confint.ebnm</code>,
<code>fitted.ebnm</code>, <code>logLik.ebnm</code>,
<code>nobs.ebnm</code>, <code>plot.ebnm</code>,
<code>predict.ebnm</code>, <code>print.ebnm</code>,
<code>print.summary.ebnm</code>, <code>quantile.ebnm</code>,
<code>residuals.ebnm</code>, <code>simulate.ebnm</code>,
<code>summary.ebnm</code>, and <code>vcov.ebnm</code>.
</p>


</div>