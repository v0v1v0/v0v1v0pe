<div class="container">

<table style="width: 100%;"><tr>
<td>BoxCox</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Box-Cox power transformation and its inverse 
</h2>

<h3>Description</h3>

<p>Box and Cox (1964) considered the following 
family of transformations indexed by 
<code>lambda</code>:  
</p>
<p><code>w</code> = <code>(y^lambda-1)/lambda</code>
</p>
<p>= <code>expm1(lambda*log(y))/lambda</code>, 
</p>
<p>with the <code>lambda=0</code> case defined as 
<code>log(y)</code> to make <code>w</code> continuous in 
<code>lambda</code> for constant <code>y</code>.  
</p>
<p>They estimate <code>lambda</code> assuming <code>w</code>
follows a normal distribution.  This raises a
theoretical problem in that <code>y</code> must be
positive, which means that <code>w</code> must follow 
a truncated normal distribution conditioned on 
<code>lambda*w</code> &gt; <code>(-1)</code>.  
</p>
<p>Bickel and Doksum (1981) removed the 
restriction to positive <code>y</code>, i.e., to 
<code>w</code> &gt; <code>(-1/lambda)</code> by modifying 
the transformation as follows:  
</p>
<p><code>w</code> = 
</p>
<p><code>(sgn(y)*abs(y)^lambda-1)/lambda</code> 
if <code>lambda != 0</code> and 
</p>
<p><code>sgn(y)*log(abs(y))</code> if <code>lambda = 0</code>, 
</p>
<p>where <code>sgn(y)</code> = 1 if y &gt;= 0 and -1 
otherwise.  
</p>
<p>NOTE:  <code>sgn(y)</code> is different from 
<code>sign</code>(y), which is 0 for 
y = 0.  A two-argument update to the sign 
function in the base package has been added to 
this Ecfun package, so <code>sign</code>(y, 1) 
= <code>sgn(y)</code>.  
</p>
<p>If (y&lt;0), this transformation is discontinuous 
at <code>lambda = 0</code>.  To see this, we rewrite 
this as 
</p>
<p><code>w</code> = 
<code>(sgn(y)*expm1(lambda*log(abs(y))) + 
  (sgn(y)-1)) / lambda</code> 
</p>
<p>= <code>sgn(y)*(log(abs(y)) + O(lambda) + 
  (sgn(y)-1)/lambda</code>, 
</p>
<p>where 
<a href="https://en.wikipedia.org/wiki/Big_O_notation">O(lambda)</a>
indicates a term that is dominated by a 
constant times <code>lambda</code>.  
</p>
<p>If y&lt;0, this latter term 
<code>(sgn(y)-1)/lambda = (-2)/lambda</code> and 
becomes <code>Inf</code> as <code>lambda</code> -&gt; 0.  
</p>
<p>In practice, we assume that <code>y</code> &gt; 0, 
so this distinction has little practical 
value.  However, the <code>BoxCox</code> function 
computes the Bickel-Doksum version.  
</p>
<p>Box and Cox further noted that proper 
estimation of <code>lambda</code> should include 
the Jacobian of the transformation in the 
log(likelihood).  Doing this can be achieved 
by rescaling the transformation with the 
<code>n</code><code>th</code> root of the Jacobian, which 
can be written as follows:   
</p>
<p><code>j(y, lambda)</code> = 
<code>J(y, lambda)^(1/n)</code> = 
<code>GeometricMean(y)^(lambda-1)</code>.  
</p>
<p>With this the rescaled power transformation 
is as follows:    
</p>
<p><code>z</code> = <code>(y^lambda-1) / 
                    (lambda*j(y, lambda)</code> 
if <code>lambda!=0</code>
or <code>GeometricMean(y)*log(y)</code> if 
<code>lambda==0</code>.  
</p>
<p>In addition to facilitating estimation of 
<code>lambda</code>, rescaling has the advantage 
that the units of <code>z</code> are the same as 
the units of <code>y</code>.    
</p>
<p>The output has class <code>BoxCox</code>, which has 
attributes that allow the input to be recovered
using <code>invBoxCox</code>. The default values of 
the arguments of <code>invBoxCox</code> are provided 
by the corresponding <code>attributes</code> 
of <code>z</code>.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">  BoxCox(y, lambda, rescale=TRUE, na.rm=rescale) 
  invBoxCox(z, lambda, sign.y, GeometricMean, rescale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>a numeric vector for which the power transform 
is desired  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>A numeric vector of length 1 or 2.  The first
component is the power.  If the second 
component is provided, <code>y</code> is replaced 
by <code>y+lambda[2]</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>

<p>logical or numeric.  If logical:  
</p>
<p>For <code>BoxCox</code>, this is <code>TRUE</code> to 
return the power transform with rescale, 
<code>z</code>, above, and <code>FALSE</code>
to return the power transform without the
<code>n</code>th root of the Jacobian, 
<code>w</code>, above.  This defaults to 
<code>TRUE</code>, because this will give <code>z</code> 
the same units as <code>y</code>.  
</p>
<p>For <code>invBoxCox</code>, this is <code>TRUE</code> 
if the input argument <code>z</code> is assumed to 
have been rescaled by the <code>n</code>th 
root of the Jacobian of the transformation. 
This defaults to a <code>rescale</code> attribute 
of <code>z</code> if present or to <code>TRUE</code> if 
absent.  
</p>
<p>If numeric, it is assumed to be the 
geometric mean of another set of y values to 
use with new <code>y</code>'s.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>

<p>logical:  
<code>TRUE</code> to remove <code>NA</code>s from 
<code>y</code> before computing the geometric 
mean.  
</p>
<p><code>FALSE</code> to compute <code>NA</code>
for the geometric mean if 
<code>any(is.na(y))</code>.  
</p>
<p>NOTE:  If <code>na.rm</code> = <code>FALSE</code>, the 
output will be all <code>NA</code> if 
<code>rescale</code> = <code>TRUE</code>.  This could 
produce non usable answers in most cases.  
To avoid that, the default for <code>na.rm</code> 
is <code>TRUE</code> whenever <code>rescale</code> = 
<code>TRUE</code>.  Conversely, applications using
<code>na.rm</code> = <code>FALSE</code> will likely also 
want <code>rescale</code> = <code>FALSE</code> to avoid
returning a non-answer in these cases.  This
explains the default <code>na.rm</code> = 
<code>rescale</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>

<p>a numeric vector or an object of class 
<code>BoxCox</code> for which the inverse Box-Cox
transform is desired.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign.y</code></td>
<td>

<p>an optional logical vector giving 
<code>sign(y-lambda[2])</code> of the data values 
that presumably generated <code>z</code>.  Defaults 
to an <code>sign.y</code> attribute of <code>z</code> or 
to <code>rep(1, length(z))</code> if no such 
attribute is present.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GeometricMean</code></td>
<td>

<p>an optional numeric scalar giving the 
geometric mean of the  data values that 
presumably generated <code>z</code>.  Defaults to 
a <code>GeometricMean</code> attribute of 
<code>z</code> or to 1 if no such attribute is 
present.  
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Box and Cox (1964) discussed 
</p>
<p><code>w(y, lambda) = (y^lambda - 1)/lambda</code>. 
</p>
<p>They noted that <code>w</code> is continuous in 
<code>lambda</code> with w(y, lambda) = <code>log(y)</code> 
if <code>lambda</code> = 0 (by l'Hopital's rule).  
</p>
<p>They also discussed  
</p>
<p><code>z(y, lambda) = (y^lambda - 1) / 
  (lambda*g^(lambda-1))</code>, 
</p>
<p>where <code>g</code> = the geometric mean of <code>y</code>.
</p>
<p>They noted that proper estimation of 
<code>lambda</code> should include the Jacobian of 
w(y, lambda) with the likelihood.  They further
showed that a naive normal likelihood using 
<code>z(y, lambda)</code> as the response without a
Jacobian is equivalent to the normal likelihood
using <code>w(y, lambda)</code> adjusted appropriately
using the Jacobian.  See Box and Cox (1964) or 
<a href="https://en.wikipedia.org/wiki/Power_transform">the Wikipedia article on "Power transform"</a>.  
</p>
<p>Bickel and Doksum (1981) suggested adding 
<code>sign(y)</code> to the transformation, as 
discussed above. 
</p>
<p>NUMERICAL ANALYSIS:  
</p>
<p>Consider the Bickel and Doksum version 
described above:  
</p>
<p><code>w</code> &lt;- 
<code>(sign(y)*abs(y)^lambda-1)/lambda</code>
</p>
<p><code>if(any(y==0)), GeometricMean(y)</code> = 0.  
This creates a problem with the above math.    
</p>
<p>Let <code>ly = log(abs(y))</code>.  Then with 
<code>la = lambda</code>, 
</p>
<p><code>w</code> = <code>(sign(y)*exp(la*ly)-1)/la</code>
</p>
<p>= <code>sign(y) * ly * (1+(la*ly/2) * 
  (1+(la*ly/3)*(1+(la*ly/4)*(1+O(la*ly)))))
  + (sign(y)-1)/la</code>
</p>
<p>For y&gt;0, the last term is zero.  
<code>boxcox</code> ignores cases 
with y&lt;=0 and uses this formula (ignoring 
the final <code>O(la*ly)</code>) whenever 
<code>abs(la) &lt;= eps = 1/50</code>. 
That form is used here also.  
</p>
<p>For <code>invBoxCox</code> a complementary 
analysis is as follows:  
</p>
<p><code>abs(y+lambda[2]) = abs(1+la*w)^(1/la)</code>
</p>
<p>= <code>exp(log1p(la*w)/la) for abs(la*w)&lt;1</code> 
</p>
<p>= <code>w * (1-la*w * ((1/2)-la*w * 
  ((1/3)-la*w*(1/4-...))))</code>
</p>


<h3>Value</h3>

<p><code>BoxCox</code> returns an object of class 
<code>BoxCox</code>, being a numeric vector of the 
same length as <code>y</code> with the following 
optional attributes:  
</p>

<ul>
<li>
<p><code>lambda</code>
the value of <code>lambda</code> 
used in the transformation

</p>
</li>
<li>
<p><code>sign.y</code>
sign(y) (or sign(y-lambda[2]) lambda[2] is
provided and if any of these quantities are
negative.  Otherwise, this is omitted and all
are assumed to be positive.

</p>
</li>
<li>
<p><code>rescale</code>
logical:  
<code>TRUE</code> if <code>z(y, lambda)</code> 
is returned rescaled by <code>g^(lambda-1)</code>
with g = the geometric mean of y 
</p>
<p>and <code>FALSE</code> if <code>z(y, lambda)</code> is 
not so rescaled.  

</p>
</li>
<li>
<p><code>GeometricMean</code>
If <code>rescale</code> is numeric, 
<code>attr(., 'GeometricMean') &lt;- rescale</code>.  
</p>
<p>Otherwise, <code>attr(., 'GeometricMean')</code> is 
the Geometric mean of <code>abs(y) = 
      exp(mean(log(abs(y)))) or of 
      abs(y+lambda[2]) if(length(lambda)&gt;1)</code>.  

</p>
</li>
</ul>
<p><code>invBoxCox</code> returns a numeric vector,
reconstructing <code>y</code> from 
<code>BoxCox(y, ...)</code>.  
</p>


<h3>Source</h3>

<p>Bickel, Peter J., and Doksum, Kjell A. (1981) 
"An analysis of transformation revisited", 
<em>Journal of the American Statistical
Association</em>, 76 (374):  296-311  
</p>
<p>Box, George E. P.; Cox, D. R. (1964). 
"An analysis of transformations", 
<em>Journal of the Royal Statistical Society</em>, 
Series B 26 (2): 211-252. 
</p>
<p>Box, George E. P.; Cox, D. R. (1982). 
"An analysis of transformations revisited,
rebutted", 
<em>Journal of the American Statistical Association</em>, 
77(377): 209-210.    
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Power_transform">Wikipedia, "Power transform"</a>
</p>


<h3>See Also</h3>

<p><code>boxcox</code> in the MASS package 
</p>
<p><code>quine</code> in the MASS package 
for data used in an example below.  
</p>
<p><code>boxcox</code> and 
<code>boxcoxCensored</code> in the
<code>EnvStats</code> package.  
</p>
<p><code>boxcox.drc</code> in the 
<code>drc</code> package.  
</p>
<p><code>boxCox</code> in the <code>car</code>
package.  
</p>
<p>These other uses all wrap the Box-Cox 
transformation in something larger and do not 
give the transformation itself directly.  
</p>


<h3>Examples</h3>

<pre><code class="language-R">##
## 1.  A simple example to check the two algorithms 
##
Days &lt;- 0:9
bc1 &lt;- BoxCox(Days, c(0.01, 1))
# Taylor expansion used for obs 1:7; expm1 for 8:10 

# check 
GM &lt;- exp(mean(log(abs(Days+1))))

bc0 &lt;- (((Days+1)^0.01)-1)/0.01
bc1. &lt;- (bc0 / (GM^(0.01-1)))  
# log(Days+1) ranges from 0 to 4.4 
# lambda = 0.01 will invoke both the obvious
# algorithm and the alternative assumed to be 
# more accurate for (lambda(log(y)) &lt; 0.02).  
attr(bc1., 'lambda') &lt;- c(0.01, 1)  
attr(bc1., 'rescale') &lt;- TRUE 
attr(bc1., 'GeometricMean') &lt;- GM 
class(bc1.) &lt;- 'BoxCox'


all.equal(bc1, bc1.)


##
## 2.  another simple example with lambda=0
##
bc0.4 &lt;- BoxCox(1:5, 0)
GM5 &lt;- prod(1:5)^.2
bc0.4. &lt;- log(1:5)*GM5
attr(bc0.4., 'lambda') &lt;- 0  
attr(bc0.4., 'rescale') &lt;- TRUE 
attr(bc0.4., 'GeometricMean') &lt;- GM5 
class(bc0.4.) &lt;- 'BoxCox'


all.equal(bc0.4, bc0.4.)


bc0.4e9 &lt;- BoxCox(1:5, .Machine$double.eps)
bc0.4ex &lt;- log(1:5)*exp(mean(log(1:5)))

all.equal(bc0.4ex, as.numeric(bc0.4e9))


# now invert:  

bc0.4i &lt;- invBoxCox(bc0.4.)

all.equal(1:5, bc0.4i)



all.equal(1:5, invBoxCox(bc0.4e9))


##
## 3.  The "boxcox" function in the MASS package 
##     computes a maximum likelihood estimate with  
##     BoxCox(Days+1, lambda=0.21) 
##     with a 95 percent confidence interval of 
##     approximately (0.08, 0.35)
##
bcDays1 &lt;- BoxCox(MASS::quine$Days, c(0.21, 1))

# check 
GeoMean &lt;- exp(mean(log(abs(MASS::quine$Days+1))))

bcDays1. &lt;- ((((MASS::quine$Days+1)^0.21)-1) / 
               (0.21*GeoMean^(0.21-1)))  
# log(Days+1) ranges from 0 to 4.4 
attr(bcDays1., 'lambda') &lt;- c(0.21, 1)  
attr(bcDays1., 'rescale') &lt;- TRUE 
attr(bcDays1., 'GeometricMean') &lt;- GeoMean 
class(bcDays1.) &lt;- 'BoxCox'


all.equal(bcDays1, bcDays1.)


iDays &lt;- invBoxCox(bcDays1)

all.equal(iDays, MASS::quine$Days)


##
## 4.  Easily computed example 
##
bc2 &lt;- BoxCox(c(1, 4), 2)

# check 
bc2. &lt;- (c(1, 4)^2-1)/4
attr(bc2., 'lambda') &lt;- 2
attr(bc2., 'rescale') &lt;- TRUE 
attr(bc2., 'GeometricMean') &lt;- 2 
class(bc2.) &lt;- 'BoxCox'


all.equal(bc2, bc2.)



all.equal(invBoxCox(bc2), c(1, 4))


##
## 5.  plot(BoxCox())
##
y0 &lt;- seq(-2, 2, .1)
z2 &lt;- BoxCox(y0, 2, rescale=FALSE)
plot(y0, z2)

# check 
z2. &lt;- (sign(y0)*y0^2-1)/2

attr(z2., 'lambda') &lt;- 2
attr(z2., 'sign.y') &lt;- sign(y0, 1)
attr(z2., 'rescale') &lt;- FALSE 
attr(z2., 'GeometricMean') &lt;- 0
class(z2.) &lt;- 'BoxCox'


all.equal(z2, z2.)



all.equal(invBoxCox(z2), y0)


</code></pre>


</div>