<div class="container">

<table style="width: 100%;"><tr>
<td>biprobit_latent</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Recursive Bivariate Probit Model with Latent First Stage</h2>

<h3>Description</h3>

<p>Estimate two probit models with bivariate normally distributed error terms, in which the dependent variable of the first stage model is unobserved.<br><br>
First stage (Probit, <code class="reqn">m_i^*</code> is unobserved):
</p>
<p style="text-align: center;"><code class="reqn">m_i^*=1(\boldsymbol{\alpha}'\mathbf{w_i}+u_i&gt;0)</code>
</p>

<p>Second stage (Probit):
</p>
<p style="text-align: center;"><code class="reqn">y_i = 1(\boldsymbol{\beta}'\mathbf{x_i} + {\gamma}m_i^* + \sigma v_i&gt;0)</code>
</p>

<p>Endogeneity structure:
<code class="reqn">u_i</code> and <code class="reqn">v_i</code> are bivariate normally distributed with a correlation of <code class="reqn">\rho</code>. <br><br>
w and x can be the same set of variables. The identification of this model is generally weak, especially if w are not good predictors of m. <code class="reqn">\gamma</code> is assumed to be positive to ensure that the model estimates are unique.
</p>


<h3>Usage</h3>

<pre><code class="language-R">biprobit_latent(
  form1,
  form2,
  data = NULL,
  EM = FALSE,
  par = NULL,
  method = "BFGS",
  verbose = 0,
  maxIter = 500,
  tol = 1e-05,
  tol_LL = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>form1</code></td>
<td>
<p>Formula for the first probit model, in which the dependent variable is unobserved. Use a formula like ~w to avoid specifying the dependent variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>form2</code></td>
<td>
<p>Formula for the second probit model, the latent dependent variable of the first stage is automatically added as a regressor in this model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Input data, a data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EM</code></td>
<td>
<p>Whether to maximize likelihood use the Expectation-Maximization (EM) algorithm, which is slower but more robust. Defaults to FLASE, but should change to TRUE is the model has convergence issues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>Starting values for estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Optimization algorithm. Default is BFGS</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A integer indicating how much output to display during the estimation process.
</p>

<ul>
<li>
<p> &lt;0 - No ouput
</p>
</li>
<li>
<p> 0 - Basic output (model estimates)
</p>
</li>
<li>
<p> 1 - Moderate output, basic ouput + parameter and likelihood in each iteration
</p>
</li>
<li>
<p> 2 - Extensive output, moderate output + gradient values on each call
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>max iterations for EM algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance for convergence of EM algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_LL</code></td>
<td>
<p>tolerance for convergence of likelihood</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the results of the estimated model, some of which are inherited from the return of maxLik
</p>

<ul>
<li>
<p> estimates: Model estimates with 95% confidence intervals. Prefix "1" means first stage variables.
</p>
</li>
<li>
<p> estimate or par: Point estimates
</p>
</li>
<li>
<p> variance_type: covariance matrix used to calculate standard errors. Either BHHH or Hessian.
</p>
</li>
<li>
<p> var: covariance matrix
</p>
</li>
<li>
<p> se: standard errors
</p>
</li>
<li>
<p> gradient: Gradient function at maximum
</p>
</li>
<li>
<p> hessian: Hessian matrix at maximum
</p>
</li>
<li>
<p> gtHg: <code class="reqn">g'H^-1g</code>, where H^-1 is simply the covariance matrix. A value close to zero (e.g., &lt;1e-3 or 1e-6) indicates good convergence.
</p>
</li>
<li>
<p> LL or maximum: Likelihood
</p>
</li>
<li>
<p> AIC: AIC
</p>
</li>
<li>
<p> BIC: BIC
</p>
</li>
<li>
<p> n_obs: Number of observations
</p>
</li>
<li>
<p> n_par: Number of parameters
</p>
</li>
<li>
<p> iterations: number of iterations taken to converge
</p>
</li>
<li>
<p> message: Message regarding convergence status.
</p>
</li>
</ul>
<p>Note that the list inherits all the components in the output of maxLik. See the documentation of maxLik for more details.
</p>


<h3>References</h3>

<p>Peng, Jing. (2023) Identification of Causal Mechanisms from Randomized Experiments: A Framework for Endogenous Mediation Analysis. Information Systems Research, 34(1):67-84. Available at https://doi.org/10.1287/isre.2022.1113
</p>


<h3>See Also</h3>

<p>Other endogeneity: 
<code>bilinear()</code>,
<code>biprobit_partial()</code>,
<code>biprobit()</code>,
<code>linear_probit()</code>,
<code>pln_linear()</code>,
<code>pln_probit()</code>,
<code>probit_linearRE()</code>,
<code>probit_linear_latent()</code>,
<code>probit_linear_partial()</code>,
<code>probit_linear()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(MASS)
N = 2000
rho = -0.5
set.seed(1)

x = rbinom(N, 1, 0.5)
z = rnorm(N)

e = mvrnorm(N, mu=c(0,0), Sigma=matrix(c(1,rho,rho,1), nrow=2))
e1 = e[,1]
e2 = e[,2]

m = as.numeric(1 + x + z + e1 &gt; 0)
y = as.numeric(1 + x + z + m + e2 &gt; 0)

est = biprobit(m~x+z, y~x+z+m)
print(est$estimates, digits=3)

est_latent = biprobit_latent(~x+z, y~x+z)
print(est_latent$estimates, digits=3)

</code></pre>


</div>