<div class="container">

<table style="width: 100%;"><tr>
<td>interpolateRasts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Interpolate values from a series of rasters</h2>

<h3>Description</h3>

<p>This function returns a series of rasters interpolated from another series of rasters. For example, the input might represent rasters of a process measured at times t, t + 1, and t + 4. The rasters at t + 2 and t + 3 could be interpolated based on the values in the other rasters. Note that this function can take a lot of time and memory, even for relatively small rasters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">interpolateRasts(
  rasts,
  interpFrom,
  interpTo,
  type = "linear",
  onFail = NA,
  useRasts = FALSE,
  na.rm = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rasts</code></td>
<td>
<p>A "stack" of <code>SpatRasters</code>s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpFrom</code></td>
<td>
<p>Numeric vector, one value per raster in <code>rasts</code>. Values represent "distance" along the set of rasters rasters (e.g., time).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpTo</code></td>
<td>
<p>Numeric vector, values of "distances" at which to interpolate the rasters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character. The type of model used to do the interpolation. Note that some of these (the first few) are guaranteed to go through every point being interpolated from. The second set, however, are effectively regressions so are not guaranteed to do through <em>any</em> of the points. Note that some methods cannot handle cases where at least some series of cells have &lt; a given number of non-<code>NA</code> values (e.g., smooth splines will not work if there are &lt; 4 cells with non-<code>NA</code> values).
</p>

<ul>
<li> <p><code>linear</code>: A model based on linear segments "fastened" at each value of <code>interpFrom</code>. The segments will intersect each value being interpolated from.
</p>
</li>
<li> <p><code>spline</code>: A natural splines-based model. Splines will intersect each value being interpolated from.
</p>
</li>
<li> <p><code>gam</code>: A generalized additive model. Note that the GAM is <em>not</em> guaranteed to intersect each value being interpolated from. Arguments to <code>gam</code> can be supplied via <code>...</code>. Especially note the <code>family</code> argument! You can use the <code>onFail</code> argument with this method since in some cases <code>gam</code> if there are too few data points.
</p>
</li>
<li> <p><code>glm</code>: A generalized linear model. Note that the GLM is <em>not</em> guaranteed to intersect each value being interpolated from. Arguments to <code>gam</code> can be supplied via <code>...</code>. Especially note the <code>family</code> argument (the main reason for why you would use a GLM versus just linear interpolation)! You can use the <code>onFail</code> argument with this method since in some cases <code>glm</code> if there are too few data points.
</p>
</li>
<li> <p><code>ns</code>: A natural splines model. Note that the NS is <em>not</em> guaranteed to intersect each value being interpolated from. Arguments to <code>trainNS</code> can be supplied via <code>...</code>. Especially note the <code>family</code> argument and the <code>df</code> argument! If <code>df</code> is not supplied, then the number of splines attempted will be equal to <code>1:(length(interpFrom) - 1)</code>. You can use the <code>onFail</code> argument with this method.
</p>
</li>
<li> <p><code>poly</code>: A polynomial model. This method constructs an <em>n</em>-degree polynomial where <em>n</em> = <code>length(interpFrom) - 1</code>. The most parsimonious model is then selected from all possible subsets of models (including an intercept-only model) using AICc. This method is <em>not</em> guaranteed to intersect each value being interpolated from. Arguments to <code>glm</code> can be supplied via <code>...</code>. Especially note the <code>family</code> argument! If <code>family</code> is not supplied, then the response is assumed to have a Gaussian distribution. You can use the <code>onFail</code> argument with this method.
</p>
</li>
<li> <p><code>bs</code>: A basis-spline model. This method constructs a series of models with <em>n</em>-degree basis-spline model where <em>n</em> ranges from 3 to <code>length(interpFrom) - 1</code>. The most parsimonious model is then selected from all possible subsets of models (including an intercept-only model) using AICc. This method is <em>not</em> guaranteed to intersect each value being interpolated from. Arguments to <code>glm</code> can be supplied via <code>...</code>. Especially note the <code>family</code> argument! If <code>family</code> is not supplied, then the response is assumed to have a Gaussian distribution. You can use the <code>onFail</code> argument with this method.
</p>
</li>
<li> <p><code>smooth.spline</code>: A smooth-spline model (see <code>smooth.spline</code>). This method is <em>not</em> guaranteed to intersect each value being interpolated from. Arguments to <code>smooth.spline</code> can be supplied via <code>...</code>. Unlike some other methods, a <code>family</code> cannot be specified (Gaussian is assumed)! You can use the <code>onFail</code> argument with this method.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onFail</code></td>
<td>
<p>Either <code>NA</code> (default) or any one of <code>'linear'</code>, <code>'spline'</code>, or <code>'poly'</code>. If a method specified by <code>type</code> fails (i.e., because there are fewer than the required number of values to interpolate from), this method is used in its place. If this is <code>NA</code> and the method fails, then an error occurs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useRasts</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), then the calculations are done using arrays. This can be substantially faster than using rasters (when <code>useRasts = TRUE</code>), but also run into memory issues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then ignore cases where all values in the same cells across rasters from which interpolations are made are <code>NA</code> (i.e., do not throw an error). If <code>FALSE</code>, then throw an error when this occurs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), display progress.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed to <code>approx</code> or <code>spline</code> (<em>do not</em> include any of these arguments: <code>x</code>, <code>y</code>, or <code>xout</code>), or to <code>glm</code>, <code>gam</code>, or <code>smooth.spline</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function can be very memory-intensive for large rasters.  It may speed things up (and make them possible) to do interpolations piece by piece (e.g., instead of interpolating between times t0, t1, t2, t3, ..., interpolate between t0 and t1, then t1 and t2, etc. This may give results that differ from using the entire set, however, depending on what type of interpolation is used. Note that using linear and splines will often yield very similar results, except that in a small number of cases splines may produce very extreme interpolated values.
</p>


<h3>Value</h3>

<p>A <code>SpatRaster</code> "stack" with one layer per element in <code>interpTo</code>.
</p>


<h3>See Also</h3>

<p><code>approximate</code>, <code>approxfun</code>, <code>splinefun</code>, <code>trainNS</code>, <code>glm</code>, , <code>bs</code>, <code>smooth.spline</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

# NB: The example below can take a few minutes to run.

library(terra)

interpFrom &lt;- c(1, 3, 4, 8, 10, 11, 15)
interpTo &lt;- 1:15
rx &lt;- rast(nrows=10, ncols=10)
r1 &lt;- setValues(rx, rnorm(100, 1))
r3 &lt;- setValues(rx, rnorm(100, 3))
r4 &lt;- setValues(rx, rnorm(100, 5))
r8 &lt;- setValues(rx, rnorm(100, 11))
r10 &lt;- setValues(rx, rnorm(100, 3))
r11 &lt;- setValues(rx, rnorm(100, 5))
r15 &lt;- setValues(rx, rnorm(100, 13))
rasts &lt;- c(r1, r3, r4, r8, r10, r11, r15)
names(rasts) &lt;- paste0('rasts', interpFrom)

linear &lt;- interpolateRasts(rasts, interpFrom, interpTo)
spline &lt;- interpolateRasts(rasts, interpFrom, interpTo, type='spline')
gam &lt;- interpolateRasts(rasts, interpFrom, interpTo, type='gam', onFail='linear')
ns &lt;- interpolateRasts(rasts, interpFrom, interpTo, type='ns', onFail='linear', verbose=FALSE)
poly &lt;- interpolateRasts(rasts, interpFrom, interpTo, type='poly', onFail='linear')
bs &lt;- interpolateRasts(rasts, interpFrom, interpTo, type='bs', onFail='linear')
ss &lt;- interpolateRasts(rasts, interpFrom, interpTo, type='smooth.spline', onFail='linear',
verbose=FALSE)

# examine trends for a particular point on the landscape
pts &lt;- matrix(c(-9, 13), ncol = 2)
pts &lt;- vect(pts)
linearExt &lt;- unlist(terra::extract(linear, pts, ID=FALSE))
splineExt &lt;- unlist(terra::extract(spline, pts, ID=FALSE))
gamExt &lt;- unlist(terra::extract(gam, pts, ID=FALSE))
nsExt &lt;- unlist(terra::extract(ns, pts, ID=FALSE))
polyExt &lt;- unlist(terra::extract(poly, pts, ID=FALSE))
bsExt &lt;- unlist(terra::extract(bs, pts, ID=FALSE))
ssExt &lt;- unlist(terra::extract(ss, pts, ID=FALSE))

mins &lt;- min(linearExt, splineExt, gamExt, nsExt, polyExt, bsExt, ssExt)
maxs &lt;- max(linearExt, splineExt, gamExt, nsExt, polyExt, bsExt, ssExt)

plot(interpTo, linearExt, type='l', lwd=2, ylim=c(mins, maxs), ylab='Value')
lines(interpTo, splineExt, col='blue')
lines(interpTo, gamExt, col='green')
lines(interpTo, nsExt, col='orange')
lines(interpTo, polyExt, col='gray')
lines(interpTo, bsExt, col='magenta')
lines(interpTo, ssExt, col='cyan')

ext &lt;- unlist(extract(rasts, pts, ID = FALSE))
points(interpFrom, ext)

legend('topleft', inset=0.01, lty=c(rep(1, 7), NA),
legend=c('linear', 'spline', 'GAM', 'NS', 'polynomial', 'B-spline',
'Smooth spline', 'Observed'), col=c('black', 'blue', 'green',
'orange', 'gray', 'magenta', 'cyan'), pch=c(rep(NA, 7), 1))



</code></pre>


</div>