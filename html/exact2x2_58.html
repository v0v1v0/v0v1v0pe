<div class="container">

<table style="width: 100%;"><tr>
<td>uncondExact2x2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Unconditional exact tests for 2x2 tables
</h2>

<h3>Description</h3>

<p>The <code>uncondExact2x2</code> function tests 2x2 tables assuming two independent binomial responses. Unlike the conditional exact tests which condition on both margins of the 2x2 table (see <code>exact2x2</code>), these unconditional tests only condition on one margin of the 2x2 table (i.e., condition on the sample sizes of the binomial responses). This makes the calculations difficult because now there is a nuisance parameter and calculations must be done over nearly the entire nuisance parameter space. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">uncondExact2x2(x1, n1, x2, n2, 
    parmtype = c("difference", "ratio", "oddsratio"), nullparm = NULL, 
    alternative = c("two.sided","less", "greater"),  
    conf.int = FALSE, conf.level = 0.95, 
    method = c("FisherAdj", "simple", "score","wald-pooled", "wald-unpooled",  "user", 
      "user-fixed"), 
    tsmethod = c("central","square"), midp = FALSE, 
    gamma = 0, EplusM=FALSE, tiebreak=FALSE,
    plotprobs = FALSE, control=ucControl(), Tfunc=NULL,...)

uncondExact2x2Pvals(n1, n2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>number of events in group 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n1</code></td>
<td>
<p>sample size in group 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2</code></td>
<td>
<p>number of events in group 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n2</code></td>
<td>
<p>sample size in group 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parmtype</code></td>
<td>

<p>type of parameter of interest, one of "difference", "ratio" or "oddsratio" (see details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullparm</code></td>
<td>

<p>value of the parameter of interest at null hypothesis, NULL defaults to 0 for parmtype='difference' and 1 for parmtype='ratio' or 'oddsratio' 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>

<p>alternative hypothesis, one of "two.sided", "less", or "greater", default is "two.sided" (see details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int</code></td>
<td>
<p>logical, calculate confidence interval?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>

<p>confidence level
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>method type, one of "FisherAdj" (default), "simple", "simpleTB", "wald-pooled", "wald-unpooled", "score", "user", or "user-fixed" (see details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tsmethod</code></td>
<td>
<p>two-sided method, either "central" or "square" (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>midp</code></td>
<td>
<p>logical. Use mid-p-value method?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Beger-Boos adjustment parameter. 0 means no adjustment. (see details).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EplusM</code></td>
<td>
<p>logical, do the E+M adjustment? (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tiebreak</code></td>
<td>
<p>logical, do tiebreak adjustment? (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotprobs</code></td>
<td>
<p>logical, plot probabilities?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list of algorithm parameters, see <code>ucControl</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tfunc</code></td>
<td>
<p>test statistic function for ordering the sample space when method='user', ignored otherwise (see details) 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>extra arguments passed to Tfunc (for uncondExact2x2), or passed to uncondExact2x2 (for uncondExact2x2Pvals)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>uncondExact2x2</code> function gives unconditional exact tests and confidence intervals for two independent binomial observations. The <code>uncondExact2x2Pvals</code> function repeatedly calls <code>uncondExact2x2</code> to get the p-values
for the entire sample space. 
</p>
<p>Let X1 be binomial(n1,theta1) and X2 be binomial(n2,theta2). The parmtype determines the parameter of interest: ‘difference’ is theta2 - theta1, 'ratio' is theta2/theta1, and ‘oddsratio’ 
is (theta2*(1-theta1))/(theta1*(1-theta2)). 
</p>
<p>The options <code>method</code>, <code>parmtype</code>, <code>tsmethod</code>, <code>alternative</code>,
<code>EplusM</code>, and <code>tiebreak</code> define some built-in test statistic
function, Tstat, that is used to order the sample space, using <code>pickTstat</code> and <code>calcTall</code>. The first 5 arguments of Tstat must be
<code>Tstat(X1,N1,X2,N2, delta0)</code>, where X1 and X2 must allow vectors,
and delta0 is the null parameter value (but delta0 does not need to be used in the ordering). 
Ordering when <code>parmtype="ratio"</code>
or <code>parmtype="oddsratio"</code> is only used when there is information about the 
parameter. So the ordering function value is not used for ordering when x1=0 and x2=0 for <code>parmtype="ratio"</code>, and 
it is not used when (x1=0 and x2=0) or (x1=n1 and x2=n2) for <code>parmtype="oddsratio"</code>.
</p>
<p>We describe the ordering functions first for the basic case,  the case when <code>tsmethod="central"</code> or <code>alternative!="two.sided"</code>,
<code>EplusM=FALSE</code>, and <code>tiebreak=FALSE</code>. In this basic case the ordering function, Tstat, is determined by <code>method</code> and <code>parmtype</code>:
</p>

<ul>
<li>
<p> method='simple' - Tstat essentially replaces theta1 with x1/n1 and theta2 with x2/n2 in the parameter definition. If parmtype=‘difference’ 
then <code>Tstat(X1,N1,X2,N2,delta0)</code> returns  <code>X2/N2-X1/N1-delta0</code>. If parmtype='ratio' then the Tstat function
returns <code>log(X2/N2) - log(X1/N1) - log(delta0)</code>.
If parmtype='oddsratio' we get
<code>log( X2*(N1-X1)/(delta0*X1*(N2-X2)))</code>. 
</p>
</li>
<li>
<p> method='wald-pooled' - Tstat is a Z statistic on the difference  using the pooled variance (not allowed if <code>parmtype!="difference"</code>)
</p>
</li>
<li>
<p>  method='wald-unpooled' - Tstat is a Z statistics on the difference using unpooled variance (not allowed if <code>parmtype!="difference"</code>)
</p>
</li>
<li>
<p> method='score' - Tstat is a Z statistic formed using score statistics,
where the parameter is defined by parmtype,
and the constrained maximum likelihood estimates of the parameter are calculated 
by <code>constrMLE.difference</code>, <code>constrMLE.ratio</code>, 
or <code>constrMLE.oddsratio</code>. 
</p>
</li>
<li>
<p> method='FisherAdj' - Tstat is a one-sided Fisher's 'exact' mid p-value. The mid p-value is an adjustment for ties that technically removes the 'exactness' of the Fisher's p-value...BUT, here we are only using it to order the sample space, so the results of the resulting unconditional test will still be exact. 
</p>
</li>
<li>
<p> method='user' - Tstat is a user supplied statistic given by <code>Tfunc</code>, it must be a function with the first 5 elements of its call being (X1, N1, X2, N2, delta0). The function must returns a vector of length the same as X1 and X2, where higher values suggest larger theta2 compared to theta1 (when <code>tsmethod!="square"</code>) or 
higher values suggest more extreme (when <code>tsmethod=="square"</code> and 
<code>alternative=="two.sided"</code>). A slower algorithm that does not require monotonicity of one-sided p-values with respect to delta0 is used.
</p>
</li>
<li>
<p> method='user-fixed' - For advanced users. Tstat is a user supplied statistic given by <code>Tfunc</code>. It should have first 5 elements as described above but its result should not change with delta0 and it must meet Barnard's 
convexity conditions. If these conditions are met (the conditions 
are not checked, since checking them will slow the algorithm), then the p-values will be monotonic in delta0 (the null parameter for a two-sided test) and we can use a faster algorithm.
</p>
</li>
</ul>
<p>In the basic case, if <code>alternative="two.sided"</code>, the argument <code>tsmethod</code>="central" gives the two-sided central method. The p-value is just twice the minimum of the 
one-sided p-values (or 1 if the doubling is greater than 1). 
</p>
<p>Now consider cases other than the basic case. 
The <code>tsmethod="square"</code> option gives the square of the test statistic
(when method="simple", "score", "wald-pooled", or "wald-unpooled") and larger values suggest rejection in either direction (unless method='user', then the user supplies any test statistic for which larger values suggest rejection).
</p>
<p>The <code>tiebreak=TRUE</code> option breaks ties in a reasonable way when 
<code>method="simple"</code> (see 'details' section of <code>calcTall</code>).
The <code>EplusM=TRUE</code> option performs Lloyd's (2008) E+M ordering 
on Tstat (see 'details' section of <code>calcTall</code>).
</p>
<p>If <code>tiebreak=TRUE</code> and <code>EplusM=TRUE</code>, the tiebreak calculations are always done first. 
</p>
<p>Berger and Boos (1994) developed a very general method for calculating p-values when a nuisance parameter is present.
First, calculate a (1-gamma) confidence interval for the nuisance parameter, check for the supremum over the union of the null hypothesis parameter space 
and that confidence interval, then add back gamma to the p-value. This adjustment is valid (in other words, applied to exact tests it still gives an adjustment that is exact). The Berger-Boos adjustment is applied when <code>gamma</code>&gt;0.
</p>
<p>When method='simple' or method='user-fixed' does a simple grid search algorithm using <code>unirootGrid</code>.
No checks are done on the Tstat function when method='user-fixed' to make sure the simple grid search will converge to the 
proper answer. So method='user-fixed' should be used by advanced users only. 
</p>
<p>When <code>midp=TRUE</code> the mid p-value is calculated (and the associated confidence interval if <code>conf.int=TRUE</code>) instead of the standard p-value. Loosely speaking, the standard p-value calculates the probability of observing equal or more extreme responses, while the  mid p-value calculates the probability of more extreme responses plus 1/2 the probability of equally extreme responses. The tests and confidence intervals when 
<code>midp=TRUE</code> are not exact, but give type I error rates and coverage of confidence intervals closer to the nominal values.
The mid p-value was studied by Lancaster (1961), see vignette on mid p-values for details. 
</p>
<p>See Fay and Hunsberger (2021) for a review paper giving the details for these kinds of unconditional exact tests.
</p>


<h3>Value</h3>

<p>The function <code>uncondExact2x2Pvals</code> returns a (n1+1) by (n2+1) matrix of p-values for all possible x1 and x2 values, while <code>uncondExact2x2</code> returns
a list of class 'htest' with elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>proportion in sample 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p>proportion in sample 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>p-value from test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int</code></td>
<td>
<p>confidence interval on parameter given by parmtype</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate</code></td>
<td>
<p>MLE estimate of parameter given by parmtype</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null.value</code></td>
<td>
<p>null hypothesis value of parameter given by parmtype</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>alternative hypothesis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>description of test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.name</code></td>
<td>
<p>description of data</p>
</td>
</tr>
</table>
<h3>Warning </h3>

<p>The algorithm for calculating the p-values and confidence intervals is based on a series of grid searches.
Because the grid searches are often trying to optimize non-monotonic functions, the algorithm is not 
guaranteed to give the correct answer. At the cost of increasing computation time, 
better accuracy can be obtained by increasing 
control$nPgrid,  and less often by increasing control$nCIgrid.
</p>


<h3>Author(s)</h3>

<p>Michael P. Fay, Sally A. Hunsberger
</p>


<h3>References</h3>

<p>Berger, R. L. and Boos, D. D. (1994). P values maximized
over a confidence set for the nuisance parameter. Journal
of the American Statistical Association 89 1012-1016.
</p>
<p>Fay, M.P. and Hunsberger, S.A. (2021). Practical valid inferences for the two-sample binomial problem. Statistics Surveys 15:72-110.
</p>
<p>Lancaster, H.O. (1961). Significance tests in discrete distributions. JASA 56: 223-234.
</p>
<p>Lloyd, C. J. (2008). Exact p-values for discrete models obtained
by estimation and maximization. Australian &amp; New
Zealand Journal of Statistics 50 329-345.
</p>


<h3>See Also</h3>

<p> See <code>boschloo</code> for unconditional exact tests with ordering
function based on Fisher's exact p-values. </p>


<h3>Examples</h3>

<pre><code class="language-R"># default uses method="FisherAdj"
uncondExact2x2(1,10,9,10, 
               parmtype="ratio")
uncondExact2x2(1,10,9,10, 
               method="score",parmtype="ratio")





</code></pre>


</div>