<div class="container">

<table style="width: 100%;"><tr>
<td>etas</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit the space-time ETAS model to data</h2>

<h3>Description</h3>

<p>A function to fit the space-time version of the Epidemic Type
Aftershock Sequence (ETAS) model to a catalog of earthquakes
(a spatio-temporal point pattern) and perform a stochastic
declustering method.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> etas(object, param0 = NULL, bwd = NULL, nnp = 5, bwm = 0.05,
      verbose = TRUE, plot.it = FALSE, ndiv = 1000, no.itr = 11,
      rel.tol=1e-03, eps = 1e-06, cxxcode = TRUE, nthreads = 1,
      mver = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>"catalog"</code> containing an
earthquake catalog dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param0</code></td>
<td>
<p>Initial guess for model parameters. A numeric vector
of appropriate length (currently 8). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bwd</code></td>
<td>
<p>Optional. Bandwidths for smoothness and integration
on the geographical region <code>win</code>. A numeric vector
which has the length of the number of events.
If not supplied, the following arguments <code>nnp</code> and
<code>bwm</code> determine bandwidths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nnp</code></td>
<td>
<p>Number of nearest neighbors for bandwidth calculations. An integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bwm</code></td>
<td>
<p>Minimum bandwidth. A positive numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical flag indicating whether to print progress reports.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.it</code></td>
<td>
<p>Logical flag indicating whether plot probabilities of
each event being a background event on a map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndiv</code></td>
<td>
<p>An integer indicating the number of knots on each
side of the geographical region for integral approximation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.itr</code></td>
<td>
<p>An integer indicating the number of iterations for
convergence of the iterative approach of simultaneous estimation
and declustering algorithm. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel.tol</code></td>
<td>
<p>Relative iteration convergence tolerance of the
iterative estimation approach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Optimization  convergence tolerance in the
Davidon-Fletch-Powell algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cxxcode</code></td>
<td>
<p>Logical flag indicating whether to use the C++ code.
The C++ code is slightly faster and allows parallel computing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>An integer indicating number of threads in
the parallel region of the C++ code</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mver</code></td>
<td>
<p>An integer indicating which spatial probability density 
function for locations of triggered events should be use. 
The default <code>mver=1</code> corresponds to the inverse 
power density and <code>mver=2</code> corresponds to the 
Gaussian density.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Ogata (1988) introduced the epidemic type aftershock sequence
(ETAS) model based on Gutenberg-Richter law and modified Omori law.
In its space-time representation (Ogata, 1998), the ETAS model is a
temporal marked point process model, and a special case of marked
Hawkes process, with conditional intensity function
</p>
<p style="text-align: center;"><code class="reqn">
      \lambda(t, x, y | H_t) = \mu(x,y) + \sum_{t_i &lt; t} k(m_i)g(t - t_i)f(x - x_i, y - y_i|m_i)
    </code>
</p>

<p>where
</p>

<dl>
<dt>
<code class="reqn">H_t</code>: </dt>
<dd>
<p>is the observational history up to time t, but not
including t; that is
</p>
<p style="text-align: center;"><code class="reqn">H_t=\{(t_i, x_i, y_i, m_i): t_i &lt; t\}</code>
</p>

</dd>
<dt>
<code class="reqn">\mu(x,y)</code>: </dt>
<dd>
<p>is the background intensity. Currently it
is assumed to take the semi-parametric form
</p>
<p style="text-align: center;"><code class="reqn">\mu(x,y)=\mu u(x,y)</code>
</p>

<p>where <code class="reqn">\mu</code> is an unknown constant and <code class="reqn">u(x,y)</code>
is an unknown function.
</p>
</dd>
<dt>
<code class="reqn">k(m)</code>: </dt>
<dd>
<p>is the expected number of events triggered
from an event of magnitude <code class="reqn">m</code> given by
</p>
<p style="text-align: center;"><code class="reqn">k(m) = A\exp(\alpha(m - m_0))</code>
</p>

</dd>
<dt>
<code class="reqn">g(t)</code>: </dt>
<dd>
<p>is the p.d.f of the occurrence
times of the triggered events, taking the form
</p>
<p style="text-align: center;"><code class="reqn">g(t) =  \frac{p-1}{c}(1 + \frac{t}{c})^{-p}</code>
</p>

</dd>
<dt>
<code class="reqn">f(x,y|m)</code>: </dt>
<dd>
<p>is the p.d.f of
the locations of the triggered events, considered to be
either the long tail inverse power density (<code>mver = 1</code>)
</p>
<p style="text-align: center;"><code class="reqn"> f(x, y|m) = \frac{q-1}{\pi \sigma(m))}
             (1 + \frac{x^2 + y^2}{\sigma(m)})^{-q} </code>
</p>

<p>or the light tail Gaussian density (<code>mver = 2</code>, only can be used if <code>cxxcode = TRUE</code>)
</p>
<p style="text-align: center;"><code class="reqn"> f(x,y|m)= \frac{1}{2\pi \sigma(m)}\exp(-\frac{x^2 + y^2}{2\sigma(m)}) </code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn"> \sigma(m) = D\exp(\gamma(m - m_0)) </code>
</p>

</dd>
</dl>
<p>The ETAS models classify seismicity into two components, background
seismicity <code class="reqn">\mu(x, y)</code> and clustering seismicity
<code class="reqn">\lambda(t, x, y|H_t) - \mu(x, y)</code>, where
each earthquake event, whether it is a background event or generated by
another event, produces its own offspring according to the branching rules
controlled by <code class="reqn">k(m)</code>, <code class="reqn">g(m)</code> and <code class="reqn">f(x, y|m)</code>.
</p>
<p>Background seismicity rate <code class="reqn">u(x, y)</code> and the model parameters
</p>
<p style="text-align: center;"><code class="reqn">\theta=(\mu, A, c, \alpha, p, D, q, \gamma)</code>
</p>

<p>are estimated simultaneously using an iterative approach proposed in Zhuang et al. (2002).
First, for an initial <code class="reqn">u_0(x, y)</code>, the parameter vector
<code class="reqn">\theta</code>  is estimated by maximizing the log-likelihood function
</p>
<p style="text-align: center;"><code class="reqn">l(\theta)=\sum_{i} \lambda(t_i, x_i, y_i|H_{t_i}) - \int \lambda(t, x, y|H_t) dx dy dt.</code>
</p>

<p>Then the procedure calculates the probability of being a background
event for each event in the catalog by
</p>
<p style="text-align: center;"><code class="reqn"> \phi_i = \frac{\mu(x_i, y_i)}{\lambda(t_i, x_i, y_i|H_{t_i})}. </code>
</p>

<p>Using these probabilities and kernel smoothing method with Gaussian kernel
and appropriate choice of bandwidth (determined by <code>bwd</code> or <code>nnp</code>
and <code>bwm</code> arguments), the background rate <code class="reqn">u_0(x, y)</code>
is updated. These steps are repeated until the estimates converge
(stabilize).
</p>
<p>The <code>no.itr</code> argument specifies the maximum number of iterations
in the iterative simultaneous estimation and declustering algorithm.
The estimates often converge in less than ten iterations. The relative
iteration convergence tolerance and the optimization
convergence tolerance are, respectively, determined by
<code>rel.tol</code> and <code>eps</code> arguments.
The progress of the computations can be traced by setting
the <code>verbose</code> and <code>plot.it</code> arguments to be <code>TRUE</code>.
</p>
<p>If <code>cxxcode = TRUE</code>, then the internal function <code>etasfit</code>
uses the C++ code implemented using the <span class="pkg">Rcpp</span> package,
which allows multi-thread parallel computing on multi-core processors
with OpenMP.
The argument <code>nthreads</code> in this case determines
the number of threads in the parallel region of the code.
If <code>nthreads = 1</code> (the default case), then a serial version of the
C++ code carries out the computations.
</p>
<p>This version of the ETAS model assumes that the earthquake catalog
is complete and the data are stationary in time. If the catalog
is incomplete or there is non-stationarity (e.g. increasing or cyclic
trend)  in the time of events, then the results of this function are
not reliable.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<dl>
<dt>param:</dt>
<dd>
<p>The ML estimates of model parameters.</p>
</dd>
<dt>bk:</dt>
<dd>
<p>An estimate of the <code class="reqn">u(x, y)</code>.</p>
</dd>
<dt>pb:</dt>
<dd>
<p>The probabilities of being background event.</p>
</dd>
<dt>opt:</dt>
<dd>
<p>The results of optimization: the value of the log-likelihood
function at the optimum point, its gradient at the optimum point and AIC of the model.</p>
</dd>
<dt>rates:</dt>
<dd>
<p>Pixel images of the estimated total intensity,
background intensity, clustering intensity and conditional intensity.</p>
</dd>
</dl>
<h3>Note</h3>

<p>This function is based on a <code>C</code> port of the original
<code>Fortran</code> code by Jiancang Zhuang, Yosihiko Ogata and
their colleagues. The <code>etas</code> function is intended to be
used for small and medium-size earthquake catalogs.
For large earthquake catalogs, due to time-consuming
computations, it is highly recommended to
use the parallel <code>Fortran</code> code on a server machine.
The <code>Fortran</code> code (implemented for
parallel/non-parallel computing) can be obtained from
<a href="http://bemlar.ism.ac.jp/zhuang/software.html">http://bemlar.ism.ac.jp/zhuang/software.html</a>.
</p>


<h3>Author(s)</h3>

<p>Abdollah Jalilian
<a href="mailto:jalilian@razi.ac.ir">jalilian@razi.ac.ir</a>
</p>


<h3>References</h3>

<p>Ogata Y (1988).
Statistical Models for Earthquake Occurrences and Residual Analysis for
Point Processes.
<em>Journal of the American Statistical Association</em>,
<b>83</b>(401), 9–27.
<a href="https://doi.org/10.2307/2288914">doi:10.2307/2288914</a>.
</p>
<p>Ogata Y (1998).
Space-time Point-process Models for Earthquake Occurrences.
<em>Annals of the Institute of Statistical Mathematics</em>,
<b>50</b>(2), 379–402.
<a href="https://doi.org/10.1023/a%3A1003403601725">doi:10.1023/a:1003403601725</a>.
</p>
<p>Zhuang J, Ogata Y, Vere-Jones D (2002).
Stochastic Declustering of Space-Time Earthquake Occurrences.
<em>Journal of the American Statistical Association</em>,
<b>97</b>(458), 369–380.
<a href="https://doi.org/10.1198/016214502760046925">doi:10.1198/016214502760046925</a>.
</p>
<p>Zhuang J, Ogata Y, Vere-Jones D (2006).
Diagnostic Analysis of Space-Time Branching Processes for Earthquakes.
In <em>Case Studies in Spatial Point Process Modeling</em>,
pp. 275–292. Springer Nature.
<a href="https://doi.org/10.1007/0-387-31144-0_15">doi:10.1007/0-387-31144-0_15</a>.
</p>
<p>Zhuang J (2011).
Next-day Earthquake Forecasts for the Japan Region Generated by
the ETAS Model.
<em>Earth, Planets and Space</em>,
<b>63</b>(3), 207–216.
<a href="https://doi.org/10.5047/eps.2010.12.010">doi:10.5047/eps.2010.12.010</a>.
</p>


<h3>See Also</h3>

<p><code>catalog</code> for constructing data.
<code>probs</code> for estimated declustering probabilities.
<code>resid.etas</code> for diagnostic plots.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # fitting the ETAS model to an Iranian catalog
  # preparing the catalog
  iran.cat &lt;- catalog(iran.quakes, time.begin="1973/01/01",
     study.start="1986/01/01", study.end="2016/01/01",
     lat.range=c(26, 40), long.range=c(44, 63), mag.threshold=5)
  print(iran.cat)
  ## Not run: 
  plot(iran.cat)
## End(Not run)

  # setting initial parameter values
  param0 &lt;- c(0.46, 0.23, 0.022, 2.8, 1.12, 0.012, 2.4, 0.35)

  # fitting the model
  ## Not run: 
  iran.fit &lt;- etas(iran.cat, param0=param0)
## End(Not run)


  # fitting the ETAS model to an Italian catalog
  # preparing the catalog
  italy.cat &lt;- catalog(italy.quakes, dist.unit="km")
  ## Not run: 
  plot(italy.cat)
## End(Not run)

  # setting initial parameter values
  mu &lt;- 1
  k0 &lt;- 0.005
  c &lt;- 0.005
  alpha &lt;- 1.05
  p &lt;- 1.01
  D &lt;- 1.1
  q &lt;- 1.52
  gamma &lt;- 0.6
  # reparametrization: transform k0 to A
  A &lt;- pi * k0 / ((p - 1) * c^(p - 1) * (q - 1) * D^(q - 1))
  param0 &lt;- c(mu, A, c, alpha, p, D, q, gamma)

  # fitting the model
  ## Not run: 
  nthreads &lt;- parallel::detectCores()
  italy.fit &lt;- etas(italy.cat, param0, nthreads=nthreads)
## End(Not run)


  # fitting the ETAS model to a Japanese catalog
  # setting the target polygonal study region
  jpoly &lt;- list(long=c(134.0, 137.9, 143.1, 144.9, 147.8,
      137.8, 137.4, 135.1, 130.6), lat=c(31.9, 33.0, 33.2,
      35.2, 41.3, 44.2, 40.2, 38.0, 35.4))
  # preparing the catalog
  japan.cat &lt;- catalog(japan.quakes, study.start="1953-05-26",
      study.end="1990-01-08", region.poly=jpoly, mag.threshold=4.5)
  ## Not run: 
  plot(japan.cat)
## End(Not run)

  # setting initial parameter values
  param0 &lt;- c(0.592844590, 0.204288231, 0.022692883, 1.495169224,
  1.109752319, 0.001175925, 1.860044210, 1.041549634)

  # fitting the model
  ## Not run: 
  nthreads &lt;- parallel::detectCores()
  japan.fit &lt;- etas(japan.cat, param0, nthreads=nthreads)
## End(Not run)
</code></pre>


</div>