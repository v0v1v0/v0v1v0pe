<div class="container">

<table style="width: 100%;"><tr>
<td>stark.test.Z</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Workhorse driver for stark.test</h2>

<h3>Description</h3>

<p>These main methods conduct the test of the election audit and returns a
p-value and other related info on that test.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stark.test.Z(
  Z,
  calc.e_p = calc.pairwise.e_p,
  w_p = weight.function("no.weight"),
  max_err = maximumMarginBound,
  bound.col = Z$tot.votes.col,
  strat.col = NULL,
  drop = NULL,
  strat.method = NULL,
  err.override = NULL,
  n = NULL,
  t = NULL,
  q = NULL
)

stark.test(
  votes,
  audits,
  C.names = NULL,
  f = 1,
  pool = TRUE,
  pairwise = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>The object holding all the voting information.  See below for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calc.e_p</code></td>
<td>
<p>The Function used to calculate maximum error bounds</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_p</code></td>
<td>
<p>The function used to calculate weights of error (A list of two
functions)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_err</code></td>
<td>
<p>Function to compute max error bounds for each precint</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound.col</code></td>
<td>
<p>Name (or column index) of column in the vote matrix
corresponding to maximum number of votes allowed in precinct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strat.col</code></td>
<td>
<p>Name of column that determines how to stratify if NULL will
not stratify</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Either a vector of TRUE/FALSE or a name of a column in Z\$V of
T/F values.  Precincts identified by drop will be dropped from calculations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strat.method</code></td>
<td>
<p>Not currently implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err.override</code></td>
<td>
<p>If non-null, use this as the found error in votes rather
than the actual errors found in the audit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Elements of the test statistic.  Can pass to avoid computation if
those values are already known (e.g., for a simulation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>Elements of the test statistic.  Can pass to avoid computation if
those values are already known (e.g., for a simulation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Elements of the test statistic.  Can pass to avoid computation if
those values are already known (e.g., for a simulation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>votes</code></td>
<td>
<p>data.frame of votes. Each row is precinct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>audits</code></td>
<td>
<p>data.frame of audits. Each row is precinct.  Table reports
overstatement by candidate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.names</code></td>
<td>
<p>Names of candidates (and names of cor columns in votes and
audits tables.  If NULL will derive from cols 2 on of votes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>The number of winners</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pool</code></td>
<td>
<p>If TRUE, combine small candidates into single pseudo-candidates
to increase power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairwise</code></td>
<td>
<p>if TRUE then do a pairwise test for all pairs and return
highest p-value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Extra arguments passed directly to the work-horse method
stark.test.Z</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It is an older method.  Most likely <code>CAST.audit</code> or
<code>trinomial.audit</code> should be used instead.
</p>
<p>stark.test() will do the entire test. It is basically a driver function that
sets up 'Z' matrix and passes buck to the stark.test.Z
</p>
<p>The Z object, in particular has: Z\$V: The table of reported votes Z\$audit:
The table of audits as differences from recorded votes
</p>


<h3>Value</h3>

<p>Return an htest object with pvalue, some relevant statistics, and
the Z object used (possibly constructed) that produced those results.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p>See <code>elec.data</code> for description of the main object.
See <code>find.q</code> and <code>compute.stark.t</code> for the main
components of this test.  <code>find.stark.SRS.p</code> is a utility
function for computing a p-value for a specific situation.  See
weight.function for functions used to weight audit errors.  See
MaximumBound for a bound on error that one might use for
these tests.  See <code>find.stratification</code> for a utility for
stratification.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## pretending that santa cruz audit was a SRS audit (which it was not)
data(santa.cruz)
Z = elec.data(santa.cruz, C.names=c("leopold","danner"))
data(santa.cruz.audit)
## do some work to get the audit totals to overstatements
rownames(santa.cruz.audit) = santa.cruz.audit$PID
Z$audit = audit.totals.to.OS(Z, santa.cruz.audit)
Z$audit
stark.test.Z(Z)


</code></pre>


</div>