<div class="container">

<table style="width: 100%;"><tr>
<td>errorLocation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The errorLocation object</h2>

<h3>Description</h3>

<p>Object storing information on error locations in a dataset.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'errorLocation'
plot(x, topn = min(10, ncol(x$adapt)), ...)

## S3 method for class 'errorLocation'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>errorLocation object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>topn</code></td>
<td>
<p>Number of variables to show in 'errors per variable plot'. Only the top-n are are shown. 
By default the top-20 variables with the most errors are shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments that will be transferred to <code>barplot</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an R object</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>errorlocation</code> objects consists of the following slots wich can be 
accessed with the dollar operator, just like with lists. Right now the only
functions creating such objects are <code>localizeErrors</code> and <code>checkDatamodel</code>.
</p>

<ul>
<li>
<p><code>adapt</code> a <code>logical</code> array where each row/column shows which record/variable should be adapted.
</p>
</li>
<li>
<p><code>status</code> A <code>data.frame</code> with the same number of rows as <code>adapt</code>. It contains the following
columns
</p>

<ul>
<li>
<p><code>weight</code> weight of the found solution
</p>
</li>
<li>
<p><code>degeneracy</code> number of equivalent solutions found
</p>
</li>
<li>
<p><code>user</code> user time used to generate solution (as in <code>sys.time</code>)
</p>
</li>
<li>
<p><code>system</code> system time used to generate solution (as in <code>sys.time</code>)
</p>
</li>
<li>
<p><code>elapsed</code> elapsed time used to generate solution (as in <code>sys.time</code>)
</p>
</li>
<li>
<p><code>maxDurationExceeded</code> Was the maximum search time reached?
</p>
</li>
<li>
<p><code>memfail</code> Indicates whether a branch was broken off due to memory allocation failure (branch and bound only)
</p>
</li>
</ul>
</li>
<li>
<p><code>method</code> The error localization method used, can be "mip", "localizer" or "checkDatamodel".
</p>
</li>
<li>
<p><code>call</code> The R calls to the function generating the object.
</p>
</li>
<li>
<p><code>user</code> <code>character</code> user who generated the object.
</p>
</li>
<li>
<p><code>timestamp</code> <code>character</code> timestamp.
</p>
</li>
</ul>
<p>It is possible to <code>plot</code> objects of class <code>errorLocation</code>. An overview containing
three or four graphs will be plotted in a new window. Axes in scatterplots are set to logarithmic
if their scales maxima exceed 50.
</p>


<h3>See Also</h3>

<p><code>localizeErrors</code>, <code>checkDatamodel</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# an editmatrix and some data:
E &lt;- editmatrix(c(
    "x + y == z",
    "x &gt; 0",
    "y &gt; 0",
    "z &gt; 0"))

dat &lt;- data.frame(
    x = c(1,-1,1),
    y = c(-1,1,1),
    z = c(2,0,2))

# localize all errors in the data
err &lt;- localizeErrors(E,dat)

summary(err)

# what has to be adapted:
err$adapt
# weight, number of equivalent solutions, timings,
err$status


## Not run

# Demonstration of verbose processing
# construct 2-block editmatrix
F &lt;- editmatrix(c(
    "x + y == z",
    "x &gt; 0",
    "y &gt; 0",
    "z &gt; 0",
    "w &gt; 10"))
# Using 'dat' as defined above, generate some extra records
dd &lt;- dat
for ( i in 1:5 ) dd &lt;- rbind(dd,dd)
dd$w &lt;- sample(12,nrow(dd),replace=TRUE)

# localize errors verbosely
(err &lt;- localizeErrors(F,dd,verbose=TRUE))

# printing is cut off, use summary for an overview
summary(err)

# or plot (not very informative in this artificial example)
plot(err)

## End(Not run)

for ( d in dir("../pkg/R",full.names=TRUE)) dmp &lt;- source(d)
# Example with different weights for each record
E &lt;- editmatrix('x + y == z')
dat &lt;- data.frame(
    x = c(1,1),
    y = c(1,1),
    z = c(1,1))

# At equal weights, both records have three solutions (degeneracy): adapt x, y
# or z:
localizeErrors(E,dat)$status

# Set different weights per record (lower weight means lower reliability):
w &lt;- matrix(c(
    1,2,2,
    2,2,1),nrow=2,byrow=TRUE)

localizeErrors(E,dat,weight=w)


# an example with categorical variables
E &lt;- editarray(expression(
    age %in% c('under aged','adult'),
    maritalStatus %in% c('unmarried','married','widowed','divorced'),
    positionInHousehold %in% c('marriage partner', 'child', 'other'),
    if( age == 'under aged' ) maritalStatus == 'unmarried',
    if( maritalStatus %in% c('married','widowed','divorced')) 
      !positionInHousehold %in% c('marriage partner','child')
    )
)
E

#
dat &lt;- data.frame(
    age = c('under aged','adult','adult' ),
    maritalStatus=c('married','unmarried','widowed' ), 
    positionInHousehold=c('child','other','marriage partner')
)
dat
localizeErrors(E,dat)
# the last record of dat has 2 degenerate solutions. Running  the last command
# a few times demonstrates that one of those solutions is chosen at random.

# Increasing the weight of  'positionInHousehold' for example, makes the best
# solution unique again
localizeErrors(E,dat,weight=c(1,1,2))


# an example with mixed data:

E &lt;- editset(expression(
    x + y == z,
    2*u  + 0.5*v == 3*w,
    w &gt;= 0,
    if ( x &gt; 0 ) y &gt; 0,
    x &gt;= 0,
    y &gt;= 0,
    z &gt;= 0,
    A %in% letters[1:4],
    B %in% letters[1:4],
    C %in% c(TRUE,FALSE),
    D %in% letters[5:8],
    if ( A %in% c('a','b') ) y &gt; 0,
    if ( A == 'c' ) B %in% letters[1:3],
    if ( !C == TRUE) D %in% c('e','f')
))

set.seed(1)
dat &lt;- data.frame(
    x = sample(-1:8),
    y = sample(-1:8),
    z = sample(10),
    u = sample(-1:8),
    v = sample(-1:8),
    w = sample(10),
    A = sample(letters[1:4],10,replace=TRUE),
    B = sample(letters[1:4],10,replace=TRUE),
    C = sample(c(TRUE,FALSE),10,replace=TRUE),
    D = sample(letters[5:9],10,replace=TRUE),
    stringsAsFactors=FALSE
)

(el &lt;-localizeErrors(E,dat,verbose=TRUE))





</code></pre>


</div>