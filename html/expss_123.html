<div class="container">

<table style="width: 100%;"><tr>
<td>criteria</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Criteria functions</h2>

<h3>Description</h3>

<p>Produce criteria which could be used in the different situations - see
'recode', 'na_if', 'count_if', 'match_row',
'%i%' and etc. For example, <code>'greater(5)'</code> returns function
which tests whether its argument greater than five. <code>'fixed("apple")'</code>
returns function which tests whether its argument contains "apple". For
criteria logical operations (|, &amp;, !, xor) are defined, e. g. you can write
something like: <code>'greater(5) | equals(1)'</code>.
List of functions:
</p>

<ul>
<li>
<p>comparison criteria - <code>'equals'</code>, <code>'greater'</code> and etc. return
functions which compare its argument against value.
</p>
</li>
<li>
<p><code>'thru'</code> checks whether a value is inside interval.
<code>'thru(0,1)'</code> is equivalent to <code>'x&gt;=0 &amp; x&lt;=1'</code>
</p>
</li>
<li>
<p><code>'%thru%'</code> is infix version of <code>'thru'</code>, e. g. <code>'0
%thru% 1'</code>
</p>
</li>
<li>
<p><code>'is_max'</code> and <code>'is_min'</code> return TRUE where vector value is
equals to maximum or minimum.
</p>
</li>
<li>
<p><code>'contains'</code> searches for the pattern in the strings. By default,
it works with fixed patterns rather than regular expressions. For details
about its arguments see grepl
</p>
</li>
<li>
<p><code>'like'</code> searches for the Excel-style pattern in the strings. You
can use wildcards: '*' means any number of symbols, '?' means single symbol.
Case insensitive.
</p>
</li>
<li>
<p><code>'fixed'</code> alias for contains.
</p>
</li>
<li>
<p><code>'perl'</code> such as <code>'contains'</code> but the pattern is perl-compatible
regular expression (<code>'perl = TRUE'</code>). For details see grepl
</p>
</li>
<li>
<p><code>'regex'</code> use POSIX 1003.2 extended regular expressions
(<code>'fixed = FALSE'</code>). For details see grepl
</p>
</li>
<li>
<p><code>'has_label'</code> searches values which have supplied label(-s).  We
can used criteria as an argument for 'has_label'.
</p>
</li>
<li>
<p><code>'to'</code> returns function which gives TRUE for all elements of
vector before the first occurrence of <code>'x'</code> and for  <code>'x'</code>.
</p>
</li>
<li>
<p><code>'from'</code> returns function which gives TRUE for all elements of 
vector after the first occurrence of <code>'x'</code> and for <code>'x'</code>.
</p>
</li>
<li>
<p><code>'not_na'</code> returns TRUE for all non-NA vector elements. 
</p>
</li>
<li>
<p><code>'other'</code> returns TRUE for all vector elements. It is intended
for usage with <code>'recode'</code>.
</p>
</li>
<li>
<p><code>'items'</code> returns TRUE for the vector elements with the given
sequential numbers.
</p>
</li>
<li>
<p><code>'and'</code>, <code>'or'</code>, <code>'not'</code> are spreadsheet-style boolean functions.
</p>
</li>
</ul>
<p>Shortcuts for comparison criteria:
</p>

<ul>
<li>
<p>'equals' - <code>'eq'</code>
</p>
</li>
<li>
<p>'not_equals' - <code>'neq'</code>, <code>'ne'</code>
</p>
</li>
<li>
<p>'greater' - <code>'gt'</code>
</p>
</li>
<li>
<p>'greater_or_equal' - <code>'gte'</code>, <code>'ge'</code>
</p>
</li>
<li>
<p>'less' - <code>'lt'</code>
</p>
</li>
<li>
<p>'less_or_equal' - <code>'lte'</code>, <code>'le'</code>
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">as.criterion(crit)

is.criterion(x)

equals(x)

not_equals(x)

less(x)

less_or_equal(x)

greater(x)

greater_or_equal(x)

thru(lower, upper)

lower %thru% upper

when(x)

is_max(x)

is_min(x)

contains(
  pattern,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = TRUE,
  useBytes = FALSE
)

like(pattern)

fixed(
  pattern,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = TRUE,
  useBytes = FALSE
)

perl(
  pattern,
  ignore.case = FALSE,
  perl = TRUE,
  fixed = FALSE,
  useBytes = FALSE
)

regex(
  pattern,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)

has_label(x)

from(x)

to(x)

items(...)

not_na(x)

is_na(x)

other(x)

and(...)

or(...)

not(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>vector of values/function which returns logical or logical vector. It will be
converted to function of class criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>vector/single value - lower bound of interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>vector/single value - upper bound of interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>character string containing a regular expression (or character
string for <code>'fixed'</code>) to be matched in the given character vector.
Coerced by as.character to a character string if possible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>
<p>logical see grepl</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perl</code></td>
<td>
<p>logical see grepl</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>logical see grepl</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useBytes</code></td>
<td>
<p>logical see grepl</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>numeric indexes of desired items for items, logical vectors or criteria for boolean functions.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>function of class 'criterion' which tests its argument against
condition and return logical value
</p>


<h3>See Also</h3>

<p>recode, count_if,
match_row, na_if, %i%
</p>


<h3>Examples</h3>

<pre><code class="language-R"># operations on vector, '%d%' means 'diff'
1:6 %d% greater(4) # 1:4
1:6 %d% (1 | greater(4)) # 2:4
# '%i%' means 'intersect
1:6 %i% (is_min() | is_max()) # 1, 6
# with Excel-style boolean operators
1:6 %i% or(is_min(), is_max()) # 1, 6

letters %i% (contains("a") | contains("z")) # a, z

letters %i% perl("a|z") # a, z

letters %i% from("w")  # w, x, y, z

letters %i% to("c")  # a, b, c

letters %i% (from("b") &amp; to("e"))  # b, d, e

c(1, 2, NA, 3) %i% not_na() # c(1, 2, 3)

# examples with count_if
df1 = data.frame(
    a=c("apples", "oranges", "peaches", "apples"),
    b = c(32, 54, 75, 86)
)

count_if(greater(55), df1$b) # greater than 55 = 2

count_if(not_equals(75), df1$b) # not equals 75 = 3

count_if(greater(32) &amp; less(86), df1$b) # greater than 32 and less than 86 = 2
count_if(and(greater(32), less(86)), df1$b) # the same result

# infix version
count_if(35 %thru% 80, df1$b) # greater than or equals to 35 and less than or equals to 80 = 2

# values that started on 'a'
count_if(like("a*"), df1) # 2

# the same with Perl-style regular expression
count_if(perl("^a"), df1) # 2

# count_row_if
count_row_if(perl("^a"), df1) # c(1,0,0,1)

# examples with 'n_intersect' and 'n_diff'
data(iris)
iris %&gt;% n_intersect(to("Petal.Width")) # all columns up to 'Species' 
 
# 'Sepal.Length', 'Sepal.Width' will be left 
iris %&gt;% n_diff(from("Petal.Length"))

# except first column
iris %n_d% items(1)

# 'recode' examples
qvar = c(1:20, 97, NA, NA)
recode(qvar, 1 %thru% 5 ~ 1, 6 %thru% 10 ~ 2, 11 %thru% hi ~ 3, other ~ 0)
# the same result
recode(qvar, 1 %thru% 5 ~ 1, 6 %thru% 10 ~ 2, greater_or_equal(11) ~ 3, other ~ 0)


</code></pre>


</div>