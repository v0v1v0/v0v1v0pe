<div class="container">

<table style="width: 100%;"><tr>
<td>control.san</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Auxiliary for Controlling SAN</h2>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning simulated annealing
algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">control.san(
  SAN.maxit = 4,
  SAN.tau = 1,
  SAN.invcov = NULL,
  SAN.invcov.diag = FALSE,
  SAN.nsteps.alloc = function(nsim) 2^seq_len(nsim),
  SAN.nsteps = 2^19,
  SAN.samplesize = 2^12,
  SAN.prop = trim_env(~sparse + .triadic),
  SAN.prop.weights = "default",
  SAN.prop.args = list(),
  SAN.packagenames = c(),
  SAN.ignore.finite.offsets = TRUE,
  term.options = list(),
  seed = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>SAN.maxit</code></td>
<td>
<p>Number of temperature levels to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.tau</code></td>
<td>
<p>Tuning parameter, specifying the temperature of the
process during the <em>penultimate</em> iteration. (During the last
iteration, the temperature is set to 0, resulting in a greedy
search, and during the previous iterations, the temperature is
set to <code style="white-space: pre;">⁠SAN.tau*(iterations left after this one)⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.invcov</code></td>
<td>
<p>Initial inverse covariance matrix used to
calculate Mahalanobis distance in determining how far a proposed
MCMC move is from the <code>target.stats</code> vector.  If <code>NULL</code>,
initially set to the identity matrix. In either case, during
subsequent runs, it is estimated empirically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.invcov.diag</code></td>
<td>
<p>Whether to only use the diagonal of the
covariance matrix. It seems to work better in practice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.nsteps.alloc</code></td>
<td>
<p>Either a numeric vector or a function of
the number of runs giving a sequence of relative lengths of
simulated annealing runs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.nsteps</code></td>
<td>
<p>Number of MCMC proposals for all the annealing runs combined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.samplesize</code></td>
<td>
<p>Number of realisations' statistics to obtain for tuning purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.prop</code></td>
<td>
<p>Specifies the proposal (directly) and/or
a series of "hints" about the structure of the model being
sampled. The specification is in the form of a one-sided formula
with hints separated by <code>+</code> operations. If the LHS exists and is
a string, the proposal to be used is selected directly.
</p>
<p>A common and default "hint" is <code>~sparse</code>, indicating
that the network is sparse and that the sample should put roughly
equal weight on selecting a dyad with or without a tie as a
candidate for toggling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.prop.weights</code></td>
<td>
<p>Specifies the proposal
distribution used in the SAN Metropolis-Hastings algorithm.  Possible
choices depending on selected <code>reference</code> and <code>constraints</code>
arguments of the <code>ergm()</code> function, but often include <code>"TNT"</code>
and <code>"random"</code>, and the <code>"default"</code> is to use the one with the
highest priority available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.prop.args</code></td>
<td>
<p>An alternative, direct way of
specifying additional arguments to proposal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAN.ignore.finite.offsets</code></td>
<td>
<p>Whether SAN should ignore (treat as 0) finite offsets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code>? term.options</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code>set.seed()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Number of threads in which to run the sampling. Defaults to
0 (no parallelism). See the entry on parallel processing
for details and troubleshooting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.type</code></td>
<td>
<p>API to use for parallel processing. Supported values
are <code>"MPI"</code> and <code>"PSOCK"</code>. Defaults to using the <code>parallel</code>
package with PSOCK clusters. See <code>ergm-parallel</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.version.check</code></td>
<td>
<p>Logical: If TRUE, check that the version of
<span class="pkg">ergm</span> running on the slave nodes is the same as
that running on the master node.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.inherit.MT</code></td>
<td>
<p>Logical: If TRUE, slave nodes and
processes inherit the <code>set.MT_terms()</code> setting.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is only used within a call to the <code>san()</code> function.
See the Usage section in <code>san()</code> for details.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>See Also</h3>

<p><code>san()</code>
</p>


</div>