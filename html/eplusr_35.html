<div class="container">

<table style="width: 100%;"><tr>
<td>expand_idf_dots_literal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parse object values given in literal character vectors or data.frames</h2>

<h3>Description</h3>

<p>Parse object values given in literal character vectors or data.frames
</p>


<h3>Usage</h3>

<pre><code class="language-R">expand_idf_dots_literal(idd_env, idf_env, ..., .default = TRUE, .exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Character vectors or data.frames.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.default</code></td>
<td>
<p>If <code>TRUE</code>, all empty fields will be filled with default
values if possible. Default: <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.exact</code></td>
<td>
<p>If <code>TRUE</code>, all inputs should match existing objects in the
Idf. In this case, <code>id</code> column is require for data.frame input.
Default: <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For object definitions in character vector format, they follow the
same rules as a normal IDF file:
</p>

<ul>
<li>
<p> Each object starts with a class name and a comma (<code style="white-space: pre;">⁠,⁠</code>);
</p>
</li>
<li>
<p> Separates each values with a comma (<code style="white-space: pre;">⁠,⁠</code>);
</p>
</li>
<li>
<p> Ends an object with a semicolon (<code style="white-space: pre;">⁠;⁠</code>) for the last value.
</p>
</li>
</ul>
<p>Each character vector can contain:
</p>

<ul>
<li>
<p> One single object, e.g. <code>c("Building,", "MyBuilding;")</code>, or "Building, MyBuilding;".
</p>
</li>
<li>
<p> Multiple objects, e.g. <code>c("Building, MyBuilding;", "SimulationControl, Yes")</code>.
</p>
</li>
</ul>
<p>You can also provide an option header to indicate if input objects are
presented in IP units, using <code style="white-space: pre;">⁠!-Option ViewInIPunits⁠</code>. If this header does
not exist, then all values are treated as in SI units.
</p>
<p>For object definitions in data.frame format, a valid definition requires at
least three columns described below. Note that column order does not matter.
</p>

<ul>
<li> <p><code>class</code>:Character type. Valid class names in the underlying
Idd object.
</p>
</li>
<li> <p><code>index</code>:Integer type. Valid field indices for each class.
</p>
</li>
<li> <p><code>value</code>:Character type or list type. Value for each field
to be added.
</p>

<ul>
<li>
<p> If character type, each value should be given as a string even if the
corresponding field is a numeric type.
</p>
</li>
<li>
<p> If list type, each value should have the right type as the corresponding
field definition.
</p>
</li>
</ul>
</li>
<li> <p><code>id</code>: <strong>Optional</strong> when <code>.exact</code> is <code>FALSE</code>. Integer type.
If input data.frame includes multiple object definitions in a same class,
values in <code>id</code> column will be used to distinguish each definition. If <code>id</code>
column does not exists, it assumes that each definition is separated by
<code>class</code> column and will issue an error if there is any duplication in the
<code>index</code> column.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A named list of 2 element <code>object</code> and <code>value</code> which is a
<code>data.table::data.table()</code> with object data and value data respectively.
</p>


<h3>Note</h3>

<p>Objects from character vectors will always be at the top of each table.
</p>


</div>