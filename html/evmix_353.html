<div class="container">

<table style="width: 100%;"><tr>
<td>itmgng</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Normal Bulk with GPD Upper and Lower Tails Interval Transition Mixture Model</h2>

<h3>Description</h3>

<p>Density, cumulative distribution function, quantile function and
random number generation for the extreme value mixture model with normal
for bulk distribution between the upper and lower thresholds with
conditional GPD's for the two tails and interval transition. The parameters are the normal mean
<code>nmean</code> and standard deviation <code>nsd</code>, interval half-width <code>espilon</code>,
lower tail (threshold <code>ul</code>, GPD scale <code>sigmaul</code> and shape <code>xil</code> and
tail fraction <code>phiul</code>) and upper tail (threshold <code>ur</code>, GPD scale
<code>sigmaur</code> and shape <code>xiR</code> and tail fraction <code>phiuR</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">ditmgng(x, nmean = 0, nsd = 1, epsilon = nsd, ul = qnorm(0.1,
  nmean, nsd), sigmaul = nsd, xil = 0, ur = qnorm(0.9, nmean, nsd),
  sigmaur = nsd, xir = 0, log = FALSE)

pitmgng(q, nmean = 0, nsd = 1, epsilon = nsd, ul = qnorm(0.1,
  nmean, nsd), sigmaul = nsd, xil = 0, ur = qnorm(0.9, nmean, nsd),
  sigmaur = nsd, xir = 0, lower.tail = TRUE)

qitmgng(p, nmean = 0, nsd = 1, epsilon, ul = qnorm(0.1, nmean, nsd),
  sigmaul = nsd, xil = 0, ur = qnorm(0.9, nmean, nsd),
  sigmaur = nsd, xir = 0, lower.tail = TRUE)

ritmgng(n = 1, nmean = 0, nsd = 1, epsilon = sd, ul = qnorm(0.1,
  nmean, nsd), sigmaul = nsd, xil = 0, ur = qnorm(0.9, nmean, nsd),
  sigmaur = nsd, xir = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>quantiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmean</code></td>
<td>
<p>normal mean</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsd</code></td>
<td>
<p>normal standard deviation (positive)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>interval half-width</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ul</code></td>
<td>
<p>lower tail threshold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmaul</code></td>
<td>
<p>lower tail GPD scale parameter (positive)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xil</code></td>
<td>
<p>lower tail GPD shape parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ur</code></td>
<td>
<p>upper tail threshold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmaur</code></td>
<td>
<p>upper tail GPD scale parameter (positive)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xir</code></td>
<td>
<p>upper tail GPD shape parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical, if TRUE then log density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>quantiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>logical, if FALSE then upper tail probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>cumulative probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size (positive integer)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The interval transition extreme value mixture model combines a normal
distribution for the bulk between the lower and upper thresholds and GPD for
upper and lower tails, with a smooth transition over the interval 
<code class="reqn">(u-epsilon, u+epsilon)</code> (where <code class="reqn">u</code> can be exchanged for the lower and
upper thresholds). The mixing function warps the normal to map from 
<code class="reqn">(u-epsilon, u)</code> to <code class="reqn">(u-epsilon, u+epsilon)</code> and warps the GPD from 
<code class="reqn">(u, u+epsilon)</code> to <code class="reqn">(u-epsilon, u+epsilon)</code>.
</p>
<p>The cumulative distribution function is defined by 
</p>
<p style="text-align: center;"><code class="reqn">F(x)=\kappa(G_l(q(x)) + H_t(r(x)) + G_u(p(x)))</code>
</p>

<p>where <code class="reqn">H_t(x)</code> is the truncated normal cdf, i.e. <code>pnorm(x, nmean, nsd)</code>.
The conditional GPD for the upper tail has cdf <code class="reqn">G_u(x)</code>, 
i.e. <code>pgpd(x, ur, sigmaur, xir)</code> and lower tail cdf <code class="reqn">G_l(x)</code> is for the 
negated support, i.e. <code>1 - pgpd(-x, -ul, sigmaul, xil)</code>. The truncated 
normal is not renormalised to be proper, so <code class="reqn">H_t(x)</code> contributes
<code>pnorm(ur, nmean, nsd) - pnorm(ul, nmean, nsd)</code> to the cdf
for all <code class="reqn">x\geq (u_r + \epsilon)</code> and zero below <code class="reqn">x\leq (u_l - \epsilon)</code>.
The normalisation constant <code class="reqn">\kappa</code> ensures a proper density, given by 
<code>1/(2 + pnorm(ur, nmean, nsd) - pnorm(ul, nmean, nsd)</code> where the
2 is from two GPD components and latter is contribution from normal component.
</p>
<p>The mixing functions <code class="reqn">q(x)</code>, <code class="reqn">r(x)</code> and <code class="reqn">p(x)</code> are reformulated from the 
<code class="reqn">q_i(x)</code> suggested by Holden and Haug (2013). These are symmetric about each
threshold, which for convenience will be referred to a simply <code class="reqn">u</code>. So for
computational convenience only a single <code class="reqn">q(x;u)</code> has been implemented for the
lower and upper GPD components called
<code>qmix</code> for a given <code class="reqn">u</code>, with the complementary
mixing function then defined as <code class="reqn">p(x;u)=-q(-x;-u)</code>. The bulk model mixing
function <code class="reqn">r(x)</code> utilises the equivalent of the <code class="reqn">q(x)</code> for the lower threshold and
<code class="reqn">p(x)</code> for the upper threshold, so these are reused in the bulk mixing function  
<code>qgbgmix</code>.
</p>
<p>A minor adaptation of the mixing function has been applied following a similar
approach to that explained in <code>ditmnormgpd</code>. For the
bulk model mixing function <code class="reqn">r(x)</code>, we need <code class="reqn">r(x)&lt;=ul</code> for all <code class="reqn">x\le ul - epsilon</code> and 
<code class="reqn">r(x)&gt;=ur</code> for all <code class="reqn">x\ge ur+epsilon</code>, as then the bulk model will contribute
zero below the lower interval and the constant <code class="reqn">H_t(ur)=H(ur)-H(ul)</code> for all
<code class="reqn">x</code> above the upper interval. Holden and Haug (2013) define
<code class="reqn">r(x)=x-\epsilon</code> for all <code class="reqn">x\ge ur</code> and <code class="reqn">r(x)=x+\epsilon</code> for all <code class="reqn">x\le ul</code>.
For more straightforward and interpretable 
computational implementation the mixing function has been set to the lower threshold
<code class="reqn">r(x)=u_l</code> for all <code class="reqn">x\le u_l-\epsilon</code> and to the upper threshold
<code class="reqn">r(x)=u_r</code> for all <code class="reqn">x\le u_r+\epsilon</code>, so the cdf/pdf of the normal model can be used
directly. We do not have to define cdf/pdf for the non-proper truncated normal
seperately. As such <code class="reqn">r'(x)=0</code> for all <code class="reqn">x\le u_l-\epsilon</code> and <code class="reqn">x\ge u_r+\epsilon</code> in
<code>qmixxprime</code>, which also makes it clearer that
normal does not contribute to either tails beyond the intervals and vice-versa. 
</p>
<p>The quantile function within the transition interval is not available in
closed form, so has to be solved numerically. Outside of the
interval, the quantile are obtained from the normal and GPD components directly.
</p>


<h3>Value</h3>

<p><code>ditmgng</code> gives the density, 
<code>pitmgng</code> gives the cumulative distribution function,
<code>qitmgng</code> gives the quantile function and 
<code>ritmgng</code> gives a random sample.
</p>


<h3>Note</h3>

<p>All inputs are vectorised except <code>log</code> and <code>lower.tail</code>.
The main input (<code>x</code>, <code>p</code> or <code>q</code>) and parameters must be either
a scalar or a vector. If vectors are provided they must all be of the same length,
and the function will be evaluated for each element of vector. In the case of 
<code>ritmgng</code> any input vector must be of length <code>n</code>.
</p>
<p>Default values are provided for all inputs, except for the fundamentals 
<code>x</code>, <code>q</code> and <code>p</code>. The default sample size for 
<code>ritmgng</code> is 1.
</p>
<p>Missing (<code>NA</code>) and Not-a-Number (<code>NaN</code>) values in <code>x</code>,
<code>p</code> and <code>q</code> are passed through as is and infinite values are set to
<code>NA</code>. None of these are not permitted for the parameters.
</p>
<p>Error checking of the inputs (e.g. invalid probabilities) is carried out and
will either stop or give warning message as appropriate.
</p>


<h3>Author(s)</h3>

<p>Alfadino Akbar and Carl Scarrott <a href="mailto:carl.scarrott@canterbury.ac.nz">carl.scarrott@canterbury.ac.nz</a>
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Normal_distribution">http://en.wikipedia.org/wiki/Normal_distribution</a>
</p>
<p><a href="http://en.wikipedia.org/wiki/Generalized_Pareto_distribution">http://en.wikipedia.org/wiki/Generalized_Pareto_distribution</a>
</p>
<p>Scarrott, C.J. and MacDonald, A. (2012). A review of extreme value
threshold estimation and uncertainty quantification. REVSTAT - Statistical
Journal 10(1), 33-59. Available from <a href="http://www.ine.pt/revstat/pdf/rs120102.pdf">http://www.ine.pt/revstat/pdf/rs120102.pdf</a>
</p>
<p>Holden, L. and Haug, O. (2013). A mixture model for unsupervised tail
estimation. arxiv:0902.4137
</p>


<h3>See Also</h3>

<p><code>gng</code>, <code>normgpd</code>,
<code>gpd</code> and <code>dnorm</code>
</p>
<p>Other itmgng: <code>fitmgng</code>
</p>
<p>Other gng: <code>fgngcon</code>, <code>fgng</code>,
<code>fitmgng</code>, <code>fnormgpd</code>,
<code>gngcon</code>, <code>gng</code>,
<code>normgpd</code>
</p>
<p>Other itmnormgpd: <code>fitmgng</code>,
<code>fitmnormgpd</code>, <code>itmnormgpd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
set.seed(1)
par(mfrow = c(2, 2))

xx = seq(-5, 5, 0.01)
ul = -1.5;ur = 2
epsilon = 0.8
kappa = 1/(2 + pnorm(ur, 0, 1) - pnorm(ul, 0, 1))

f = ditmgng(xx, nmean = 0, nsd = 1, epsilon, ul, sigmaul = 1, xil = 0.5, ur, sigmaur = 1, xir = 0.5)
plot(xx, f, ylim = c(0, 0.5), xlim = c(-5, 5), type = 'l', lwd = 2, xlab = "x", ylab = "density")
lines(xx, kappa * dgpd(-xx, -ul, sigmau = 1, xi = 0.5), col = "blue", lty = 2, lwd = 2)
lines(xx, kappa * dnorm(xx, 0, 1), col = "red", lty = 2, lwd = 2)
lines(xx, kappa * dgpd(xx, ur, sigmau = 1, xi = 0.5), col = "green", lty = 2, lwd = 2)
abline(v = ul + epsilon * seq(-1, 1), lty = c(2, 1, 2), col = "blue")
abline(v = ur + epsilon * seq(-1, 1), lty = c(2, 1, 2), col = "green")
legend('topright', c('Normal-GPD ITM', 'kappa*GPD Lower', 'kappa*Normal', 'kappa*GPD Upper'),
      col = c("black", "blue", "red", "green"), lty = c(1, 2, 2, 2), lwd = 2)

# cdf contributions
F = pitmgng(xx, nmean = 0, nsd = 1, epsilon, ul, sigmaul = 1, xil = 0.5, ur, sigmaur = 1, xir = 0.5)
plot(xx, F, ylim = c(0, 1), xlim = c(-5, 5), type = 'l', lwd = 2, xlab = "x", ylab = "cdf")
lines(xx[xx &lt; ul], kappa * (1 - pgpd(-xx[xx &lt; ul], -ul, 1, 0.5)), col = "blue", lty = 2, lwd = 2)
lines(xx[(xx &gt;= ul) &amp; (xx &lt;= ur)], kappa * (1 + pnorm(xx[(xx &gt;= ul) &amp; (xx &lt;= ur)], 0, 1) -
      pnorm(ul, 0, 1)), col = "red", lty = 2, lwd = 2)
lines(xx[xx &gt; ur], kappa * (1 + (pnorm(ur, 0, 1) - pnorm(ul, 0, 1)) +
      pgpd(xx[xx &gt; ur], ur, sigmau = 1, xi = 0.5)), col = "green", lty = 2, lwd = 2)
abline(v = ul + epsilon * seq(-1, 1), lty = c(2, 1, 2), col = "blue")
abline(v = ur + epsilon * seq(-1, 1), lty = c(2, 1, 2), col = "green")
legend('topleft', c('Normal-GPD ITM', 'kappa*GPD Lower', 'kappa*Normal', 'kappa*GPD Upper'),
      col = c("black", "blue", "red", "green"), lty = c(1, 2, 2, 2), lwd = 2)

# simulated data density histogram and overlay true density 
x = ritmgng(10000, nmean = 0, nsd = 1, epsilon, ul, sigmaul = 1, xil = 0.5,
                                                ur, sigmaur = 1, xir = 0.5)
hist(x, freq = FALSE, breaks = seq(-1000, 1000, 0.1), xlim = c(-5, 5))
lines(xx, ditmgng(xx, nmean = 0, nsd = 1, epsilon, ul, sigmaul = 1, xil = 0.5,
  ur, sigmaur = 1, xir = 0.5), lwd = 2, col = 'black')

## End(Not run)

</code></pre>


</div>