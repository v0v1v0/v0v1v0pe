<div class="container">

<table style="width: 100%;"><tr>
<td>plotPredIntNparSimultaneousTestPowerCurve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Power Curves for Sampling Design for Test Based on Nonparametric Simultaneous Prediction Interval
</h2>

<h3>Description</h3>

<p>Plot power vs. <code class="reqn">\Delta/\sigma</code> (scaled minimal detectable difference) for a 
sampling design for a test based on a nonparametric simultaneous prediction 
interval.  The power is based on assuming the true distribution of the 
observations is normal.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  plotPredIntNparSimultaneousTestPowerCurve(n = 8, n.median = 1, k = 1, m = 2, 
    r = 1, rule = "k.of.m", lpl.rank = ifelse(pi.type == "upper", 0, 1), 
    n.plus.one.minus.upl.rank = ifelse(pi.type == "lower", 0, 1), pi.type = "upper", 
    r.shifted = r, integrate.args.list = NULL, method = "approx", NMC = 100, 
    range.delta.over.sigma = c(0, 5), plot.it = TRUE, add = FALSE, n.points = 20, 
    plot.col = "black", plot.lwd = 3 * par("cex"), plot.lty = 1, 
    digits = .Options$digits, cex.main = par("cex"), ..., main = NULL, 
    xlab = NULL, ylab = NULL, type = "l") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>positive integer specifying the sample sizes. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.median</code></td>
<td>

<p>positive odd integer specifying the sample size associated with the 
future medians.  The default value is <code>n.median=1</code> (i.e., individual 
observations).  Note that all future medians must be based on the same 
sample size.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>for the <code class="reqn">k</code>-of-<code class="reqn">m</code> rule (<code>rule="k.of.m"</code>), a positive integer 
specifying the minimum number of observations (or medians) out of <code class="reqn">m</code> 
observations (or medians) (all obtained on one future sampling “occassion”) 
the prediction interval should contain.  
The default value is <code>k=1</code>.  This argument is ignored when the argument 
<code>rule</code> is not equal to <code>"k.of.m"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>

<p>positive integer specifying the maximum number of future observations (or 
medians) on one future sampling “occasion”.  
The default value is <code>m=2</code>, except when <code>rule="Modified.CA"</code>, in which 
case this argument is ignored and <code>m</code> is automatically set equal to <code>4</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>

<p>positive integer specifying the number of future sampling 
“occasions”.  The default value is <code>r=1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>

<p>character string specifying which rule to use.  The possible values are 
<code>"k.of.m"</code> (<code class="reqn">k</code>-of-<code class="reqn">m</code> rule; the default), <code>"CA"</code> (California rule), 
and <code>"Modified.CA"</code> (modified California rule).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpl.rank</code></td>
<td>

<p>non-negative integer indicating the rank of the order statistic to use for 
the lower bound of the prediction interval.  When <code>pi.type="lower"</code>, the 
default value is <code>lpl.rank=1</code> (implying the minimum value of <code>x</code> is used 
as the lower bound of the prediction interval).  When <code>pi.type="upper"</code>, 
the argument <code>lpl.rank</code> is set equal to <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.plus.one.minus.upl.rank</code></td>
<td>

<p>non-negative integer related to the rank of the order statistic to use for 
the upper 
bound of the prediction interval.  A value of <code>n.plus.one.minus.upl.rank=1</code> 
means use the first largest value, and in general a value of <br><code>n.plus.one.minus.upl.rank=</code><code class="reqn">i</code> means use the <code class="reqn">i</code>'th largest value. 
When <br><code>pi.type="upper"</code>, the default value is <code>n.plus.one.minus.upl.rank=1</code>. 
When <code>pi.type="lower"</code>, the argument <code>n.plus.one.minus.upl.rank</code> is set 
equal to <code>0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi.type</code></td>
<td>

<p>character string indicating what kind of prediction interval to compute.  
The possible values are <code>"two.sided"</code> (the default), <code>"lower"</code>, and 
<code>"upper"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r.shifted</code></td>
<td>

<p>integer between <code>1</code> and <code>r</code> specifying the number of future sampling 
occasions for which the scaled mean is shifted by <code class="reqn">\Delta/\sigma</code>.  
The default value is <code>r.shifted=r</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integrate.args.list</code></td>
<td>

<p>list of arguments to supply to the <code>integrate</code> function.  The default 
value is <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>character string indicating what method to use to compute the power.  The possible 
values are <code>"approx"</code> (the default) and <code>"simulate"</code> (use 
Monte Carlo simulation).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NMC</code></td>
<td>

<p>positive integer indicating the number of Monte Carlo trials to run when <br><code>method="simulate"</code>.  The default value is <code>NMC=100</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range.delta.over.sigma</code></td>
<td>

<p>numeric vector of length 2 indicating the range of the x-variable to use for the 
plot.  The default value is <code>range.delta.over.sigma=c(0,5)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.it</code></td>
<td>

<p>a logical scalar indicating whether to create a plot or add to the existing plot 
(see explanation of the argument <code>add</code> below) on the current graphics device.  
If <code>plot.it=FALSE</code>, no plot is produced, but a list of (x,y) values is returned 
(see the section VALUE).  The default value is <code>plot.it=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>

<p>a logical scalar indicating whether to add the design plot to the existing plot (<code>add=TRUE</code>), 
or to create a plot from scratch (<code>add=FALSE</code>).  The default value is <code>add=FALSE</code>.  
This argument is ignored if <code>plot.it=FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.points</code></td>
<td>

<p>a numeric scalar specifying how many (x,y) pairs to use to produce the plot.  
There are <code>n.points</code> x-values evenly spaced between <code>range.x.var[1]</code> and <br><code>range.x.var[2]</code>.  The default value is <code>n.points=100</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.col</code></td>
<td>

<p>a numeric scalar or character string determining the color of the plotted line or points.  The default value 
is <code>plot.col="black"</code>.  See the entry for <code>col</code> in the help file for <code>par</code> 
for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.lwd</code></td>
<td>

<p>a numeric scalar determining the width of the plotted line.  The default value is 
<code>3*par("cex")</code>.  See the entry for <code>lwd</code> in the help file for <code>par</code> 
for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.lty</code></td>
<td>

<p>a numeric scalar determining the line type of the plotted line.  The default value is 
<code>plot.lty=1</code>.  See the entry for <code>lty</code> in the help file for <code>par</code> 
for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>

<p>a scalar indicating how many significant digits to print out on the plot.  The default 
value is the current setting of <code>options("digits")</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.main, main, xlab, ylab, type, ...</code></td>
<td>

<p>additional graphical parameters (see <code>par</code>).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See the help file for <code>predIntNparSimultaneousTestPower</code> for 
information on how to compute the power of a hypothesis test for the difference 
between two means of normal distributions based on a nonparametric simultaneous 
prediction interval.
</p>


<h3>Value</h3>

<p><code>plotPredIntNparSimultaneousTestPowerCurve</code> invisibly returns a list with 
components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x.var</code></td>
<td>
<p>x-coordinates of points that have been or would have been plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.var</code></td>
<td>
<p>y-coordinates of points that have been or would have been plotted.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>See the help file for <code>predIntNparSimultaneous</code>.
</p>
<p>In the course of designing a sampling program, an environmental scientist may wish 
to determine the relationship between sample size, significance level, power, and 
scaled difference if one of the objectives of the sampling program is to determine 
whether two distributions differ from each other.  The functions 
<code>predIntNparSimultaneousTestPower</code> and <br><code>plotPredIntNparSimultaneousTestPowerCurve</code> can be 
used to investigate these relationships for the case of normally-distributed 
observations. 
</p>


<h3>Author(s)</h3>

<p>Steven P. Millard (<a href="mailto:EnvStats@ProbStatInfo.com">EnvStats@ProbStatInfo.com</a>)
</p>


<h3>References</h3>

<p>See the help file for <code>predIntNparSimultaneous</code>.
</p>
<p>Gansecki, M. (2009).  <em>Using the Optimal Rank Values Calculator</em>.  
US Environmental Protection Agency, Region 8, March 10, 2009.
</p>


<h3>See Also</h3>

<p><code>predIntNparSimultaneousTestPower</code>, 
<code>predIntNparSimultaneous</code>, 
<code>predIntNparSimultaneousN</code>, 
<code>predIntNparSimultaneousConfLevel</code>, 
<code>plotPredIntNparSimultaneousDesign</code>, 
<code>predIntNpar</code>, <code>tolIntNpar</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Example 19-5 of USEPA (2009, p. 19-33) shows how to compute nonparametric upper 
  # simultaneous prediction limits for various rules based on trace mercury data (ppb) 
  # collected in the past year from a site with four background wells and 10 compliance 
  # wells (data for two of the compliance wells  are shown in the guidance document).  
  # The facility must monitor the 10 compliance wells for five constituents 
  # (including mercury) annually.

  # We will pool data from 4 background wells that were sampled on 
  # a number of different occasions, giving us a sample size of 
  # n = 20 to use to construct the prediction limit.

  # There are 10 compliance wells and we will monitor 5 different 
  # constituents at each well annually.  For this example, USEPA (2009) 
  # recommends setting r to the product of the number of compliance wells and 
  # the number of evaluations per year (i.e., r = 10 * 1 = 10).  
 
  # Here we will reproduce Figure 19-2 on page 19-35.  This figure plots the 
  # power of the nonparametric simultaneous prediction interval for 6 different 
  # plans:
  #          Rule Median.n k m Order.Statistic Achieved.alpha BG.Limit
  #1)      k.of.m        1 1 3             Max         0.0055     0.28
  #2)      k.of.m        1 1 4             Max         0.0009     0.28
  #3) Modified.CA        1 1 4             Max         0.0140     0.28
  #4)      k.of.m        3 1 2             Max         0.0060     0.28
  #5)      k.of.m        1 1 4             2nd         0.0046     0.25
  #6)      k.of.m        1 1 4             3rd         0.0135     0.24

  # Here is the power curve for the 1-of-4 sampling strategy.

  dev.new()
  plotPredIntNparSimultaneousTestPowerCurve(n = 20, k = 1, m = 4, r = 10, 
    rule = "k.of.m", n.plus.one.minus.upl.rank = 3, pi.type = "upper", 
    r.shifted = 1, method = "approx", range.delta.over.sigma = c(0, 5), main = "")

  title(main = paste(
    "Power Curve for Nonparametric 1-of-4 Sampling Strategy Based on",
    "25 Background Samples, SWFPR=10%, and 2 Future Sampling Periods", 
    sep = "\n"), cex.main = 1.1)

  #----------

  # Here are the power curves for all 6 sampling strategies.  
  # Because these take several seconds to create, here we have commented out 
  # the R commands.  To run this example, just remove the pound signs (#) from 
  # in front of the R commands.

  #dev.new()
  #plotPredIntNparSimultaneousTestPowerCurve(n = 20, k = 1, m = 4, r = 10, 
  #  rule = "k.of.m", n.plus.one.minus.upl.rank = 3, pi.type = "upper", 
  #  r.shifted = 1, method = "approx", range.delta.over.sigma = c(0, 5), main = "")

  #plotPredIntNparSimultaneousTestPowerCurve(n = 20, n.median = 3, k = 1, m = 2, 
  #  r = 10, rule = "k.of.m", n.plus.one.minus.upl.rank = 1, pi.type = "upper", 
  #  r.shifted = 1, method = "approx", range.delta.over.sigma = c(0, 5), 
  #  add = TRUE, plot.col = 2, plot.lty = 2)

  #plotPredIntNparSimultaneousTestPowerCurve(n = 20, r = 10, rule = "Modified.CA", 
  #  n.plus.one.minus.upl.rank = 1, pi.type = "upper", r.shifted = 1, 
  #  method = "approx", range.delta.over.sigma = c(0, 5), add = TRUE, 
  #  plot.col = 3, plot.lty = 3)

  #plotPredIntNparSimultaneousTestPowerCurve(n = 20, k = 1, m = 4, r = 10, 
  #  rule = "k.of.m", n.plus.one.minus.upl.rank = 2, pi.type = "upper", 
  #  r.shifted = 1, method = "approx", range.delta.over.sigma = c(0, 5), 
  #  add = TRUE, plot.col = 4, plot.lty = 4)

  #plotPredIntNparSimultaneousTestPowerCurve(n = 20, k = 1, m = 3, r = 10, 
  #  rule = "k.of.m", n.plus.one.minus.upl.rank = 1, pi.type = "upper", 
  #  r.shifted = 1, method = "approx", range.delta.over.sigma = c(0, 5), 
  #  add = TRUE, plot.col = 5, plot.lty = 5)

  #plotPredIntNparSimultaneousTestPowerCurve(n = 20, k = 1, m = 4, r = 10, 
  #  rule = "k.of.m", n.plus.one.minus.upl.rank = 1, pi.type = "upper", 
  #  r.shifted = 1, method = "approx", range.delta.over.sigma = c(0, 5), 
  #  add = TRUE, plot.col = 6, plot.lty = 6)

  #legend("topleft", legend = c("1-of-4, 3rd", "1-of-2, Max, Median", "Mod CA", 
  #  "1-of-4, 2nd", "1-of-3, Max", "1-of-4, Max"), lwd = 3 * par("cex"), 
  #  col = 1:6, lty = 1:6, bty = "n")

  #title(main = "Figure 19-2. Comparison of Full Power Curves")

  #==========

  # Clean up
  #---------
  graphics.off()
</code></pre>


</div>