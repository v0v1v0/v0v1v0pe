<div class="container">

<table style="width: 100%;"><tr>
<td>bioticVelocity</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Velocity of shifts in densities across a series of rasters</h2>

<h3>Description</h3>

<p>Calculates metrics of "movement" of cell densities across a time series of rasters. Rasters could represent, for example, the probability of presence of a species through time. In this case, velocities would indicate rates and directions of range shift.  The simplest metric is movement of the density-weighted centroid (i.e., range "center"), but many more are available to provide a nuanced indicator of velocity. See <code>Details</code> for the types of metrics that can be calculated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bioticVelocity(
  x,
  times = NULL,
  atTimes = NULL,
  elevation = NULL,
  metrics = c("centroid", "nsCentroid", "ewCentroid", "nCentroid", "sCentroid",
    "eCentroid", "wCentroid", "nsQuants", "ewQuants", "similarity", "summary"),
  quants = c(0.05, 0.1, 0.5, 0.9, 0.95),
  onlyInSharedCells = FALSE,
  cores = 1,
  warn = TRUE,
  longitude = NULL,
  latitude = NULL,
  paths = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either a <code>SpatRaster</code> or a 3-dimensional array. Values <em>should really be</em> be either <code>NA</code> or &gt;= 0.
</p>

<ul>
<li>
<p> If <code>x</code> is a <code>SpatRaster</code>, then each layer is assumed to represent a time slice. Rasters <em>must</em> be in an equal-area projection. They must also be ordered temporally, with the raster "on top" assumed to represent the starting time.
</p>
</li>
<li>
<p> If <code>x</code> is an array then each "layer" in the third dimension is assumed to represent a map at a particular time slice in an equal-area projection. Note that if this is an array you should probably also specify the arguments <code>longitude</code> and <code>latitude</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Numeric vector with the same number of layers in <code>x</code> or <code>NULL</code> (default). This specifies the time represented by each layer in <code>x</code> from beginning of the time series (top layer) to the end (bottom layer). Times <em>must</em> appear in sequential order. For example, if time periods are 24 kybp, 23 kybp, 22 kybp, use <code>c(-24, -23, -22)</code>, not <code>c(24, 23, 22)</code>. If <code>NULL</code> (default), values are assigned starting at 1 and ending at the total number of layers in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>atTimes</code></td>
<td>
<p>Numeric, values of <code>times</code> across which to calculate biotic velocity. You can use this to calculate biotic velocities across selected time periods (e.g., just the first and last time periods). Note that <code>atTimes</code> must be the same as or a subset of <code>times</code>. The default is <code>NULL</code>, in which case velocity is calculated across all time slices (i.e., between <code>times</code> 1 and 2, 2 and 3, 3 and 4, etc.).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elevation</code></td>
<td>
<p>Either <code>NULL</code> (default) or a raster or matrix representing elevation. If this is supplied, changes in elevation are incorporated into all velocity and speed metrics. Additionally, you can also calculate the metrics <code>elevCentrioid</code> and <code>elevQuants</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metrics</code></td>
<td>
<p>Biotic velocity metrics to calculate (default is to calculate them all). All metrics ignore <code>NA</code> cells in <code>x</code>. Here, "starting time period" represents one layer in <code>x</code> and "end time period" the next layer.
</p>

<ul>
<li> <p><code>centroid</code>: Speed of mass-weighted centroid (directionless).
</p>
</li>
<li> <p><code>nsCentroid</code> or <code>ewCentroid</code>: Velocity in the north-south or east-west directions of the mass-weighted centroid.
</p>
</li>
<li> <p><code>nCentroid</code>, <code>sCentroid</code>, <code>eCentroid</code>, and <code>wCentroid</code>: Speed of mass-weighted centroid of the portion of the raster north/south/east/west of the landscape-wide weighted centroid of the starting time period.
</p>
</li>
<li> <p><code>nsQuants</code> or <code>ewQuants</code>: Velocity of the location of the <em>Q</em>th quantile of mass in the north-south or east-west directions. The quantiles can be specified in <code>quants</code>. For example, this could be the movement of the 5th, 50th, and 95th quantiles of population size going from south to north. The 0th quantile would measure the velocity of the southernmost or easternmost cell(s) with values &gt;0, and the 100th quantile the northernmost or westernmost cell(s) with non-zero values.
</p>
</li>
<li> <p><code>similarity</code>: Metrics of similarity between each time period. Some of these make sense only for cases where values in <code>x</code> are in the range [0, 1], but not if some values are outside this range. See <code>nicheOverlapMetrics</code> for more details. The metrics are:
</p>

<ul>
<li>
<p> Simple mean difference
</p>
</li>
<li>
<p> Mean absolute difference
</p>
</li>
<li>
<p> Root-mean squared difference
</p>
</li>
<li>
<p> Expected Fraction of Shared Presences or ESP (Godsoe, W. 2014. <em>Ecography</em> 37:130-136 <a href="https://doi.org/10.1111/j.1600-0587.2013.00403.x">doi:10.1111/j.1600-0587.2013.00403.x</a>)
</p>
</li>
<li>
<p> D statistic (Schoener, T.W. 1968. <em>Ecology</em> 49:704-726. <a href="https://doi.org/10.2307/1935534">doi:10.2307/1935534</a>)
</p>
</li>
<li>
<p> I statistic (Warren, D.L., et al. 2008. <em>Evolution</em> 62:2868-2883 <a href="https://doi.org/10.1111/j.1558-5646.2008.00482.x">doi:10.1111/j.1558-5646.2008.00482.x</a>)
</p>
</li>
<li>
<p> Pearson correlation
</p>
</li>
<li>
<p> Spearman rank correlation
</p>
</li>
</ul>
</li>
<li> <p><code>summary</code>: This calculates a series of measures for each "starting time period" raster. None of these are measures of velocity:
</p>

<ul>
<li>
<p> Mean: Mean value across all cells.
</p>
</li>
<li>
<p> Sum: Total across all cells.
</p>
</li>
<li>
<p> Quantiles: <em>Q</em>th quantile values across all cells. Quantiles are provided through argument <code>quants</code>.
</p>
</li>
<li>
<p> Prevalence: Number of cells with values &gt; 0.
</p>
</li>
</ul>
</li>
<li> <p><code>elevCentroid</code>: Velocity of the centroid of mass in elevation (up or down). A raster or matrix must be supplied to argument <code>elevation</code>.
</p>
</li>
<li> <p><code>elevQuants</code>: Velocity of the <em>Q</em>th quantile of mass in elevation (up or down). The quantiles to be evaluated are given by <code>quants</code>. The lowest elevation with mass &gt;0 is the 0th quantile, and the highest elevation with mass &gt;0 is the 100th. Argument <code>elevation</code> must be supplied.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quants</code></td>
<td>
<p>Numeric vector indicating the quantiles at which biotic velocity is calculated for the "<code>quant</code>" and "<code>Quants</code>" metrics. Default quantiles to calculate are <code>c(0.1, 0.9)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onlyInSharedCells</code></td>
<td>
<p>If <code>TRUE</code>, calculate biotic velocity using only those cells that are not <code>NA</code> in the start <em>and</em> end of each time period. This is useful for controlling for shifting land mass due to sea level rise, for example, when calculating biotic velocity for an ecosystem or a species. The default is <code>FALSE</code>, in which case velocity is calculated using all cells in each time period, regardless of whether some become <code>NA</code> or change from <code>NA</code> to not <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Positive integer. Number of processor cores to use. Note that if the number of time steps at which velocity is calculated is small, using more cores may not always be faster.  If you have issues when <code>cores</code> &gt; 1, please see the <code>troubleshooting_parallel_operations</code> guide.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then display function-specific warnings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longitude</code></td>
<td>
<p>Numeric matrix or <code>NULL</code> (default):
</p>

<ul>
<li>
<p> If <code>x</code> is a <code>SpatRaster</code>, then this is ignored (longitude is ascertained directly from the rasters, which <em>must</em> be in equal-area projection for velocities to be valid).
</p>
</li>
<li>
<p> If <code>x</code> is an array and <code>longitude</code> is <code>NULL</code> (default), then longitude will be ascertained from column numbers in <code>x</code> and velocities will be in arbitrary spatial units (versus, for example, meters). Alternatively, this can be a two-dimensional matrix whose elements represent the longitude coordinates of the centers of cells of <code>x</code>. The matrix must have the same number of rows and columns as <code>x</code>. Coordinates must be from an equal-area projection for results to be valid.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>latitude</code></td>
<td>
<p>Numeric matrix or <code>NULL</code> (default):
</p>

<ul>
<li>
<p> If <code>x</code> is a <code>SpatRaster</code>, then this is ignored (latitude is obtained directly from the rasters, which <em>must</em> be in equal-area projection for velocities to be valid).
</p>
</li>
<li>
<p> If <code>x</code> is an array and <code>latitude</code> is <code>NULL</code> (default), then latitude will be obtained from row numbers in <code>x</code> and velocities will be in arbitrary spatial units (versus, for example, meters). Alternatively, this can be a two-dimensional matrix whose elements represent the latitude coordinates of the centers of cells of <code>x</code>. The matrix must have the same number of rows and columns as <code>x</code>. Coordinates must be from an equal-area projection for results to be valid.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paths</code></td>
<td>
<p>This is used internally and rarely (never?) needs to be defined by a user (i.e., leave it as <code>NULL</code>). Valid values are a character vector or <code>NULL</code> (default). If a character vector, it should give the values used by <code>.libPaths</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments (not used).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><em>Attention:</em>  
</p>
<p>This function may yield erroneous velocities if the region of interest is near or spans a pole or the international date line. Results using the "Quant" and "quant" metrics may be somewhat counterintuitive if just one cell is &gt;0, or one row or column has the same values with all other values equal to 0 or <code>NA</code> because defining quantiles in these situations is not intuitive. Results may also be counterintuitive if some cells have negative values because they can "push" a centroid away from what would seem to be the center of mass as assessed by visual examination of a map.  
</p>
<p><em>Note:</em>  
</p>
<p>For the <code>nsQuants</code> and <code>ewQuants</code> metrics it is assumed that the latitude/longitude assigned to a cell is at its exact center. For calculating the position of a quantile, density is interpolated linearly from one cell center to the center of the adjacent cell. If a desired quantile does not fall exactly on the cell center, it is calculated from the interpolated values. For quantiles that fall south/westward of the first row/column of cells, the cell border is assumed to be at 0.5 * cell length south/west of the cell center.
</p>


<h3>Value</h3>

<p>A data frame with biotic velocities and related values. Fields are as follows:
</p>

<ul>
<li> <p><code>timeFrom</code>: Start time of interval
</p>
</li>
<li> <p><code>timeTo</code>: End time of interval
</p>
</li>
<li> <p><code>timeMid</code>: Time point between <code>timeFrom</code> and <code>timeTo</code>
</p>
</li>
<li> <p><code>timeSpan</code>: Duration of interval
</p>
</li>
</ul>
<p>Depending on <code>metrics</code> that are specified, additional fields are as follows. All measurements of velocity are in distance units (typically meters) per time unit (which is the same as the units used for <code>times</code> and <code>atTimes</code>). For example, if the rasters are in an Albers equal-area projection and <code>times</code> are in years, then the output will be meters per year.
</p>

<ul>
<li>
<p> If <code>metrics</code> has <code>'centroid'</code>: Columns named <code>centroidVelocity</code>, <code>centroidLong</code>, <code>centroidLat</code> – Speed of weighted centroid, plus its longitude and latitude (in the <code>timeTo</code> period of each time step). Values are always &gt;= 0.
</p>
</li>
<li>
<p> If <code>metrics</code> has <code>'nsCentroid'</code>: Columns named <code>nsCentroid</code> and <code>nsCentroidLat</code> – Velocity of weighted centroid in north-south direction, plus its latitude (in the <code>timeTo</code> period of each time step). Positive values connote movement north, and negative values south.
</p>
</li>
<li>
<p> If <code>metrics</code> has <code>'ewCentroid'</code>: <code>ewCentroid</code> and <code>ewCentroidLong</code> – Velocity of weighted centroid in east-west direction, plus its longitude (in the <code>timeTo</code> period of each time step).  Positive values connote movement east, and negative values west.
</p>
</li>
<li>
<p> If <code>metrics</code> has <code>'nCentroid'</code>, <code>'sCentroid'</code>, <code>'eCentroid'</code>, and/or <code>'wCentroid'</code>: Columns named <code>nCentroidVelocity</code> and <code>nCentroidAbund</code>, <code>sCentroid</code> and <code>sCentroidAbund</code>, <code>eCentroid</code> and <code>eCentroidAbund</code>, and/or <code>wCentroid</code> and <code>wCentroidAbund</code> – Speed of weighted centroid of all cells that fall north, south, east, or west of the landscape-wide centroid, plus a column indicating the total weight (abundance) of all such populations. Values are always &gt;= 0.
</p>
</li>
<li>
<p> If <code>metrics</code> contains any of <code>nsQuants</code> or <code>ewQuants</code>: Columns named <code>nsQuantVelocity_quant</code><em>Q</em> and <code>nsQuantLat_quant</code><em>Q</em>, or <code>ewQuantVelocity_quant</code><em>Q</em> and <code>ewQuantLat_quant</code><em>Q</em>: Velocity of the <em>Q</em>th quantile weight in the north-south or east-west directions, plus the latitude or longitude thereof (in the <code>timeTo</code> period of each time step). Quantiles are cumulated starting from the south or the west, so the 0.05th quantile, for example, is in the far south or west of the range and the 0.95th in the far north or east. Positive values connote movement north or east, and negative values movement south or west.
</p>
</li>
<li>
<p> If <code>metrics</code> contains <code>similarity</code>, metrics of similarity are calculated for each pair of successive landscapes, defined below as <code>x1</code> (raster in <code>timeFrom</code>) and <code>x2</code> (raster in <code>timeTo</code>), with the number of shared non-<code>NA</code> cells between them being <code>n</code>:
</p>

<ul>
<li>
<p> A column named <code>simpleMeanDiff</code>: <code>sum(x2 - x1, na.rm = TRUE) / n</code>
</p>
</li>
<li>
<p> A column named <code>meanAbsDiff</code>: <code>sum(abs(x2 - x1), na.rm = TRUE) / n</code>
</p>
</li>
<li>
<p> A column named <code>rmsd</code> (root-mean square difference): <code>sqrt(sum((x2 - x1)^2, na.rm = TRUE)) / n</code>
</p>
</li>
<li>
<p> A column named <code>godsoeEsp</code>: <code>1 - sum(2 * (x1 * x2), na.rm=TRUE) / sum(x1 + x2, na.rm = TRUE)</code>, values of 1 ==&gt; maximally similar, 0 ==&gt; maximally dissimilar.
</p>
</li>
<li>
<p> A column named <code>schoenersD</code>: <code>1 - (sum(abs(x1 - x2), na.rm = TRUE) / n)</code>, values of 1 ==&gt; maximally similar, 0 ==&gt; maximally dissimilar.
</p>
</li>
<li>
<p> A column named <code>warrensI</code>: <code>1 - sqrt(sum((sqrt(x1) - sqrt(x2))^2, na.rm = TRUE) / n)</code>, values of 1 ==&gt; maximally similar, 0 ==&gt; maximally dissimilar.
</p>
</li>
<li>
<p> A column named <code>cor</code>: Pearson correlation between <code>x1</code> and <code>x2</code>.
</p>
</li>
<li>
<p> A column named <code>rankCor</code>: Spearman rank correlation between <code>x1</code> and <code>x2</code>.
</p>
</li>
</ul>
</li>
<li>
<p> If <code>metrics</code> contains <code>elevCentroid</code>: Columns named <code>elevCentroidVelocity</code> and <code>elevCentroidElev</code> – Velocity of the centroid in elevation (up or down) and the elevation in the "to" timestep. Positive values of velocity connote movement upward, and negative values downward.
</p>
</li>
<li>
<p> If <code>metrics</code> contains <code>elevQuants</code>: Columns named <code>elevQuantVelocity_quant</code><em>Q</em> and <code>elevQuantVelocityElev_quant</code><em>Q</em> – Velocity of the <em>N</em>th quantile of mass in elevation (up or down) and the elevation of this quantile in the "to" timestep. Positive values of velocity connote movement upward, and negative values downward.
</p>
</li>
<li>
<p> If <code>metrics</code> contains <code>summary</code>:
</p>

<ul>
<li>
<p> A column named <code>propSharedCellsNotNA</code>: Proportion of cells that are not <code>NA</code> in <em>both</em> the "from" and "to" time steps. The proportion is calculated using the total number of cells in a raster as the denominator (i.e., not total number of cells across two rasters).
</p>
</li>
<li>
<p> Columns named <code>timeFromPropNotNA</code> and <code>timeToPropNotNA</code>: Proportion of cells in the "from" time and "to" steps that are not <code>NA</code>.
</p>
</li>
<li>
<p> A column named <code>mean</code>: Mean weight in <code>timeTo</code> time step. In the same units as the values of the cells.
</p>
</li>
<li>
<p> Columns named <code>quantile_quant</code><em>Q</em>: The <em>Q</em>th quantile(s) of weight in the <code>timeTo</code> time step. In the same units as the values of the cells.
</p>
</li>
<li>
<p> A column named <code>prevalence</code>: Proportion of non-<code>NA</code> cells with weight &gt;0 in the <code>timeTo</code> time step relative to all non-<code>NA</code> cells. Unitless.
</p>
</li>
</ul>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
# NB These examples can take a few minutes to run.
# To illustrate calculation and interpretation of biotic velocity,
# we will calibrate a SDM for the Red-Bellied Lemur and project
# the model to the present and successive future climates. The time series
# of rasters is then used to calculate biotic velocity.

library(sf)
library(terra)

### process environmental rasters
#################################

# get rasters
rastFile &lt;- system.file('extdata/madClim.tif', package='enmSdmX')
madClim &lt;- rast(rastFile)

rastFile &lt;- system.file('extdata/madClim2030.tif', package='enmSdmX')
madClim2030 &lt;- rast(rastFile)

rastFile &lt;- system.file('extdata/madClim2050.tif', package='enmSdmX')
madClim2050 &lt;- rast(rastFile)

rastFile &lt;- system.file('extdata/madClim2070.tif', package='enmSdmX')
madClim2070 &lt;- rast(rastFile)

rastFile &lt;- system.file('extdata/madClim2090.tif', package='enmSdmX')
madClim2090 &lt;- rast(rastFile)

# The bioticVelocity() function needs rasters to be in equal-area
# projection, so we will project them here.
madAlbers &lt;- getCRS('madAlbers') # Albers projection for Madagascar
madClim &lt;- project(madClim, madAlbers)
madClim2030 &lt;- project(madClim2030, madAlbers)
madClim2050 &lt;- project(madClim2050, madAlbers)
madClim2070 &lt;- project(madClim2070, madAlbers)
madClim2090 &lt;- project(madClim2090, madAlbers)

# Coordinate reference systems:
wgs84 &lt;- getCRS('WGS84') # WGS84
madAlbers &lt;- getCRS('madAlbers') # Madagascar Albers

# lemur occurrence data
data(lemurs)
occs &lt;- lemurs[lemurs$species == 'Eulemur fulvus', ]
occs &lt;- vect(occs, geom=c('longitude', 'latitude'), crs=wgs84)
occs &lt;- project(occs, madAlbers)

# eliminate cell duplicates
occs &lt;- elimCellDuplicates(occs, madClim)

# extract environment at occurrences
occEnv &lt;- extract(madClim, occs, ID = FALSE)
occEnv &lt;- occEnv[complete.cases(occEnv), ]
	
# create background sites (using just 1000 to speed things up!)
bgEnv &lt;- terra::spatSample(madClim, 3000)
bgEnv &lt;- bgEnv[complete.cases(bgEnv), ]
bgEnv &lt;- bgEnv[sample(nrow(bgEnv), 1000), ]

# collate occurrences and background sites
presBg &lt;- data.frame(
   presBg = c(
      rep(1, nrow(occEnv)),
      rep(0, nrow(bgEnv))
   )
)

env &lt;- rbind(occEnv, bgEnv)
env &lt;- cbind(presBg, env)

### calibrate model
###################

predictors &lt;- c('bio1', 'bio12')

# MaxEnt
mx &lt;- trainMaxEnt(
	data = env,
	resp = 'presBg',
	preds = predictors,
	regMult = 1, # too few values for reliable model, but fast
	cores = 2
)

### project to present and future climate
#########################################

predPresent &lt;- predictEnmSdm(mx, madClim)
pred2030 &lt;- predictEnmSdm(mx, madClim2030)
pred2050 &lt;- predictEnmSdm(mx, madClim2050)
pred2070 &lt;- predictEnmSdm(mx, madClim2070)
pred2090 &lt;- predictEnmSdm(mx, madClim2090)

plot(predPresent, main = 'Present Suitability')

# plot change in suitability between present and 2090s
delta &lt;- pred2090 - predPresent
plot(delta, main = 'Change in Suitability')

### calculate biotic velocity
#############################

series &lt;- c(
	predPresent,
	pred2030,
	pred2050,
	pred2070,
	pred2090
)

names(series) &lt;- c('present', 't2030', 't2050', 't2070', 't2090')
plot(series)

times &lt;- c(1985, 2030, 2050, 2070, 2090)
quants &lt;- c(0.10, 0.90)

bv &lt;- bioticVelocity(
	x = series,
	times = times,
	quants = quants,
	cores = 2
)
 
bv

### centroid velocities

# centroid (will always be &gt;= 0)
# fastest centroid movement around 2060
plot(bv$timeMid, bv$centroidVelocity, type = 'l',
  xlab = 'Year', ylab = 'Speed (m / y)', main = 'Centroid Speed')
  
# velocity northward/southward through time
# shows northward shift because always positive, fastest around 2060
plot(bv$timeMid, bv$nsCentroidVelocity, type = 'l',
  xlab = 'Year', ylab = 'Velocity (m / y)', main = 'Centroid N/S Velocity')
  
# velocity eastward (positive)/westward (negative) through time
# movement eastward (positive) first, then westward (negative)
plot(bv$timeMid, bv$ewCentroidVelocity, type = 'l',
  xlab = 'Year', ylab = 'Velocity (m / y)', main = 'Centroid E/W Velocity')

### map of centroid location through time
# shows centroid moves slightly northward through time
plot(delta, main = 'Centroid Location &amp;\nChange in Suitability')
points(bv$centroidLong[1], bv$centroidLat[1], pch = 1)
points(bv$centroidLong[4], bv$centroidLat[4], pch = 16)
lines(bv$centroidLong, bv$centroidLat)
legend(
  'bottomright',
  legend = c(
    'start (~1985)',
	'stop (~2090)',
	'trajectory'
  ),
  pch = c(1, 16, NA),
  lwd = c(NA, NA, 1)
)

### velocities of portions of range north/south/east/west of centroid
# positive ==&gt; northward shift
# negative ==&gt; southward shift
  
# portion of range north of centroid
# shows northward expansion because always positive
plot(bv$timeMid, bv$nCentroidVelocity, type = 'l',
  xlab = 'Year', ylab = 'Velocity (m / y)',
  main = 'Northern Part of Range')
  
# portion of range south of centroid
# shows northward contraction because always positive
plot(bv$timeMid, bv$sCentroidVelocity, type = 'l',
  xlab = 'Year', ylab = 'Velocity (m / y)',
  main = 'Southern Part of Range')
  
# portion of range east of centroid
# shows eastern portion moves farther east
plot(bv$timeMid, bv$eCentroidVelocity, type = 'l',
  xlab = 'Year', ylab = 'Velocity (m / y)',
  main = 'Eastern Part of Range')
  
# portion of range west of centroid
# shows western portion moves east
plot(bv$timeMid, bv$wCentroidVelocity, type = 'l',
  xlab = 'Year', ylab = 'Velocity (m / y)',
  main = 'Western Part of Range')

### velocities of range margins

# from south to north, 10th and 90th quantiles of density
# positive ==&gt; northward shift
# negative ==&gt; southward shift
# shows both northern and southern range margins shift northward
# because always positive... northern margin shift usually slower
ylim &lt;- range(bv$nsQuantVelocity_quant0p1, bv$nsQuantVelocity_quant0p9)

plot(bv$timeMid, bv$nsQuantVelocity_quant0p1, type = 'l', ylim = ylim,
  xlab = 'Year', ylab = 'Velocity (m / y)',
  main = 'Northern/Southern Range Margins')
lines(bv$timeMid, bv$nsQuantVelocity_quant0p9, lty = 'dashed')
legend(
  'bottomright',
  legend = c('Southern Margin', 'Northern Margin'),
  lty = c('solid', 'dashed')
)
  
# from east to west, 10th and 90th quantiles of density
# positive ==&gt; eastward shift
# negative ==&gt; westward shift
ylim &lt;- range(bv$ewQuantVelocity_quant0p1, bv$ewQuantVelocity_quant0p9)

plot(bv$timeMid, bv$ewQuantVelocity_quant0p1, type = 'l', ylim = ylim,
  xlab = 'Year', ylab = 'Velocity (m / y)',
  main = 'Eastern/Western Range Margins')
lines(bv$timeMid, bv$ewQuantVelocity_quant0p9, lty = 'dashed')
legend(
  'bottomright',
  legend = c('Eastern Margin', 'Western Margin'),
  lty = c('solid', 'dashed')
)
  
  
### summary statistics

# mean density across cells through time
plot(bv$timeMid, bv$mean, type = 'l',
  xlab = 'Year', ylab = 'Mean Density',
  main = 'Mean Density')

# sum of density across cells through time
plot(bv$timeMid, bv$sum, type = 'l',
  xlab = 'Year', ylab = 'Sum of Density',
  main = 'Sum of Density')

### change metrics

# average change in suitability from one time period to next
# shows average conditions getting worse
plot(bv$timeMid, bv$simpleMeanDiff, type = 'l',
  xlab = 'Year', ylab = 'Mean Change in Suitability')
  
# average absolute change in suitability from one time period to next
# shows average absolute change declining
plot(bv$timeMid, bv$meanAbsDiff, type = 'l',
  xlab = 'Year', ylab = 'Mean Absolute Change in Suitability')
  
# root-mean square difference from one time period to the next
# shows difference between successive rasters declines through time
plot(bv$timeMid, bv$rmsd, type = 'l',
  xlab = 'Year', ylab = 'RMSD')
  
### raster similarity
# most indicate that successive rasters are similar through time
ylim &lt;- range(bv$godsoeEsp, bv$schoenerD, bv$warrenI, bv$cor, bv$warrenI)
plot(bv$timeMid, bv$godsoeEsp, type = 'l', lty = 1, col = 1,
  xlab = 'Year', ylab = 'Raster similarity', ylim = ylim)
lines(bv$timeMid, bv$schoenerD, lty = 2, col = 2)
lines(bv$timeMid, bv$warrenI, lty = 3, col = 3)
lines(bv$timeMid, bv$cor, lty = 4, col = 4)
lines(bv$timeMid, bv$rankCor, lty = 5, col = 5)

legend(
  'right',
  legend = c(
    'Godsoe\'s ESP',
    'Schoener\'s D',
    'Warren\'s I',
    'Correlation',
    'Rank Correlation'
  ),
  col = 1:5,
  lty = 1:5
)
  

# values of 10th and 90th quantiles across cells through time
# shows most favorable cells becoming less favorable
# least favorable cells remain mainly unchanged
ylim &lt;- range(bv$quantile_quant0p1, bv$quantile_quant0p9)

plot(bv$timeMid, bv$quantile_quant0p1, type = 'l', ylim = ylim,
  xlab = 'Year', ylab = 'Quantile Value',
  main = 'Quantiles across Cells')
lines(bv$timeMid, bv$quantile_quant0p9, lty = 'dashed')

legend(
  'topright',
  legend = c('10th quantile', '90th quantile'),
  lty = c('solid', 'dashed')
)

### map of northern/southern range margins through time

# range of longitude shown in plot
madExtent &lt;- ext(madClim)
xExtent &lt;- as.vector(madExtent)[1:2]

plot(predPresent, main = 'North/South Range Margin Location')
lines(c(xExtent[1], xExtent[2]),
  c(bv$nsQuantLat_quant0p9[1], bv$nsQuantLat_quant0p9[1]))
lines(c(xExtent[1], xExtent[2]),
  c(bv$nsQuantLat_quant0p9[2], bv$nsQuantLat_quant0p9[2]), lty = 'dashed')
lines(c(xExtent[1], xExtent[2]),
  c(bv$nsQuantLat_quant0p9[3], bv$nsQuantLat_quant0p9[3]), lty = 'dotdash')
lines(c(xExtent[1], xExtent[2]),
  c(bv$nsQuantLat_quant0p9[4], bv$nsQuantLat_quant0p9[4]), lty = 'dotted')

lines(c(xExtent[1], xExtent[2]),
  c(bv$nsQuantLat_quant0p1[1], bv$nsQuantLat_quant0p1[1]))
lines(c(xExtent[1], xExtent[2]),
  c(bv$nsQuantLat_quant0p1[2], bv$nsQuantLat_quant0p1[2]), lty = 'dashed')
lines(c(xExtent[1], xExtent[2]),
  c(bv$nsQuantLat_quant0p1[3], bv$nsQuantLat_quant0p1[3]), lty = 'dotdash')
lines(c(xExtent[1], xExtent[2]),
  c(bv$nsQuantLat_quant0p1[4], bv$nsQuantLat_quant0p1[4]), lty = 'dotted')

legend(
  'bottomright',
  legend = c(
    '1980s',
	'2030s',
	'2050s',
	'2070s',
	'2090s'
  ),
  lty = c('solid', 'dashed', 'dotdash', 'dotted')
)

### map of eastern/western range margins through time

# range of longitude shown in plot
madExtent &lt;- ext(madClim)
yExtent &lt;- as.vector(madExtent)[3:4]

plot(predPresent, main = 'North/South Range Margin Location')
lines(c(bv$ewQuantLong_quant0p9[1], bv$ewQuantLong_quant0p9[1]),
  c(yExtent[1], yExtent[2]))
lines(c(bv$ewQuantLong_quant0p9[2], bv$ewQuantLong_quant0p9[2]),
  c(yExtent[1], yExtent[2]), lty = 'dashed')
lines(c(bv$ewQuantLong_quant0p9[3], bv$ewQuantLong_quant0p9[3]),
  c(yExtent[1], yExtent[2]), lty = 'dotdash')
lines(c(bv$ewQuantLong_quant0p9[4], bv$ewQuantLong_quant0p9[4]),
  c(yExtent[1], yExtent[2]), lty = 'dotted')

lines(c(bv$ewQuantLong_quant0p1[1], bv$ewQuantLong_quant0p1[1]),
  c(yExtent[1], yExtent[2]))
lines(c(bv$ewQuantLong_quant0p1[2], bv$ewQuantLong_quant0p1[2]),
  c(yExtent[1], yExtent[2]), lty = 'dashed')
lines(c(bv$ewQuantLong_quant0p1[3], bv$ewQuantLong_quant0p1[3]),
  c(yExtent[1], yExtent[2]), lty = 'dotdash')
lines(c(bv$ewQuantLong_quant0p1[4], bv$ewQuantLong_quant0p1[4]),
  c(yExtent[1], yExtent[2]), lty = 'dotted')

legend(
  'bottomright',
  legend = c(
    '1980s',
	'2030s',
	'2050s',
	'2070s',
	'2090s'
  ),
  lty = c('solid', 'dashed', 'dotdash', 'dotted')
)



</code></pre>


</div>