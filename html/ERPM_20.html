<div class="container">

<table style="width: 100%;"><tr>
<td>estimate_multipleERPM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate ERPM for multiple observations</h2>

<h3>Description</h3>

<p>Function to estimate a given model for given observed (multiple) partitions.
All options of the algorithm can be specified here.
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimate_multipleERPM(
  partitions,
  presence.tables,
  nodes,
  objects,
  effects,
  startingestimates,
  gainfactor = 0.1,
  a.scaling = 0.8,
  r.truncation.p1 = -1,
  r.truncation.p2 = -1,
  burnin = 30,
  thining = 10,
  length.p1 = 100,
  min.iter.p2 = NULL,
  max.iter.p2 = NULL,
  multiplication.iter.p2 = 200,
  num.steps.p2 = 6,
  length.p3 = 1000,
  neighborhood = c(0.7, 0.3, 0),
  fixed.estimates = NULL,
  numgroups.allowed = NULL,
  numgroups.simulated = NULL,
  sizes.allowed = NULL,
  sizes.simulated = NULL,
  double.averaging = FALSE,
  inv.zcov = NULL,
  inv.scaling = NULL,
  parallel = FALSE,
  parallel2 = FALSE,
  cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>partitions</code></td>
<td>
<p>observed partitions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>presence.tables</code></td>
<td>
<p>XXX</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodes</code></td>
<td>
<p>nodeset (data frame)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector "name", and a vector "object")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector "names", and a vector "objects")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startingestimates</code></td>
<td>
<p>first guess for the model parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gainfactor</code></td>
<td>
<p>numeric used to decrease the size of steps made in the Newton optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.scaling</code></td>
<td>
<p>numeric used to reduce the influence of non-diagonal elements in the scaling matrix (for stability)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r.truncation.p1</code></td>
<td>
<p>numeric used to limit extreme values in the covariance matrix (for stability)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r.truncation.p2</code></td>
<td>
<p>numeric used to limit extreme values in the covariance matrix (for stability)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length.p1</code></td>
<td>
<p>number of samples in phase 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.iter.p2</code></td>
<td>
<p>minimum number of sub-steps in phase 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter.p2</code></td>
<td>
<p>maximum number of sub-steps in phase 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiplication.iter.p2</code></td>
<td>
<p>value for the lengths of sub-steps in phase 2 (multiplied by  2.52^k)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.steps.p2</code></td>
<td>
<p>number of optimisation steps in phase 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length.p3</code></td>
<td>
<p>number of samples in phase 3</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighborhood</code></td>
<td>
<p>way of choosing partitions: probability vector (actors swap, merge/division, single actor move)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.estimates</code></td>
<td>
<p>if some parameters are fixed, list with as many elements as effects, these elements equal a fixed value if needed, or NULL if they should be estimated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sizes.allowed</code></td>
<td>
<p>vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sizes.simulated</code></td>
<td>
<p>vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>double.averaging</code></td>
<td>
<p>option to average the statistics sampled in each sub-step of phase 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv.zcov</code></td>
<td>
<p>initial value of the inverted covariance matrix (if a phase 3 was run before) to bypass the phase 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv.scaling</code></td>
<td>
<p>initial value of the inverted scaling matrix (if a phase 3 was run before) to bypass the phase 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>whether the phase 1 and 3 should be parallelized</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel2</code></td>
<td>
<p>whether there should be several phases 2 run in parallel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpus</code></td>
<td>
<p>how many cores can be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the outputs of the three different phases of the algorithm
</p>


<h3>Examples</h3>

<pre><code class="language-R"># define an arbitrary set of n = 6 nodes with attributes, and an arbitrary covariate matrix
n &lt;- 6 
nodes &lt;- data.frame(label = c("A","B","C","D","E","F"),
                    gender = c(1,1,2,1,2,2),
                    age = c(20,22,25,30,30,31)) 
friendship &lt;- matrix(c(0, 1, 1, 1, 0, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 0, 0,
                       0, 1, 1, 0, 0, 1,
                       0, 0, 0, 0, 1, 0), 6, 6, TRUE) 

# specify whether nodes are present at different points of time
presence.tables &lt;- matrix(c(1, 1, 1, 1, 1, 1,
                            0, 1, 1, 1, 1, 1,
                            1, 0, 1, 1, 1, 1), 6, 3)

# choose effects to be included in the estimated model
effects_multiple &lt;- list(names = c("num_groups","same","diff","tie","inertia_1"),
                objects = c("partitions","gender","age","friendship","partitions"),
                objects2 = c("","","","",""))
objects_multiple &lt;- list()
objects_multiple[[1]] &lt;- list(name = "friendship", object = friendship)

# define the observation
partitions &lt;- matrix(c(1, 1, 2, 2, 2, 3,
                       NA, 1, 1, 2, 2, 2,
                       1, NA, 2, 3, 3, 1), 6, 3) 


# estimate
startingestimates &lt;- c(-2,0,0,0,0)
estimation &lt;- estimate_multipleERPM(partitions,
                                    presence.tables,          
                                    nodes, 
                                    objects_multiple, 
                                    effects_multiple, 
                                    startingestimates = startingestimates, 
                                    burnin = 100, 
                                    thining = 50,
                                    gainfactor = 0.6,
                                    length.p1 = 200, 
                                    multiplication.iter.p2 = 20, 
                                    num.steps.p2 = 4, 
                                    length.p3 = 1000) 

# get results table
estimation


</code></pre>


</div>