<div class="container">

<table style="width: 100%;"><tr>
<td>extend.cord</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate or extend multivariate abundance data</h2>

<h3>Description</h3>

<p><code>extend</code> returns a simulated response matrix or a <code>manyglm</code> object with <code>N</code> observations
and simulated response matrix that utilises the existing correlation structure of the data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'cord'
extend(
  object,
  N = nrow(object$obj$data),
  coeffs = coef(object$obj),
  newdata = NULL,
  n_replicate = NULL,
  do.fit = FALSE,
  seed = NULL
)

extend(
  object,
  N = nrow(object$obj$data),
  coeffs = coef(object$obj),
  newdata = NULL,
  n_replicate = NULL,
  do.fit = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>objects of class <code>cord</code>, typically the result of a call to <code>cord</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Number of samples to be extended. Defaults to the number of observations in the original sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coeffs</code></td>
<td>
<p>Coefficient matrix for a <code>manyglm</code> object that characterises the size of effects to be simulated.
See <code>effect_alt</code> for help in producing this matrix. Defaults to the coefficient matrix from the <code>cord</code>
object, <code>coef(object$obj)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Data frame of same size as the original X covariates from the fitted <code>object</code>, that specifies
a different design of interest. Defaults to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_replicate</code></td>
<td>
<p>Number of unique replicates of the original data frame. Defaults to <code>NULL</code>, overwrites <code>N</code> if specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.fit</code></td>
<td>
<p>Logical. If <code>TRUE</code>, fits a <code>manyglm</code> object from the simulated data. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random number seed, defaults to a random seed number.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>extend</code> takes a <code>cord</code> object and returns a new simulated response matrix or an "extended" <code>manyglm</code> object
with <code>N</code> observations and the new simulated response matrix. Response abundances are simulated through a Gaussian
copula model that utilises a coefficient matrix <code>coeffs</code>, the specified <code>cord</code> model and the joint
correlation structure exhibited between the response variables. To help with the specification of
<code>coeffs</code>, see <code>effect_alt</code> which simplifies this process.
</p>
<p>Response variables are simulated through a copula model by first extracting Gaussian copular scores
as Dunn-Smyth residuals (Dunn &amp; Smyth 1996), which are obtained from abundances <code class="reqn">y_{ij}</code> with marginal distributions
<code class="reqn">F_j</code> which have been specified via the original <code>manyglm</code> model (<code>fit.glm</code>; see examples);
</p>
<p style="text-align: center;"><code class="reqn">z_{ij} = \Phi^{-1}{F_{j}(y_{ij}^-) + u_{ij} f_{j}(y_{ij})}</code>
</p>

<p>These scores then follow a multivariate Gaussian distribution with zero mean and covariance structure <code class="reqn">\Sigma</code>,
</p>
<p style="text-align: center;"><code class="reqn">z_{ij} \sim N_p(0,\Sigma)</code>
</p>

<p>To avoid estimating a large number <code class="reqn">p(p-1)/2</code> pairwise correlations within <code class="reqn">\Sigma</code>, factor analysis is utilised
with two latent factor variables, which can be interpreted as an unobserved environmental covariate.
</p>
<p>Thus, in order to simulate new multivariate abundances we simulate new copula scores and back transform them to
abundances as <code class="reqn">y_{ij}= {F^*}_j^{-1}(\Phi(z_{ij}))</code>, where the coefficient matrix <code>coeffs</code> specifies the
effect size within the new marginal distributions <code class="reqn">{F^*}_j</code>.
</p>
<p>The data frame is also extended in a manner that preserves the original design structure. This is done by first
repeating the design matrix until the number of samples exceeds <code>N</code>, then randomly removing rows from the last
repeated data frame until the number of samples equals <code>N</code>. Alternatively, a balanced design structure can be
obtained by specifying the number of replicates.
</p>
<p><code>newdata</code> can be utilised if a different data frame is wanted for simulation.
</p>
<p>If users are interested in obtaining a <code>manyglm</code> model, <code>do.fit=TRUE</code> can be used to obtain a <code>manyglm</code>
object from the simulated responses.
</p>


<h3>Value</h3>

<p>Simulated data or <code>manyglm</code> object.
</p>


<h3>Functions</h3>


<ul><li> <p><code>extend()</code>: Simulate or extend multivariate abundance data
</p>
</li></ul>
<h3>References</h3>

<p>Dunn, P.K., &amp; Smyth, G.K. (1996). Randomized quantile residuals. Journal of Computational and Graphical Statistics 5, 236-244.
</p>


<h3>See Also</h3>

<p><code>effect_alt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ecoCopula)
library(mvabund)
data(spider)
spiddat = mvabund(spider$abund)
X = data.frame(spider$x)

# Specify increasers and decreasers
increasers = c("Alopacce", "Arctlute", "Arctperi", "Pardnigr", "Pardpull")
decreasers = c("Alopcune", "Alopfabr", "Zoraspin")

# Simulate data
fit.glm = manyglm(spiddat~1, family="negative.binomial")
fit.cord = cord(fit.glm)
simData = extend(fit.cord)

# Simulate data with N=20
fit.glm = manyglm(spiddat~soil.dry, family="negative.binomial", data=X)
fit.cord = cord(fit.glm)
simData = extend(fit.cord, N=20)

# Obtain a manyglm fit from simulated data with N=10 and effect_size=1.5
X$Treatment = rep(c("A","B","C","D"),each=7)
fit_factors.glm = manyglm(spiddat~Treatment, family="negative.binomial", data=X)
effect_mat = effect_alt(fit_factors.glm, effect_size=1.5,
     increasers, decreasers, term="Treatment")
fit_factors.cord = cord(fit_factors.glm)
newFit.glm = extend(fit_factors.cord, N=10,
     coeffs=effect_mat, do.fit=TRUE)

# Change sampling design
X_new = X
X_new$Treatment[6:7] = c("B","B")
simData = extend(fit_factors.cord, N=NULL,
   coeffs=effect_mat, newdata=X_new, n_replicate=5)
</code></pre>


</div>