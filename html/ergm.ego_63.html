<div class="container">

<table style="width: 100%;"><tr>
<td>template_network</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct an Empty “Template” Network Consistent with an Egocentric Sample</h2>

<h3>Description</h3>

<p>Taking an object with ego information, constructs a
<code>network</code> object with no edges whose vertices have the
attributes of the egos in the dataset, replicating the egos as needed, and
taking into accounts their sampling weights.
</p>


<h3>Usage</h3>

<pre><code class="language-R">template_network(x, ...)

## S3 method for class 'data.frame'
template_network(x, ...)

## S3 method for class 'egor'
template_network(x, N, scaling = c("round", "sample"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>egor</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>The target number of vertices the output network should have.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>If <code>egor</code> contains weights or <code>N</code> is not
a multiple of number of egos in the sample, it may not be possible, for a
finite <code>N</code> to represent each ego exactly according to its relative
weight, and <code>scaling</code> controls how the fractional egos are allocated:
</p>
 <dl>
<dt>"round"</dt>
<dd>
<p>(the default) Rather than treating <code>N</code> as a hard
setting, calculate <code class="reqn">N w_i / w_\cdot</code> for each ego <code class="reqn">i</code> and round it
to the nearest integer. Then, the <code>N</code> actually used will be the sum of
these rounded freqencies.</p>
</dd> <dt>"sample"</dt>
<dd>
<p>Resample in
proportion to <code class="reqn">w_i</code>.</p>
</dd> </dl>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>network</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>template_network(data.frame)</code>: method for <code>data.frame</code>s and <code>tibble</code>s, specifying ego composition directly.
</p>
</li>
<li> <p><code>template_network(egor)</code>: method for <code>egor</code> objects; weights, if any, are obtained from the <code>egor</code>'s design information.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>See Also</h3>

<p><code>as.egor.network</code>, which performs the inverse
operation.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

data(faux.mesa.high)
summary(faux.mesa.high, print.adj = FALSE)

fmh.ego &lt;- as.egor(faux.mesa.high)

# Same actor attributes
fmh.template &lt;- template_network(fmh.ego, N=network.size(faux.mesa.high))
summary(fmh.template, print.adj = FALSE)

# Twice the actors, same distribution
fmh2.template &lt;- template_network(fmh.ego, N=2*network.size(faux.mesa.high))
summary(fmh2.template, print.adj = FALSE)

</code></pre>


</div>