<div class="container">

<table style="width: 100%;"><tr>
<td>ipc.estK</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Fit the (In)homogeneous Poisson Cluster Point Process by Minimum Contrast </h2>

<h3>Description</h3>

<p>Fits the (In)homogeneous Poisson Cluster point process to a point pattern dataset by the Method of Minimum Contrast.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ipc.estK(mippp, lambda = NULL, correction = "iso", r = NULL, sigma2 = NULL,
            rho = NULL, q = 1/4, p = 2)


## S3 method for class 'ecespa.minconfit'
plot(x, type="L", add=FALSE, xlim=NULL, ylim=NULL, lwd=c(1,1),
           lty=c(1,2), col=c(1,2), main=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mippp</code></td>
<td>
<p> Point pattern to which the  (I)PCP will be fitted. A point pattern with the <code>ppp</code> format of <code>spatstat</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p> Optional. Values of the estimated intensity function as a pixel image (object of class "<code>im</code>" of spatstat) giving the intensity values at all locations of <code>mippp</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>
<p> A character item selecting any of the options "border", "bord.modif", "isotropic", "Ripley" or
"translate". It specifies the edge correction(s) to be applied in the computation of the <code class="reqn">K(r)</code> function.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>  Numeric vector. The values of the argument <code class="reqn">r</code> at which the <code class="reqn">K(r)</code> functions  should be evaluated.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p> Optional. Starting value for the parameter <code class="reqn">sigma2</code> of the Poisson Cluster process. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p> Optional. Starting value for the parameter <code class="reqn">rho</code> of the Poisson Cluster process. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
 <p><code class="reqn">q</code> exponent of the contrast criterion (see <code>mincontrast</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
 <p><code class="reqn">p</code> exponent of the contrast criterion (see <code>mincontrast</code>).  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> An object of class 'ecespa.minconfit', resulting of  applying <code>ipc.estK</code> to fit a Poisson Cluster Process. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> Type of function to be ploted. If type="L", function <code class="reqn">L(r)</code> [= <code class="reqn">sqrt(K(r)/pi)-r</code>] is ploted. Otherwise, function <code class="reqn">K(r)</code> is ploted. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p> Logical. Should the curves be added to another plot? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p> Vector setting the limits of the x-axis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p> Vector setting the limits of the y-axis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p> Vector (length=2) setting the line width for ploting the two functions. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p> Vector (length=2) setting the line type for ploting the two functions. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p> Vector (length=2) setting the line color for ploting the two functions. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p> Optional. Text to appear as a title of the plot. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Additional graphical parameters passed to <code>link{plot}</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm fits the (inhomogeneous) Poisson cluster point process (PCP) to a point pattern, by finding the parameters of the (inhomogeneous) Poisson cluster model
which give the closest match between the theoretical K function of the Poisson cluster process and the observed
K function. For a concise explanation of the PCP see <code>pc.estK</code>. For a more detailed explanation of the Method of Minimum Contrast, see <code>mincontrast</code>
in <span class="pkg">spatstat</span> or Diggle (2003: 86). 
</p>
<p>The inhomogeneous PCP can be thought of as a thinned process of an homogeneous PCP, where the spatially varying thinning probability
<code class="reqn">f(s)</code> is related to the spatially varying intensity function <code class="reqn">lambda(s)</code> as <code class="reqn">f(s) = lambda(s)/max{lambda(s)}</code> (Waagepetersen, 2007).  
As the inhomogeneous K function  for  the IPCP coincides with the (homogeneous) K function for the corresponding homogeneous PCP, 
the parameters of the underlying homomgeneous PCP can be estimated as those that give the closest match between the theoretical K function 
for the homogeneous PCP and the empirical inhomogeneous K function  for  the observed IPCP.
</p>
<p>This Poisson cluster process can be simulated with <code>rIPCP</code>.
</p>


<h3>Value</h3>

<p><code>ipc.estK</code> gives an object of class '<code>ecespa.minconfit</code>', basically a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p>Parameter <code class="reqn">sigma^2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho </code></td>
<td>
<p>Parameter <code class="reqn">rho</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.theta </code></td>
<td>
<p>Minimized value of the contrast criterion <code class="reqn">D(theta)</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kobs </code></td>
<td>
<p>Values of the observed K-function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kfit </code></td>
<td>
<p>Values of the fitted K-function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r </code></td>
<td>
<p> Sequence of distances at which <code>Kobs</code> and <code>Kfit</code> have been estimated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data </code></td>
<td>
<p>Original point pattern. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda </code></td>
<td>
<p>Original intensity function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataname </code></td>
<td>
<p>Name of the original point pattern. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaname </code></td>
<td>
<p>Name of the original intensity function image. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
 <p><code class="reqn">q</code> exponent of the contrast criterion. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
 <p><code class="reqn">p</code> exponent of the contrast criterion.  </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot , inspired by some code of  Philip M. Dixon </p>


<h3>References</h3>

<p>Diggle, P. J. 2003. <em>Statistical analysis of spatial point patterns</em>. Arnold, London.
</p>
<p>Waagepetersen, R. P. 2007. An estimating function approach to inference for inhomogeneous Neymann-Scott processes. <em>Biometrics</em> 63: 252-258. <a href="https://doi.org/10.1111/j.1541-0420.2006.00667.x">doi:10.1111/j.1541-0420.2006.00667.x</a>.
</p>


<h3>See Also</h3>

<p>some functions in <span class="pkg">spatstat</span>: <code>mincontrast</code> for a more general implementation of the method of mimimum contrast;
<code>matclust.estK</code> and <code>lgcp.estK</code> fit other appropriate processes for clustered patterns.</p>


<h3>Examples</h3>

<pre><code class="language-R">

#####################
## Same example as in pc.estK

data(gypsophylous)

# set the number of simulations (nsim=199 or larger for real analyses)
# and resolution for lambda (ngrid=200  or larger for real analyses)
nsim&lt;- 19
ngrid &lt;- 50

## Estimate K function ("Kobs").

gyps.env &lt;- envelope(gypsophylous, Kest, correction="iso", nsim=nsim)

plot(gyps.env, sqrt(./pi)-r~r, legend=FALSE)

## Fit Poisson Cluster Process. The limits of integration 
## rmin and rmax are setup to 0 and 60, respectively. 

cosa.pc2 &lt;- ipc.estK(gypsophylous, r = gyps.env$r[gyps.env$r&lt;=60])

## Add fitted Kclust function to the plot.


plot(cosa.pc2, add=TRUE, lwd=c(3,3))


## A kind of pointwise test of the gypsophylous pattern been a realisation
## of the fitted model, simulating with rIPCP and using function J (Jest).


gyps.env.sim2 &lt;- envelope(gypsophylous, Jest, nsim=nsim,
                    simulate=expression(rIPCP(cosa.pc2)))


plot(gyps.env.sim2,  main="",legendpos="bottomleft")

## Not run: 

#####################
## Inhomogeneous example

data(urkiola)
   
   #####################
   ## univariate case

   # get univariate pp
   I.ppp &lt;- split.ppp(urkiola)$birch

   # estimate inhomogeneous intensity function
   I.lam &lt;- predict (ppm(I.ppp, ~polynom(x,y,2)), type="trend", ngrid=ngrid)

   # Compute and plot envelopes to Kinhom, simulating from an Inhomogeneous
   #  Poisson Process:
   
   I2.env &lt;- envelope( I.ppp,Kinhom, lambda=I.lam, correction="trans", 
                              nsim=nsim, simulate=expression(rpoispp(I.lam)))
   plot(I2.env, sqrt(./pi)-r~r, xlab="r (metres)", ylab= "L (r)", col=c(1,3,2,2),legend=FALSE) 

   # It seems that there is short scale clustering; let's fit an Inhomogeneous 
   # Poisson Cluster Process: 

   I.ki &lt;- ipc.estK(mippp=I.ppp, lambda=I.lam, correction="trans")

   # Compute and plot envelopes to Kinhom, simulating from the fitted IPCP:

   Ipc.env &lt;- Ki(I.ki, correction="trans", nsim=nsim, ngrid=ngrid)

   plot (Ipc.env, xlab="r (metres)", ylab= "L (r)")
 
   #####################
   ## bivariate case: test independence between birch and quercus in Urkiola

   J.ppp &lt;- split.ppp(urkiola)$oak
   
   # We want to simulate oak from a homogeneous Poisson model:
   J.ppm &lt;- ppm(J.ppp, trend=~1, interaction=Poisson() )
   
   IJ.env &lt;- Kci (mod1=I.ki, mod2=J.ppm, nsim=nsim)
   
   plot(IJ.env, type=12)
   
   plot(IJ.env, type=21)

## End(Not run)


</code></pre>


</div>