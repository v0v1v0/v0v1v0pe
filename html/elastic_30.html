<div class="container">

<table style="width: 100%;"><tr>
<td>cluster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Elasticsearch cluster endpoints</h2>

<h3>Description</h3>

<p>Elasticsearch cluster endpoints
</p>


<h3>Usage</h3>

<pre><code class="language-R">cluster_settings(
  conn,
  index = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)

cluster_health(
  conn,
  index = NULL,
  level = NULL,
  wait_for_status = NULL,
  wait_for_relocating_shards = NULL,
  wait_for_active_shards = NULL,
  wait_for_nodes = NULL,
  timeout = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)

cluster_state(
  conn,
  index = NULL,
  metrics = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)

cluster_stats(
  conn,
  index = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)

cluster_reroute(conn, body, raw = FALSE, callopts = list(), ...)

cluster_pending_tasks(
  conn,
  index = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code>connect()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>Index</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>
<p>If <code>TRUE</code> (default), data is parsed to list. If <code>FALSE</code>, then raw JSON.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>callopts</code></td>
<td>
<p>Curl args passed on to crul::verb-POST</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) the url call used printed to console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further args passed on to elastic search HTTP API as parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Can be one of cluster, indices or shards. Controls the details level of the
health information returned. Defaults to cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wait_for_status</code></td>
<td>
<p>One of green, yellow or red. Will wait (until the timeout
provided) until the status of the cluster changes to the one provided or better, i.e.
green &gt; yellow &gt; red. By default, will not wait for any status.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wait_for_relocating_shards</code></td>
<td>
<p>A number controlling to how many relocating shards
to wait for. Usually will be 0 to indicate to wait till all relocations have happened.
Defaults to not wait.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wait_for_active_shards</code></td>
<td>
<p>A number controlling to how many active shards to wait for.
Defaults to not wait.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wait_for_nodes</code></td>
<td>
<p>The request waits until the specified number N of nodes is
available. It also accepts &gt;=N, &lt;=N, &gt;N and &lt;N. Alternatively, it is possible to use
ge(N), le(N), gt(N) and lt(N) notation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeout</code></td>
<td>
<p>A time based parameter controlling how long to wait if one of the
wait_for_XXX are provided. Defaults to 30s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metrics</code></td>
<td>
<p>One or more of version, master_node, nodes, routing_table,
metadata, and blocks. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>body</code></td>
<td>
<p>Query, either a list or json.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>metrics param options:
</p>

<ul>
<li>
<p> version Shows the cluster state version.
</p>
</li>
<li>
<p> master_node Shows the elected master_node part of the response
</p>
</li>
<li>
<p> nodes Shows the nodes part of the response
</p>
</li>
<li>
<p> routing_table Shows the routing_table part of the response. If you supply
a comma separated list of indices, the returned output will only contain the
indices listed.
</p>
</li>
<li>
<p> metadata Shows the metadata part of the response. If you supply a comma
separated list of indices, the returned output will only contain the indices
listed.
</p>
</li>
<li>
<p> blocks Shows the blocks part of the response
</p>
</li>
</ul>
<p>Additional parameters that can be passed in:
</p>

<ul>
<li>
<p> metric A comma-separated list of metrics to display. Possible values: '_all',
'completion', 'docs', 'fielddata', 'filter_cache', 'flush', 'get', 'id_cache', 'indexing',
'merge', 'percolate', 'refresh', 'search', 'segments', 'store', 'warmer'
</p>
</li>
<li>
<p> completion_fields A comma-separated list of fields for completion metric (supports
wildcards)
</p>
</li>
<li>
<p> fielddata_fields A comma-separated list of fields for fielddata metric (supports
wildcards)
</p>
</li>
<li>
<p> fields A comma-separated list of fields for fielddata and completion metric (supports
wildcards)
</p>
</li>
<li>
<p> groups A comma-separated list of search groups for search statistics
</p>
</li>
<li>
<p> allow_no_indices Whether to ignore if a wildcard indices expression resolves into no
concrete indices. (This includes _all string or when no indices have been specified)
</p>
</li>
<li>
<p> expand_wildcards Whether to expand wildcard expression to concrete indices that are
open, closed or both.
</p>
</li>
<li>
<p> ignore_indices When performed on multiple indices, allows to ignore missing ones
(default: none)
</p>
</li>
<li>
<p> ignore_unavailable Whether specified concrete indices should be ignored when unavailable
(missing or closed)
</p>
</li>
<li>
<p> human Whether to return time and byte values in human-readable format.
</p>
</li>
<li>
<p> level Return stats aggregated at cluster, index or shard level. ('cluster', 'indices'
or 'shards', default: 'indices')
</p>
</li>
<li>
<p> types A comma-separated list of document types for the indexing index metric
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# connection setup
(x &lt;- connect())

cluster_settings(x)
cluster_health(x)

cluster_state(x)
cluster_state(x, metrics = "version")
cluster_state(x, metrics = "nodes")
cluster_state(x, metrics = c("version", "nodes"))
cluster_state(x, metrics = c("version", "nodes", 'blocks'))
cluster_state(x, "shakespeare", metrics = "metadata")
cluster_state(x, c("shakespeare", "flights"), metrics = "metadata")

cluster_stats(x)
cluster_pending_tasks(x)

body &lt;- '{
  "commands": [ 
    {
      "move": {
        "index" : "test", "shard" : 0,
        "from_node" : "node1", "to_node" : "node2"
      }
    },
    {
      "allocate_replica" : {
        "index" : "test", "shard" : 1, "node" : "node3"
      }
    }
  ]
}'
# cluster_reroute(x, body =  body)

cluster_health(x)
# cluster_health(x, wait_for_status = "yellow", timeout = "3s")

## End(Not run)
</code></pre>


</div>