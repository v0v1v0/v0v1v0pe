<div class="container">

<table style="width: 100%;"><tr>
<td>EEAaq_idw_map</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build a spatial interpolation map based on the Inverse Distance Weighting technique.</h2>

<h3>Description</h3>

<p><code>EEAaq_idw_map</code> recieves as input a <code>EEAaq_taggr_df</code> or a <code>EEAaq_taggr_df_sfc</code> class object and produces a
spatial interpolation map. Depending on the time frequency of the aggregation, multiple maps are generated, one for
each timestamp.
It may be exported as pdf, jpeg, png, gif and html.
</p>


<h3>Usage</h3>

<pre><code class="language-R">EEAaq_idw_map(
  data = NULL,
  pollutant = NULL,
  aggr_fun,
  bounds_level = NULL,
  distinct = FALSE,
  gradient = TRUE,
  idp = 2,
  nmax = NULL,
  maxdist = NULL,
  dynamic = FALSE,
  fill_NUTS_level = NULL,
  tile = "Esri.WorldGrayCanvas",
  save = NULL,
  filepath = NULL,
  width = 1280,
  height = 720,
  res = 144,
  delay = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an object of class <code>EEAaq_taggr_df</code> or <code>EEAaq_taggr_df_sfc</code>, which is the
output of the <code>EEAaq_time_aggregate</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pollutant</code></td>
<td>
<p>vector containing the pollutant for which to build the map. It must be one of the pollutants
contained in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggr_fun</code></td>
<td>
<p>charachter containing the aggregation function to use for computing the interpolation. It must
be one of the statistics contained in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds_level</code></td>
<td>
<p>character containing the NUTS level or LAU for which draw internal boundaries.
Admissible values are 'NUTS0', 'NUTS1', 'NUTS2', 'NUTS3', 'LAU'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distinct</code></td>
<td>
<p>logic value (T or F). If <code>TRUE</code>, each map generated is printed and saved in distinct pages
(for instance if <code>data</code> has a monthly frequency in a yearly time window, 12 distinct plots are generated).
If <code>FALSE</code> (the default), the maps are printed in a single page.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>logic value (T or F). If <code>TRUE</code> (the default) the maps generated are colored with a
continuous color scale. If <code>FALSE</code>, the color scale is discrete.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idp</code></td>
<td>
<p>numeric value that specify the inverse distance weighting power. For further information see
<code>idw</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmax</code></td>
<td>
<p>numeric value; specify the number of nearest observations that should be
used for the inverse distance weighting computing, where nearest is defined in terms of the
space of the spatial locations. By default, all observations are used. For further information see
<code>idw</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxdist</code></td>
<td>
<p>numeric value; only observations within a distance of <code>maxdist</code> from the prediction location
are used for the idw computation. By default, all observations are used.
If combined with <code>nmax</code>, both criteria apply.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dynamic</code></td>
<td>
<p>logic value (T or F). If <code>TRUE</code> the function creates a Leaflet map widget using
<b>htmlwidgets</b> (for further information see <code>leaflet</code>). If <code>FALSE</code> (the default)
the maps generated are static.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill_NUTS_level</code></td>
<td>
<p>character containing the NUTS level or LAU for which to aggregate the idw computing,
in order to obtain a uniform coloring inside each area at the specified level.
(For instance if <code>fill_NUTS_level = "LAU"</code>, each municipality is filled by the mean value of the pollutant
concentration, computed by the idw, of each pixel inside the respective municipality). Allowed values are
'NUTS0', 'NUTS1', 'NUTS2', 'NUTS3', 'LAU'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tile</code></td>
<td>
<p>character representing the name of the provider tile. To see the full list of the providers, run
<code>leaflet::providers</code>. For further information see <code>addProviderTiles</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save</code></td>
<td>
<p>character representing in which extension to save the map. Allowed values are 'jpeg', 'png', 'pdf'
(if <code>dynamic = FALSE</code>), 'gif' (if <code>dynamic = FALSE &amp; distinct = TRUE</code>), 'html' (if <code>dynamic = TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filepath</code></td>
<td>
<p>a character string giving the file path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width, height</code></td>
<td>
<p>the width and the height of the plot, expressed in pixels (by default <code>width = 1280, height = 720</code>).
This parameters are available only for <code>save</code> 'jpeg', 'png' and 'gif'.
For further information see <code>png</code> or <code>jpeg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res</code></td>
<td>
<p>the nominal resolution in ppi which will be recorded in the bitmap file, if a positive integer
(by default <code>res = 144</code>). This parameter is available only for <code>save</code> 'jpeg', 'png'.
For further information see <code>png</code> or <code>jpeg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delay</code></td>
<td>
<p>numeric value specifying the time to show each image in seconds, when <code>save = "gif"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logic value (T or F). If <code>TRUE</code> (the default) information about the function progress are printed.
If <code>FALSE</code> no message is printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>EEAaq_idw_map</code> create a spatial interpolation map, based on the Inverse Distance Weighting method (Shepard 1968).
This method starts from the available georeferenced data and estimates the value of the variable in the points
where it's unknown as a weighted average of the known values, where weights are given by an inverse function of the
distance of every point from the fixed stations.
The greater the distance of a point from a station, the smaller the weight assigned to the values of the respective
station for the computing of that unknown point.
Given the sampling plan <code class="reqn">s_{i}</code> for <code class="reqn">i=1,...,n</code>, which represent the location of the air quality stations,
the pollutant concentration value <code class="reqn">Y(s_i)=Y_i</code> represents the value of the pollutant concentration detected
by the site <code class="reqn">s_i</code> and <code class="reqn">u</code> is the point for which the value of the concentration in unknown.
</p>
<p style="text-align: center;"><code class="reqn">\hat{Y}(u) = \sum_{i=1}^{n} Y_i \omega_i(u), </code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">\omega_i(u) = \frac{g(d(s_i,u))}{\sum_{i=1}^{n}g(d(s_i,u))} </code>
</p>

<p>represent the weights assigned to each location <code class="reqn">s_i</code> and <code class="reqn">d(s_i,u)</code> is the distance between <code class="reqn">u</code>
and <code class="reqn">s_i</code>.
</p>


<h3>Value</h3>

<p>cosa restituisce la funzione
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data &lt;- EEAaq_get_data(zone_name = "Milano", NUTS_level = "LAU",
  pollutant = "PM10", from = 2023, to = 2023, ID = FALSE, verbose = TRUE)

#Monthly aggregation
t_aggr &lt;- EEAaq_time_aggregate(data = data, frequency = "monthly",
                                aggr_fun = c("mean", "min", "max"))

#12 maps are generated, one for each month
EEAaq_idw_map(data = t_aggr, pollutant = "PM10",
aggr_fun = "mean", distinct = TRUE,
gradient = TRUE, idp = 2,
dynamic = FALSE)

#Let's try to change the parameters fill_NUTS_level and dynamic
#Now we are going to use a dataset containing PM10 concentrations
#in Milan province (NUTS 3), during 2022
data &lt;- EEAaq_get_data(zone_name = "Milano", NUTS_level = "NUTS3",
  pollutant = "PM10", from = 2022, to = 2022)
#yearly aggregation
t_aggr &lt;- EEAaq_time_aggregate(data = data, frequency = "yearly",
  aggr_fun = "mean")
#Let's generate one dynamic map, containing the municipalities inside the Milan province
#filled with the mean concentration value for 2022, computed via idw:
EEAaq_idw_map(data = t_aggr, pollutant = "PM10", aggr_fun = "mean",
  distinct = TRUE, gradient = FALSE, dynamic = TRUE, fill_NUTS_level = "LAU")

</code></pre>


</div>