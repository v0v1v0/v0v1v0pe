<div class="container">

<table style="width: 100%;"><tr>
<td>invariance</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Measurement Invariance of <code>EGA</code> Structure</h2>

<h3>Description</h3>

<p>Estimates configural invariance using <code>bootEGA</code>
on all data (across groups) first. After configural variance is established,
then metric invariance is tested using the community structure that established
configural invariance (see <strong>Details</strong> for more information on this process)
</p>


<h3>Usage</h3>

<pre><code class="language-R">invariance(
  data,
  groups,
  structure = NULL,
  iter = 500,
  configural.threshold = 0.7,
  configural.type = c("parametric", "resampling"),
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  ncores,
  seed = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>Numeric or character vector (length = <code>nrow(data)</code>).
Group membership corresponding to each case in data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structure</code></td>
<td>
<p>Numeric or character vector (length = <code>ncol(data)</code>).
A vector representing the structure (numbers or labels for each item).
Can be theoretical factors or the structure detected by <code>EGA</code>.
If supplied, then configural invariance check is skipped (i.e., configural
invariance is assumed based on the given structure)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Numeric (length = 1).
Number of iterations to perform for the permutation.
Defaults to <code>500</code> (recommended)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>configural.threshold</code></td>
<td>
<p>Numeric (length = 1).
Value to use a threshold in <code>itemStability</code> to determine
which items should be removed during configural invariance (see <strong>Details</strong>
for more information).
Defaults to <code>0.70</code> (recommended)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>configural.type</code></td>
<td>
<p>Character (length = 1).
Type of bootstrap to use for configural invariance in <code>bootEGA</code>.
Defaults to <code>"parametric"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> — Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code>polychoric.matrix</code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> — Uses <code>cor_auto</code> to compute correlations.
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> — Pearson's correlation is computed for all
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> — Spearman's rank-order correlation is computed
for all variables regardless of categories
</p>
</li>
</ul>
<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> — Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> — Computes correlation for all complete cases in the dataset
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> — Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> — Computes the GLASSO with EBIC model selection.
See <code>EBICglasso.qgraph</code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> — Computes the TMFG method.
See <code>TMFG</code> for more details
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>Character or
 <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code>community.detection</code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> — See <code>cluster_leiden</code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> — By default, <code>"louvain"</code> will implement the Louvain algorithm using
the consensus clustering method (see <code>community.consensus</code>
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code>
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> — See <code>cluster_walktrap</code> for more details
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used?
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> — Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> — Applies the Leading Eigenvector algorithm
(<code>cluster_leading_eigen</code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023)
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> — Applies the Louvain algorithm (<code>cluster_louvain</code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Louvain solution is used; otherwise, regular EGA is used.
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Numeric (length = 1).
Number of cores to use in computing results.
Defaults to <code>ceiling(parallel::detectCores() / 2)</code> or half of your
computer's processing power.
Set to <code>1</code> to not use parallel computing
</p>
<p>If you're unsure how many cores your computer has,
then type: <code>parallel::detectCores()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>NULL</code> or random results.
Set for reproducible results.
See <a href="https://github.com/hfgolino/EGAnet/wiki/Reproducibility-and-PRNG">Reproducibility and PRNG</a>
for more details on random number generation in </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Boolean (length = 1).
Should progress be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to not display progress</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments that can be passed on to
<code>auto.correlate</code>,
<code>network.estimation</code>,
<code>community.detection</code>,
<code>community.consensus</code>,
<code>EGA</code>,
<code>bootEGA</code>, and
<code>net.loads</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In traditional psychometrics, measurement invariance is performed in
sequential testing from more flexible (more free parameters) to more rigid
(fewer free parameters) structures. Measurement invariance in network
psychometrics is no different.
</p>
<p><strong>Configural Invariance</strong>
</p>
<p>To establish configural invariance, the data are collapsed across groups
and a common sample structure is identified used <code>bootEGA</code>
and <code>itemStability</code>. If some variables have a replication
less than 0.70 in their assigned dimension, then they are considered unstable
and therefore not invariant. These variables are removed and this process
is repeated until all items are considered stable (replication values greater
than 0.70) or there are no variables left. If configural invariance cannot be
established, then the last run of results are returned and metric invariance
is not tested (because configural invariance is not met). Importantly, if any
variables <em>are</em> removed, then configural invariance is not met for the
original structure. Any removal would suggest only partial configural invariance
is met.
</p>
<p><strong>Metric Invariance</strong>
</p>
<p>The variables that remain after configural invariance are submitted to metric
invariance. First, each group estimates a network and then network loadings
(<code>net.loads</code>) are computed using the assigned
community memberships (determined during configural invariance). Then,
the difference between the assigned loadings of the groups is computed. This
difference represents the empirical values. Second, the group memberships
are permutated and networks are estimated based on the these permutated
groups for <code>iter</code> times. Then, network loadings are computed and
the difference between the assigned loadings of the group is computed, resulting
in a null distribution. The empirical difference is then compared against
the null distribution using a two-tailed <em>p</em>-value based on the number
of null distribution differences that are greater and less than the empirical
differences for each variable. Both uncorrected and false discovery rate
corrected <em>p</em>-values are returned in the results. Uncorrected <em>p</em>-values
are flagged for significance along with the direction of group differences.
</p>
<p><strong>Three or More Groups</strong>
</p>
<p>When there are 3 or more groups, the function performs metric invariance testing by comparing
all possible pairs of groups. Specifically:
</p>

<ul>
<li> <p><em>Pairwise Comparisons</em>: The function generates all possible unique group pairings
and computes the differences in network loadings for each pair. The same community structure,
derived from configural invariance or provided by the user, is used for all groups.
</p>
</li>
<li> <p><em>Permutation Testing</em>: For each group pair, permutation tests are conducted to
assess the statistical significance of the observed differences in loadings. <em>p</em>-values are
calculated based on the proportion of permuted differences that are greater than or equal to
the observed difference.
</p>
</li>
<li> <p><em>Result Compilation</em>: The function compiles the results for each pair including
both uncorrected (<code>p</code>) and FDR-corrected (Benjamini-Hochberg; <code>p_BH</code>) <em>p</em>-values,
and the direction of differences. It returns a summary of the findings for all pairwise comparisons.
</p>
</li>
</ul>
<p>This approach allows for a detailed examination of metric invariance across multiple groups,
ensuring that all potential differences are thoroughly assessed while maintaining the ability
to identify specific group differences.
</p>
<p>For more details, see Jamison, Golino, and Christensen (2023)
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>configural.results</code></td>
<td>
<p><code>bootEGA</code> results from
the final run that produced configural invariance. This output will be
output on the final run of unsuccessful configural invariance runs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memberships</code></td>
<td>
<p>Original memberships provided in <code>structure</code>
or from <code>EGA</code> if <code>structure = NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EGA</code></td>
<td>
<p>Original <code>EGA</code> results for the full sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>EGA</code> — <code>EGA</code> results for each group
</p>
</li>
<li> <p><code>loadings</code> — Network loadings (<code>net.loads</code>) for each group
</p>
</li>
<li> <p><code>loadingsDifference</code> — Difference between the dominant loadings of each group
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permutation</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>groups</code> — Permutated groups acorss iterations
</p>
</li>
<li> <p><code>loadings</code> — Network loadings (<code>net.loads</code>) for each group for each permutation
</p>
</li>
<li> <p><code>loadingsDifference</code> — Difference between the dominant loadings of each group for each permutation
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>results</code></td>
<td>
<p>Data frame of the results (which are printed)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Laura Jamison &lt;lj5yn@virginia.edu&gt;,
Hudson F. Golino &lt;hfg9s at virginia.edu&gt;, and
Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;,
</p>


<h3>References</h3>

<p><strong>Original implementation</strong> <br>
Jamison, L., Christensen, A. P., &amp; Golino, H. F. (2024).
Metric invariance in exploratory graph analysis via permutation testing.
<em>Methodology</em>, <em>20</em>(2), 144-186.
</p>


<h3>See Also</h3>

<p><code>plot.EGAnet</code> for plot usage in 
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load data
wmt &lt;- wmt2[-1,7:24]

# Groups
groups &lt;- rep(1:2, each = nrow(wmt) / 2)

## Not run: 
# Measurement invariance
results &lt;- invariance(wmt, groups, ncores = 2)

# Plot with uncorrected alpha = 0.05
plot(results, p_type = "p", p_value = 0.05)

# Plot with BH-corrected alpha = 0.10
plot(results, p_type = "p_BH", p_value = 0.10)
## End(Not run)

</code></pre>


</div>