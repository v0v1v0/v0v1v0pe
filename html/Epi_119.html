<div class="container">

<table style="width: 100%;"><tr>
<td>mcutLexis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Cut follow-up at multiple event dates and keep track of order of events 
</h2>

<h3>Description</h3>

<p>A generalization of <code>cutLexis</code> to the case where different
events may occur in any order (but at most once for each).
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcutLexis( L0, timescale = 1, wh,
              new.states = NULL,
        precursor.states = transient(L0),
              seq.states = TRUE,
              new.scales = NULL,
            ties.resolve = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L0</code></td>
<td>
<p>A Lexis object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timescale</code></td>
<td>
<p>Which time scale do the variables in <code>L0[,wh]</code>
refer to. Can be character or integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wh</code></td>
<td>
<p>Which variables contain the event dates. Character or
integer vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.states</code></td>
<td>
<p>Names of the events forming new states. If
<code>NULL</code> equal to the variable names from <code>wh</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precursor.states</code></td>
<td>
<p>Which states are precursor states. See
<code>cutLexis</code> for definition of precursor states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seq.states</code></td>
<td>
<p>Should the sequence of events be kept track of? That
is, should A-B be considered different from B-A. If <code>FALSE</code>,
the state with combined preceding events A and B will be called
A+B (alphabetically sorted).
</p>
<p>May also be supplied as character: <code>s</code> - sequence, keep
track of sequence of states occupied (same as <code>TRUE</code>), <code>u</code>
- unordered, keep track only of states visited (same as
<code>FALSE</code>) or <code>l</code>, <code>c</code> - last or current state, only
record the latest state visited. If given as character, only the
first letter converted to lower case is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.scales</code></td>
<td>
<p>Should we construct new time scales indicating the
time since each of the event occurrences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ties.resolve</code></td>
<td>
<p>Should tied event times be resolved by adding
random noise to tied event dates. If <code>FALSE</code> the function will
not accept that two events occur at the same time for a person
(ties). If <code>TRUE</code> a random quantity in the range
<code>c(-1,1)/100</code> will be added to all event times in all records
with at least one tie. If <code>ties.resolve</code> is numeric a random
quantity in the range <code>c(-1,1)*ties.resolve</code> will be added to
all event times in all records with at least one tie.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>Lexis</code> object with extra states created by
occurrence of a number of intermediate events.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code>cutLexis</code>,
<code>rcutLexis</code>,
<code>addCov.Lexis</code>,
<code>Lexis</code>,
<code>splitLexis</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># A dataframe of times
set.seed(563248)
dd &lt;- data.frame( id = 1:30,
                 doN = round(runif(30,-30, 0),1),
                 doE = round(runif(30,  0,20),1),
                 doX = round(runif(30, 50,60),1),
                 doD = round(runif(30, 50,60),1),
                 # these are the event times
                 doA = c(NA,21,NA,27,35,NA,52, 5,43,80,
                         NA,22,56,28,53,NA,51, 5,43,80,
                         NA,23,NA,33,51,NA,55, 5,43,80),
                 doB = c(NA,20,NA,53,27,NA, 5,52,34,83,
                         NA,20,23,37,35,NA,52, 8,33,NA,
                         25,NA,37,40,NA,NA,15,23,36,61) )

# set up a Lexis object with time from entry to death/exit
Lx &lt;- Lexis( entry = list(time=doE,
                           age=doE-doN),
              exit = list(time=pmin(doX,doD)),
       exit.status = factor(doD&lt;doX,labels=c("OK","D")),
              data = dd )
summary( Lx )

# cut the follow-up at dates doA and doB
L2 &lt;- mcutLexis( Lx, "time", wh=c("doA","doB"),
                 new.states = c("A","B"),
           precursor.states = "OK",
                 seq.states = TRUE,
                 new.scales = c("tfA","tfB") )
summary( L2 )
L2

# show the states
boxes( L2, boxpos=list(x=c(10,60,50,90,50,90),
                       y=c(50,50,90,90,10,10)),
           scale.R=100, show.BE=TRUE, DR.sep=c(" (",")"))


L3 &lt;- mcutLexis( Lx, "time", wh=c("doA","doB"),
                 new.states = c("A","B"),
           precursor.states = "OK",
                 seq.states = FALSE,
                 new.scales = c("tfA","tfB") )
summary( L3 )
boxes( L3, boxpos=list(x=c(10,50,50,90,50),
                       y=c(50,50,90,50,10)),
           show.R=FALSE, show.BE=TRUE )
</code></pre>


</div>