<div class="container">

<table style="width: 100%;"><tr>
<td>IdfObject</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create and Modify an EnergyPlus Object</h2>

<h3>Description</h3>

<p><code>IdfObject</code> is an abstraction of a single object in an Idf. It provides
more detail methods to modify object values and comments. An <code>IdfObject</code>
object can also be created using function <code>idf_object()</code> or from methods of a
parent Idf object, using <code style="white-space: pre;">⁠$object()⁠</code>, <code style="white-space: pre;">⁠$objects_in_class()⁠</code> and equivalent.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IdfObject-new"><code>IdfObject$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-version"><code>IdfObject$version()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-parent"><code>IdfObject$parent()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-id"><code>IdfObject$id()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-name"><code>IdfObject$name()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-group_name"><code>IdfObject$group_name()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-class_name"><code>IdfObject$class_name()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-definition"><code>IdfObject$definition()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-comment"><code>IdfObject$comment()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-value"><code>IdfObject$value()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-set"><code>IdfObject$set()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-value_possible"><code>IdfObject$value_possible()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-validate"><code>IdfObject$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-is_valid"><code>IdfObject$is_valid()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-value_relation"><code>IdfObject$value_relation()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-ref_to_object"><code>IdfObject$ref_to_object()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-ref_by_object"><code>IdfObject$ref_by_object()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-ref_to_node"><code>IdfObject$ref_to_node()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-has_ref_to"><code>IdfObject$has_ref_to()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-has_ref_by"><code>IdfObject$has_ref_by()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-has_ref_node"><code>IdfObject$has_ref_node()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-has_ref"><code>IdfObject$has_ref()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-to_table"><code>IdfObject$to_table()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-to_string"><code>IdfObject$to_string()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-print"><code>IdfObject$print()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-clone"><code>IdfObject$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-IdfObject-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create an <code>IdfObject</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$new(object, class = NULL, parent)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>object</code></dt>
<dd>
<p>An integer specifying an object ID.</p>
</dd>
<dt><code>class</code></dt>
<dd>
<p>An integer specifying a class index.</p>
</dd>
<dt><code>parent</code></dt>
<dd>
<p>An Idf object specifying the parent object.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>It is not recommended to directly use <code style="white-space: pre;">⁠$new()⁠</code> method to create an
<code>IdfObject</code> object, instead considering to use idf_object,
<a href="../../eplusr/html/Idf.html#method-object"><code>Idf$object()</code></a>
and other equivalent to create <code>IdfObject</code> objects. They provide
more user-friendly interfaces. <code style="white-space: pre;">⁠$new()⁠</code> is a lower level API which is
mainly used inside methods in other classes.
</p>



<h5>Returns</h5>

<p>An <code>IdfObject</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# example model shipped with eplusr from EnergyPlus v8.8
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8
idf &lt;- read_idf(path_idf, use_idd(8.8, "auto"))

roof &lt;- IdfObject$new(26, parent = idf)

# get the IdfObject of material named "C5 - 4 IN HW CONCRETE"
mat &lt;- idf$Material[["C5 - 4 IN HW CONCRETE"]]
}

</pre>
</div>


<hr>
<a id="method-IdfObject-version"></a>



<h4>Method <code>version()</code>
</h4>

<p>Get the version of parent <code>Idf</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$version()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$version()⁠</code> returns the version of parent <code>Idf</code> in a
<code>base::numeric_version()</code> format. This makes it easy to direction
compare versions of different <code>IdfObject</code>s, e.g. <code>idfobj$version() &gt; 8.6</code> or
<code>idfobj1$version() &gt; idfobj2$version()</code>.
</p>



<h5>Returns</h5>

<p>A <code>base::numeric_version()</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get version
roof$version()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-parent"></a>



<h4>Method <code>parent()</code>
</h4>

<p>Get parent Idf
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$parent()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$parent()⁠</code> returns parent Idf object.
</p>



<h5>Returns</h5>

<p>A Idf object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$parent()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-id"></a>



<h4>Method <code>id()</code>
</h4>

<p>Get the unique ID for current object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$id()</pre></div>



<h5>Details</h5>

<p>In Idf, each object is assigned with an integer as an universally
unique identifier (UUID) in the context of current Idf. UUID is
not reused even if the object associated is deleted.
</p>
<p><code style="white-space: pre;">⁠$id()⁠</code> returns an integer of current object unique ID.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$id()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-name"></a>



<h4>Method <code>name()</code>
</h4>

<p>Get the name for current object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$name()</pre></div>



<h5>Details</h5>

<p>In <code>Idf</code>, each object is assigned with a single string as the name
for it, if the class it belongs to has name attribute, e.g. class
<code>RunPeriod</code>, <code>Material</code> and etc. That name should be unique among all
objects in that class. EnergyPlus will fail with an error if
duplications are found among object names in a class.
</p>
<p><code style="white-space: pre;">⁠$name()⁠</code> returns a single string of current object name. If
specified class does not have name attribute, <code>NA</code> is returned.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$name()

# NA will be returned if the class does not have name attribute. For example,
# "Version" class
idf$Version$name()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-group_name"></a>



<h4>Method <code>group_name()</code>
</h4>

<p>Get name of group for current object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$group_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$group_name()⁠</code> returns a single string of group name current
<code>IdfObject</code> belongs to.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$group_name()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-class_name"></a>



<h4>Method <code>class_name()</code>
</h4>

<p>Get name of class for current object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$class_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$class_name()⁠</code> returns a single string of class name current
<code>IdfObject</code> belongs to.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$class_name()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-definition"></a>



<h4>Method <code>definition()</code>
</h4>

<p>Get the IddObject object for current class.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$definition()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$definition()⁠</code> returns an IddObject of current class. IddObject
contains all data used for parsing and creating current <code>IdfObject</code>.
For details, please see IddObject class.
</p>



<h5>Returns</h5>

<p>An IddObject object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$definition()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-comment"></a>



<h4>Method <code>comment()</code>
</h4>

<p>Get and modify object comments
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$comment(comment, append = TRUE, width = 0L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>comment</code></dt>
<dd>
<p>A character vector.
</p>

<ul>
<li>
<p> If missing, current comments are returned. If there is no
comment in current <code>IdfObject</code>, <code>NULL</code> is returned.
</p>
</li>
<li>
<p> If <code>NULL</code>, all comments in current <code>IdfObject</code> is deleted.
</p>
</li>
<li>
<p> If a character vector, it is inserted as comments depending on
the <code>append</code> value.
</p>
</li>
</ul>
</dd>
<dt><code>append</code></dt>
<dd>
<p>Only applicable when <code>commment</code> is a character vector.
Default: <code>FALSE</code>.
</p>

<ul>
<li>
<p> If <code>NULL</code>, existing comments is deleted before adding <code>comment</code>.
</p>
</li>
<li>
<p> If <code>TRUE</code>, comment will be appended to existing comments.
</p>
</li>
<li>
<p> If <code>FALSE</code>, <code>comment</code> is prepended to existing currents.
</p>
</li>
</ul>
</dd>
<dt><code>width</code></dt>
<dd>
<p>A positive integer giving the target width for wrapping
inserted <code>comment</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$comment()⁠</code> returns current <code>IdfObject</code> comments if <code>comment</code> is not
given, or modifies current <code>IdfObject</code> comments if <code>comment</code> is given.
If no comments found, <code>NULL</code> is returned.
</p>



<h5>Returns</h5>

<p>If calling without any argument, a character vector or <code>NULL</code>
(if no comments) is return. Otherwise, the modified object itself.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get object comments
roof$comment()

# add new object comments
roof$comment(c("This is a material named `WD01`", "This object has an ID of 47"))
roof$comment()

# append new comments
roof$comment("This is an appended comment")
roof$comment()

# prepend new comments
roof$comment("This is a prepended comment", append = FALSE)
roof$comment()

# wrap long comments
roof$comment("This is a very long comment that is needed to be wrapped.", width = 30)
roof$comment()

# delete old comments and add new one
roof$comment("This is the only comment", append = NULL)
roof$comment()

# delete all comments
roof$comment(NULL)
roof$comment()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-value"></a>



<h4>Method <code>value()</code>
</h4>

<p>Get object field values.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$value(which = NULL, all = FALSE, simplify = FALSE, unit = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>all</code></dt>
<dd>
<p>If <code>TRUE</code>, values of all possible fields in current class
the <code>IdfObject</code> belongs to are returned. Default: <code>FALSE</code></p>
</dd>
<dt><code>simplify</code></dt>
<dd>
<p>If <code>TRUE</code>, values of fields are converted into
characters and the converted character vector is returned.</p>
</dd>
<dt><code>unit</code></dt>
<dd>
<p>If <code>TRUE</code>, values of numeric fields are assigned with
units using <code>units::set_units()</code> if applicable. Default:
<code>FALSE</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$value()⁠</code> takes an integer vector of valid field indexes or a
character vector of valid field names, and returns a named list
containing values of specified fields when <code>simplify</code> is <code>FALSE</code> and
a character vector when <code>simplify</code> is <code>TRUE</code>.
</p>
<p>eplusr also provides custom S3 method of <code>$</code> and <code>[[</code> which make
it more convenient to get a single value of current <code>IdfObject</code>.
Basically, <code>idfobj$FieldName</code> and <code>idfobj[[Field]]</code> is
equivalent to <code>idfobj$value(FieldName)[[1]]</code> and
<code>idfobj$value(Field)[[1]]</code>.
</p>



<h5>Returns</h5>

<p>A named list.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all existing field values
str(mat$value())

# get values of field 1, 3, 5
str(mat$value(c(1, 3, 5)))

# get character format values instead of a named list
mat$value(c(1, 3, 5), simplify = TRUE)

# get values of all field even those that are not set
str(roof$value())
str(roof$value(all = TRUE))

# get field values using shortcuts
mat$Roughness
mat[["Specific_Heat"]]
mat[c(1,2)]
mat[c("Name", "Density")]
}

</pre>
</div>


<hr>
<a id="method-IdfObject-set"></a>



<h4>Method <code>set()</code>
</h4>

<p>Modify object field values.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$set(..., .default = TRUE, .empty = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>New field value definitions in <code>field = value</code> format or a
single list in format:
</p>
<div class="sourceCode"><pre>list(field1 = value1, field2 = value2)
</pre></div>
</dd>
<dt><code>.default</code></dt>
<dd>
<p>If <code>TRUE</code>, default values are used for those blank
fields if possible. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>.empty</code></dt>
<dd>
<p>If <code>TRUE</code>, trailing empty fields are kept. Default: <code>FALSE</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$set()⁠</code> takes new field value definitions in <code>field = value</code> format
or in a single list format, sets new values for fields specified, and
returns the modified <code>IdfObject</code>. Unlike <code style="white-space: pre;">⁠$set()⁠</code> method in Idf
class, the special element <code>.comment</code> is <strong>not allowed</strong>. To modify
object comments, please use <code style="white-space: pre;">⁠$comment()⁠</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# set field values
mat$set(name = "new_name", Thickness = 0.02)
mat[c("Name", "Thickness")]

# When `default` argument is set to TRUE and input field values are empty, i.e.
# NULL, the field values will be reset to defaults.
mat[c("Thermal Absorptance", "Solar Absorptance")]

mat$set(visible_absorptance = NULL, Solar_Absorptance = NULL, .default = TRUE)
mat[c("Visible Absorptance", "Solar Absorptance")]

# set field values using shortcuts
mat$Name &lt;- "another_name"
mat$Name
mat[["Thickness"]] &lt;- 0.019
mat$Thickness
}

</pre>
</div>


<hr>
<a id="method-IdfObject-value_possible"></a>



<h4>Method <code>value_possible()</code>
</h4>

<p>Get possible object field values.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$value_possible(
  which = NULL,
  type = c("auto", "default", "choice", "range", "source")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>type</code></dt>
<dd>
<p>A character vector. What types of possible values should
be returned. Should be one of or a combination of <code>"auto"</code>,
<code>"default"</code>, <code>"choice"</code>, <code>"range"</code> and <code>"source"</code>. Default:
All of those.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$value_possible()⁠</code> takes an integer vector of valid field indexes or a character
vector of valid field names, and returns all possible values for specified
fields. For a specific field, there are 5 types of possible values:
</p>

<ul>
<li> <p><code>auto</code>: Whether the field can be filled with <code>Autosize</code> and
<code>Autocalculate</code>. This field attribute can also be retrieved using:
</p>
<div class="sourceCode"><pre>idfobj$definition()$is_autosizable_field()
idfobj$definition()$is_autocalculatable_field()
</pre></div>
</li>
<li> <p><code>default</code>: The default value. This value can also be retrieved using
<code>idfobj$defintion()$field_default()</code>.
</p>
</li>
<li> <p><code>choice</code>: The choices which the field can be set. This value can also be
retrieved using <code>idfobj$definition()$field_choice()</code>.
</p>
</li>
<li> <p><code>range</code>: The range which the field value should fall in. This range can
also be retrieved using <code>idfobj$definition()$field_range()</code>.
</p>
</li>
<li> <p><code>source</code>: All values from other objects that current field can refer to.
</p>
</li>
</ul>
<h5>Returns</h5>

<p><code style="white-space: pre;">⁠$value_possible()⁠</code> returns an <code>IdfValuePossible</code> object
which is a data.table with at most 15
columns:
</p>

<ul>
<li> <p><code>class_id</code>: index of class that current <code>IdfObject</code> belongs to
</p>
</li>
<li> <p><code>class_name</code>: name of class that current <code>IdfObject</code> belongs to
</p>
</li>
<li> <p><code>object_id</code>: ID of current <code>IdfObject</code>
</p>
</li>
<li> <p><code>object_name</code>: name of current <code>IdfObject</code>
</p>
</li>
<li> <p><code>field_id</code>: indexes (at Idd level) of object fields specified
</p>
</li>
<li> <p><code>field_index</code>: indexes of object fields specified
</p>
</li>
<li> <p><code>field_name</code>: names (without units) of object fields specified
</p>
</li>
<li> <p><code>value_id</code>: value indexes (at Idf level) of object fields specified
</p>
</li>
<li> <p><code>value_chr</code>: values (converted to characters) of object fields specified
</p>
</li>
<li> <p><code>value_num</code>: values (converted to numbers in SI units) of object fields
specified.
</p>
</li>
<li> <p><code>auto</code>: Exists only when <code>"auto"</code> is one of <code>type</code>. Character type.
Possible values are: <code>"Autosize"</code>, <code>"Autocalculate"</code> and <code>NA</code> (if current
field is neither <code>autosizable</code> nor <code>autocalculatable</code>).
</p>
</li>
<li> <p><code>default</code>: Exists only when <code>"default"</code> is one of <code>type</code>. List type. The
default value of current field. The value is converted into number if
corresponding field type yells so. Note that if current field is a numeric
field but the default value is <code>"Autosize"</code> or <code>"Autocalculate"</code>, it is
left as it is, leaving the returned type being a string instead of a
number.
</p>
</li>
<li> <p><code>range</code>: Exists only when <code>"range"</code> is one of <code>type</code>. List type. The range
that field value should fall in. Every range has four components: <code>minimum</code>
(lower limit), <code>lower_incbounds</code> (<code>TRUE</code> if the lower limit should be
included), <code>maximum</code> (upper limit), and <code>upper_incbounds</code> (<code>TRUE</code> if the
upper limit should be included). For fields of character type, empty lists
are returned. For fields of numeric types with no specified ranges,
<code>minimum</code> is set to <code>-Inf</code>, <code>lower_incbounds</code> is set to FALSE, <code>upper</code> is
set to <code>Inf</code>, and <code>upper_incbounds</code> is set to FALSE. The field range is
printed in number interval denotation.
</p>
</li>
<li> <p><code>source</code>: Exists only when <code>"source"</code> is one of <code>type</code>. List type. Each
element is a character vector which includes all values from other objects
that current field can use as sources and refers to.
</p>
</li>
</ul>
<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$value_possible()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-validate"></a>



<h4>Method <code>validate()</code>
</h4>

<p>Check possible object field value errors
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$validate(level = eplusr_option("validate_level"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>level</code></dt>
<dd>
<p>One of <code>"none"</code>, <code>"draft"</code>, <code>"final"</code> or a list of 10
elements with same format as <code>custom_validate()</code> output.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$validate()⁠</code> checks if there are errors in current <code>IdfObject</code> object
under specified validation level and returns an <code>IdfValidity</code> object.
</p>
<p><code style="white-space: pre;">⁠$validate()⁠</code> is useful to help avoid some common errors before
running the model. By default, validation is performed when calling
all methods that modify objects, e.g.
<a href="../../eplusr/html/IdfObject.html#method-set"><code>$set()</code></a>
and etc.
</p>
<p>In total, there are 10 different validate checking components:
</p>

<ul>
<li> <p><code>required_object</code>: Check if required objects are missing in current
<code>Idf</code>.
</p>
</li>
<li> <p><code>unique_object</code>: Check if there are multiple objects in one
unique-object class. An unique-object class means that there should
be at most only one object existing in that class.
</p>
</li>
<li> <p><code>unique_name</code>: Check if all objects in each class have unique names.
</p>
</li>
<li> <p><code>extensible</code>: Check if all fields in an extensible group have
values. An extensible group is a set of fields that should be
treated as a whole, such like the X, Y and Z vertices of a building
surfaces. An extensible group should be added or deleted together.
<code>extensible</code> component checks if there are some, but not all,
fields in an extensible group are empty.
</p>
</li>
<li> <p><code>required_field</code>: Check if all required fields have values.
</p>
</li>
<li> <p><code>auto_field</code>: Check if all fields filled with value <code>"Autosize"</code> and
<code>"Autocalculate"</code> are actual autosizable and autocalculatable
fields or not.
</p>
</li>
<li> <p><code>type</code>: Check if all fields have value types complied with their
definitions, i.e. character, numeric and integer fields should be
filled with corresponding type of values.
</p>
</li>
<li> <p><code>choice</code>: Check if all choice fields are filled with valid choice
values.
</p>
</li>
<li> <p><code>range</code>: Check if all numeric fields have values within prescibed
ranges.
</p>
</li>
<li> <p><code>reference</code>: Check if all fields whose values refer to other fields
are valid.
</p>
</li>
</ul>
<p>The <code>level</code> argument controls what checkings should be performed.
<code>level</code> here is just a list of 10 element which specify the toggle
status of each component. You can use helper <code>custom_validate()</code> to
get that list and pass it directly to <code>level</code>.
</p>
<p>There are 3 predefined validate level that indicates different
combinations of checking components, i.e. <code>none</code>, <code>draft</code> and
<code>final</code>. Basically, <code>none</code> level just does not perform any
checkings; <code>draft</code> includes 5 components, i.e. <code>auto_field</code>, <code>type</code>,
<code>unique_name</code>, <code>choice</code> and <code>range</code>; and <code>final</code> level includes all
10 components. You can always get what components each level contains
using <code>level_checks()</code>. By default, the result from
<code>eplusr_option("validate_level")</code> is passed to <code>level</code>. If not set,
<code>final</code> level is used.
</p>
<p>Underneath, an <code>IdfValidity</code> object which <code style="white-space: pre;">⁠$validate()⁠</code> returns is a
list of 13 element as shown below. Each element or several elements
represents the results from a single validation checking component.
</p>

<ul>
<li> <p><code>missing_object</code>: Result of <code>required_object</code> checking.
</p>
</li>
<li> <p><code>duplicate_object</code>: Result of <code>unique_object</code> checking.
</p>
</li>
<li> <p><code>conflict_name</code>: Result of <code>unique_name</code> checking.
</p>
</li>
<li> <p><code>incomplete_extensible</code>: Result of <code>extensible</code> checking.
</p>
</li>
<li> <p><code>missing_value</code>: Result of <code>required_field</code> checking.
</p>
</li>
<li> <p><code>invalid_autosize</code>: Result of <code>auto_field</code> checking for invalid
<code>Autosize</code> field values.
</p>
</li>
<li> <p><code>invalid_autocalculate</code>: Result of <code>auto_field</code> checking for
invalid <code>Autocalculate</code> field values.
</p>
</li>
<li> <p><code>invalid_character</code>: Result of <code>type</code> checking for invalid
character field values.
</p>
</li>
<li> <p><code>invalid_numeric</code>: Result of <code>type</code> checking for invalid
numeric field values.
</p>
</li>
<li> <p><code>invalid_integer</code>: Result of <code>type</code> checking for invalid
integer field values.
</p>
</li>
<li> <p><code>invalid_choice</code>: Result of <code>choice</code> checking.
</p>
</li>
<li> <p><code>invalid_range</code>: Result of <code>range</code> checking.
</p>
</li>
<li> <p><code>invalid_reference</code>: Result of <code>reference</code> checking.
</p>
</li>
</ul>
<p>Except <code>missing_object</code>, which is a character vector of class names
that are missing, all other elements are
data.table with 9 columns containing data
of invalid field values:
</p>

<ul>
<li> <p><code>object_id</code>: IDs of objects that contain invalid values
</p>
</li>
<li> <p><code>object_name</code>: names of objects that contain invalid values
</p>
</li>
<li> <p><code>class_id</code>: indexes of classes that invalid objects belong to
</p>
</li>
<li> <p><code>class_name</code>: names of classes that invalid objects belong to
</p>
</li>
<li> <p><code>field_id</code>: indexes (at Idd level) of object fields that are invalid
</p>
</li>
<li> <p><code>field_index</code>: indexes of object fields in corresponding that are invalid
</p>
</li>
<li> <p><code>field_name</code>: names (without units) of object fields that are invalid
</p>
</li>
<li> <p><code>units</code>: SI units of object fields that are invalid
</p>
</li>
<li> <p><code>ip_units</code>: IP units of object fields that are invalid
</p>
</li>
<li> <p><code>type_enum</code>: An integer vector indicates types of invalid fields
</p>
</li>
<li> <p><code>value_id</code>: indexes (at Idf level) of object field values that are invalid
</p>
</li>
<li> <p><code>value_chr</code>: values (converted to characters) of object fields that are
invalid
</p>
</li>
<li> <p><code>value_num</code>: values (converted to numbers in SI units) of object fields
that are invalid
</p>
</li>
</ul>
<p>Knowing the internal structure of <code>IdfValidity</code>, it is easy to extract
invalid IdfObjects you interested in. For example, you can get all IDs of
objects that contain invalid value references using
<code>model$validate()$invalid_reference$object_id</code>. Then using
<a href="../../eplusr/html/IdfObject.html#method-set"><code>$set()</code></a>
method to correct them.
</p>
<p>Different validate result examples are shown below:
</p>

<ul>
<li>
<p> No error is found:
</p>
<div class="sourceCode"><pre>v No error found.
</pre></div>
<p>Above result shows that there is no error found after conducting all
validate checks in specified validate level.
</p>
</li>
<li>
<p> Errors are found:
</p>
<div class="sourceCode"><pre> x [2] Errors found during validation.
=========================================================================

-- [2] Invalid Autocalculate Field --------------------------------------
   Fields below cannot be `autocalculate`:

    Class: &lt;AirTerminal:SingleDuct:VAV:Reheat&gt;
    \- Object [ID:176] &lt;SPACE5-1 VAV Reheat&gt;
       +- 17: AUTOCALCULATE, !- Maximum Flow per Zone Floor Area During Reheat {m3/s-m2}
       \- 18: AUTOCALCULATE; !- Maximum Flow Fraction During Reheat
</pre></div>
<p>Above result shows that after all validate components
performed under current validate level, 2 invalid field values
are found. All of them are in a object named <code style="white-space: pre;">⁠SPACE5-1 VAV Reheat⁠</code>
with ID <code>176</code>. They are invalid because those two fields do not
have an autocalculatable attribute but are given <code>AUTOCALCULATE</code>
value. Knowing this info, one simple way to fix the
error is to correct those two fields by doing:
</p>
<div class="sourceCode"><pre>idf$set(..176 =
    list(`Maximum Flow per Zone Floor Area During Reheat` = "autosize",
         `Maximum Flow Fraction During Reheat` = "autosize"
    )
)
</pre></div>
</li>
</ul>
<h5>Returns</h5>

<p>An <code>IdfValidity</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$validate()

# check at predefined validate level
mat$validate("none")
mat$validate("draft")
mat$validate("final")

# custom validate checking components
mat$validate(custom_validate(auto_field = TRUE, choice = TRUE))
}

</pre>
</div>


<hr>
<a id="method-IdfObject-is_valid"></a>



<h4>Method <code>is_valid()</code>
</h4>

<p>Check if there is any error in current object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$is_valid(level = eplusr_option("validate_level"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>level</code></dt>
<dd>
<p>One of <code>"none"</code>, <code>"draft"</code>, <code>"final"</code> or a list of 10
elements with same format as <code>custom_validate()</code> output.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$is_valid()⁠</code> returns <code>TRUE</code> if there is no error in current <code>IdfObject</code>
object under specified validation level and <code>FALSE</code> otherwise.
</p>
<p><code style="white-space: pre;">⁠$is_valid()⁠</code> checks if there are errors in current <code>IdfObject</code> object
under specified validation level and returns <code>TRUE</code> or <code>FALSE</code>
accordingly. For detailed description on validate checking, see
<a href="../../eplusr/html/IdfObject.html#method-validate"><code>$validate()</code></a>
documentation above.
</p>



<h5>Returns</h5>

<p>A single logical value of <code>TRUE</code> or <code>FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$is_valid()

mat$definition()$field_range("Density")
eplusr_option(validate_level = "none") # have to set validate to "none" to do so
mat$Density &lt;- -1
eplusr_option(validate_level = "final") # change back to "final" validate level
mat$is_valid()

# check at predefined validate level
mat$is_valid("none")
mat$is_valid("draft")
mat$is_valid("final")

# custom validate checking components
mat$is_valid(custom_validate(auto_field = TRUE, choice = TRUE))
}

</pre>
</div>


<hr>
<a id="method-IdfObject-value_relation"></a>



<h4>Method <code>value_relation()</code>
</h4>

<p>Get value relations
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$value_relation(
  which = NULL,
  direction = c("all", "ref_to", "ref_by", "node"),
  object = NULL,
  class = NULL,
  group = NULL,
  depth = 0L,
  keep = FALSE,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>direction</code></dt>
<dd>
<p>The relation direction to extract. Should be either
<code>"all"</code>, <code>"ref_to"</code> or "ref_by".</p>
</dd>
<dt><code>object</code></dt>
<dd>
<p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt>
<dd>
<p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt>
<dd>
<p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
<dt><code>keep</code></dt>
<dd>
<p>If <code>TRUE</code>, all input fields are returned regardless they
have any relations with other objects or not. If <code>FALSE</code>, only
fields in input that have relations with other objects are
returned. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>class_ref</code></dt>
<dd>
<p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">⁠Component 1 Name⁠</code> is treated as referenced by
<code style="white-space: pre;">⁠Component 1 Object Type⁠</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Many fields in Idd can be referred by others. For example, the
<code style="white-space: pre;">⁠Outside Layer⁠</code> and other fields in <code>Construction</code> class refer to the
<code>Name</code> field in <code>Material</code> class and other material related classes.
Here it means that the <code style="white-space: pre;">⁠Outside Layer⁠</code> field <strong>refers to</strong> the <code>Name</code>
field and the <code>Name</code> field is <strong>referred by</strong> the <code style="white-space: pre;">⁠Outside Layer⁠</code>. In
EnergyPlus, there is also a special type of field called <code>Node</code>,
which together with <code>Branch</code> and <code>BranchList</code> define the topography
of the HVAC connections. A outlet node of a component can be referred
by another component as its inlet node, but can also exists
independently, such as zone air node.
</p>
<p><code style="white-space: pre;">⁠$value_relation()⁠</code> provides a simple interface to get this kind of
relation. It takes field indexes or field names, together a relation
direction, and returns an <code>IdfRelation</code> object which contains data
presenting such relation described above. For instance, if
<code>idfobj$value_relation("Name", "ref_by")</code> gives results below:
</p>
<div class="sourceCode"><pre>-- Referred by Others ------------------------
  \- 1: "WALL-1";      !- Name
     ^~~~~~~~~~~~~~~~~~~~~~~~~
     \- Class: &lt;BuildingSurface:Detailed&gt;
        \- Object [ID:3] &lt;WALL-1PF&gt;
           \- 3: "WALL-1";      !- Construction Name
</pre></div>
<p>This means that the value <code>"WALL-1"</code> of field <code>Name</code> is referred by
field <code style="white-space: pre;">⁠Construction Name⁠</code> in a surface named <code style="white-space: pre;">⁠WALL-1PF⁠</code>. All those
objects can be further easily extracted using <code style="white-space: pre;">⁠$ref_by_object()⁠</code>
method.
</p>
<p>Note that <code style="white-space: pre;">⁠$value_relation()⁠</code> shows all fields specified, even some of them
may do not have relation.
</p>



<h5>Returns</h5>

<p>An <code>IdfRelation</code> object, which is a list of 3
<code>data.table::data.table()</code>s named <code>ref_to</code>, <code>ref_by</code> and <code>node</code>.
Each <code>data.table::data.table()</code> contains 24 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# check each layer's reference of a construction named FLOOR
roof$value_relation("zone name", "ref_to")

# check where is this construction being used
roof$value_relation("name", direction = "ref_by")
}

</pre>
</div>


<hr>
<a id="method-IdfObject-ref_to_object"></a>



<h4>Method <code>ref_to_object()</code>
</h4>

<p>Extract multiple <code>IdfObject</code> objects referred by specified field values
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$ref_to_object(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  depth = 0L,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt>
<dd>
<p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt>
<dd>
<p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt>
<dd>
<p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
<dt><code>class_ref</code></dt>
<dd>
<p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">⁠Component 1 Name⁠</code> is treated as referenced by
<code style="white-space: pre;">⁠Component 1 Object Type⁠</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">⁠$ref_to_object()⁠</code> takes an integer vector of field indexes or a
character vector of field names, and returns a list of <code>IdfObject</code>s
that specified fields refer to.
</p>



<h5>Returns</h5>

<p>A named list of <code>IdfObject</code> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get other objects that this object refereces
mat$ref_to_object() # not referencing other objects
}

</pre>
</div>


<hr>
<a id="method-IdfObject-ref_by_object"></a>



<h4>Method <code>ref_by_object()</code>
</h4>

<p>Extract multiple <code>IdfObject</code> objects referring to specified field values
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$ref_by_object(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  depth = 0L,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt>
<dd>
<p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt>
<dd>
<p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt>
<dd>
<p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
<dt><code>class_ref</code></dt>
<dd>
<p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">⁠Component 1 Name⁠</code> is treated as referenced by
<code style="white-space: pre;">⁠Component 1 Object Type⁠</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">⁠$ref_by_object()⁠</code> takes an integer vector of field indexes or a
character vector of field names, and returns a list of <code>IdfObject</code>s
that refer to specified fields.
</p>



<h5>Returns</h5>

<p>A named list of <code>IdfObject</code> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get other objects that reference this object
mat$ref_by_object() # referenced by construction "FLOOR"
}

</pre>
</div>


<hr>
<a id="method-IdfObject-ref_to_node"></a>



<h4>Method <code>ref_to_node()</code>
</h4>

<p>Extract multiple <code>IdfObject</code> objects referring to same nodes
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$ref_to_node(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  depth = 0L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt>
<dd>
<p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt>
<dd>
<p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt>
<dd>
<p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">⁠$ref_to_node()⁠</code> takes an integer vector of field indexes or a
character vector of field names, and returns a list of <code>IdfObject</code>s
whose nodes are referred by specified fields.
</p>



<h5>Returns</h5>

<p>A named list of <code>IdfObject</code> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
if (is_avail_eplus(8.8)) {
    path &lt;- file.path(eplus_config(8.8)$dir, "ExampleFiles/5Zone_Transformer.idf")
    idf_5z &lt;- read_idf(path)
    idf_5z$NodeList$OutsideAirInletNodes$ref_to_node()
}
}

</pre>
</div>


<hr>
<a id="method-IdfObject-has_ref_to"></a>



<h4>Method <code>has_ref_to()</code>
</h4>

<p>Check if object field values refer to others
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$has_ref_to(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  recursive = FALSE,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt>
<dd>
<p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt>
<dd>
<p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>recursive</code></dt>
<dd>
<p>If <code>TRUE</code>, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>class_ref</code></dt>
<dd>
<p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">⁠Component 1 Name⁠</code> is treated as referenced by
<code style="white-space: pre;">⁠Component 1 Object Type⁠</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">⁠$has_ref_to()⁠</code> takes an integer vector of field indexes or a
character vector of field names, and returns a logical vector showing
whether specified fields refer to other object values or not.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as specified field.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$has_ref_to()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-has_ref_by"></a>



<h4>Method <code>has_ref_by()</code>
</h4>

<p>Check if object field values are referred by others
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$has_ref_by(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  recursive = FALSE,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt>
<dd>
<p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt>
<dd>
<p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>recursive</code></dt>
<dd>
<p>If <code>TRUE</code>, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>class_ref</code></dt>
<dd>
<p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">⁠Component 1 Name⁠</code> is treated as referenced by
<code style="white-space: pre;">⁠Component 1 Object Type⁠</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">⁠Component 1 Object Type⁠</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">⁠$has_ref_by()⁠</code> takes an integer vector of field indexes or a
character vector of field names, and returns a logical vector showing
whether there are other object values ref to specified fields.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as specified field.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$has_ref_by()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-has_ref_node"></a>



<h4>Method <code>has_ref_node()</code>
</h4>

<p>Check if object field values refer to other nodes
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$has_ref_node(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  recursive = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt>
<dd>
<p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt>
<dd>
<p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>recursive</code></dt>
<dd>
<p>If <code>TRUE</code>, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. Default: <code>FALSE</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">⁠$has_ref_node()⁠</code> takes an integer vector of field indexes or a
character vector of field names, and returns a logical vector showing
whether specified fields refer to other objects' nodes.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as specified field.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$has_ref_node()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-has_ref"></a>



<h4>Method <code>has_ref()</code>
</h4>

<p>Check if object field values refer to or are referred by others
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$has_ref(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  recursive = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt>
<dd>
<p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt>
<dd>
<p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>recursive</code></dt>
<dd>
<p>If <code>TRUE</code>, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. Default: <code>FALSE</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">⁠$has_ref()⁠</code> takes an integer vector of field indexes or a character
vector of field names, and returns a logical vector showing whether
there are other object values ref to specified field values or
specified field values refer to other object values or specified
field values refer to other objects' nodes.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as specified field.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# check if having any referenced objects or is referenced by other objects
mat$has_ref()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-to_table"></a>



<h4>Method <code>to_table()</code>
</h4>

<p>Format <code>IdfObject</code> as a data.frame
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$to_table(
  string_value = TRUE,
  unit = TRUE,
  wide = FALSE,
  all = FALSE,
  group_ext = c("none", "group", "index")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string_value</code></dt>
<dd>
<p>If <code>TRUE</code>, all field values are returned as
character. If <code>FALSE</code>, <code>value</code> column in returned
data.table is a list column with
each value stored as corresponding type. Note that if the
value of numeric field is set to <code>"Autosize"</code> or
<code>"Autocalculate"</code>, it is left as it is, leaving the returned
type being a string instead of a number. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>unit</code></dt>
<dd>
<p>Only applicable when <code>string_value</code> is <code>FALSE</code>. If
<code>TRUE</code>, values of numeric fields are assigned with units using
<code>units::set_units()</code> if applicable. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>wide</code></dt>
<dd>
<p>Only applicable if target objects belong to a same class.
If <code>TRUE</code>, a wide table will be returned, i.e. first three
columns are always <code>id</code>, <code>name</code> and <code>class</code>, and then every
field in a separate column. Note that this requires all
objects specified must from the same class.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>all</code></dt>
<dd>
<p>If <code>TRUE</code>, all available fields defined in IDD for the
class that objects belong to will be returned. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>group_ext</code></dt>
<dd>
<p>Should be one of <code>"none"</code>, <code>"group"</code> or <code>"index"</code>.
If not <code>"none"</code>, <code>value</code> column in returned
<code>data.table::data.table()</code> will be converted into a list.
If <code>"group"</code>, values from extensible fields will be grouped by the
extensible group they belong to. For example, coordinate
values of each vertex in class <code>BuildingSurface:Detailed</code> will
be put into a list. If <code>"index"</code>, values from extensible fields
will be grouped by the extensible field indice they belong to.
For example, coordinate values of all x coordinates will be
put into a list. If <code>"none"</code>, nothing special will be done.
Default: <code>"none"</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$to_table()⁠</code> returns a data.table that
contains core data of current <code>IdfObject</code>. It has 6 columns:
</p>

<ul>
<li> <p><code>id</code>: Integer type. Object IDs.
</p>
</li>
<li> <p><code>name</code>: Character type. Object names.
</p>
</li>
<li> <p><code>class</code>: Character type. Current class name.
</p>
</li>
<li> <p><code>index</code>: Integer type. Field indexes.
</p>
</li>
<li> <p><code>field</code>: Character type. Field names.
</p>
</li>
<li> <p><code>value</code>: Character type if <code>string_value</code> is <code>TRUE</code> or list type if
<code>string_value</code> is <code>FALSE</code> or <code>group_ext</code> is not <code>"none"</code>. Field values.
</p>
</li>
</ul>
<p>Note that when <code>group_ext</code> is not <code>"none"</code>, <code>index</code> and <code>field</code>
values will not match the original field indices and names. In this
case, <code>index</code> will only indicate the indices of sequences. For
<code>field</code> column, specifically:
</p>

<ul>
<li>
<p> When <code>group_ext</code> is <code>"group"</code>, each field name in a extensible group
will be abbreviated using <code>abbreviate()</code> with <code>minlength</code> being
<code>10L</code> and all abbreviated names will be separated by <code>|</code> and
combined together. For example, field names in the extensible group
(<code style="white-space: pre;">⁠Vertex 1 X-coordinate⁠</code>, <code style="white-space: pre;">⁠Vertex 1 Y-coordinate⁠</code>, <code style="white-space: pre;">⁠Vertex 1 Z-coordinate⁠</code>) in class <code>BuildiBuildingSurface:Detailed</code> will be
merged into one name <code>Vrtx1X-crd|Vrtx1Y-crd|Vrtx1Z-crd</code>.
</p>
</li>
<li>
<p> When <code>group_ext</code> is <code>"index"</code>, the extensible group indicator in field
names will be removed. Take the same example as above, the
resulting field names will be <code style="white-space: pre;">⁠Vertex X-coordinate⁠</code>, <code style="white-space: pre;">⁠Vertex Y-coordinate⁠</code>, and <code style="white-space: pre;">⁠Vertex Z-coordinate⁠</code>.
</p>
</li>
</ul>
<h5>Returns</h5>

<p>A data.table with 6 columns (if
<code>wide</code> is <code>FALSE</code>) or at least 6 columns (if <code>wide</code> is <code>TRUE</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all object data in a data.table format without field units
str(mat$to_table(unit = FALSE))

# get all object data in a data.table format where all field values are put in a
# list column and field names without unit
str(mat$to_table(string_value = FALSE, unit = FALSE))

# get all object data in a data.table format, including tailing empty fields
str(idf$Zone$`ZONE ONE`$to_table(all = TRUE))

# get all object data in a data.table format where each field becomes a column
str(mat$to_table(wide = TRUE))

# group extensible by extensible group number
surf &lt;- idf$BuildingSurface_Detailed[["Zn001:Roof001"]]
surf$to_table(group_ext = "group")

# group extensible by extensible group number and convert into a wide table
surf$to_table(group_ext = "group", wide = TRUE)

# group extensible by extensible field index
surf$to_table(group_ext = "index")

# group extensible by extensible field index and convert into a wide table
surf$to_table(group_ext = "index", wide = TRUE)

# when grouping extensible, 'string_value' and 'unit' still take effect
surf$to_table(group_ext = "index", wide = TRUE, string_value = FALSE, unit = TRUE)
}

</pre>
</div>


<hr>
<a id="method-IdfObject-to_string"></a>



<h4>Method <code>to_string()</code>
</h4>

<p>Format current object as a character vector
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$to_string(comment = TRUE, leading = 4L, sep_at = 29L, all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>comment</code></dt>
<dd>
<p>If <code>FALSE</code>, all comments will not be included.
Default: <code>TRUE</code>.</p>
</dd>
<dt><code>leading</code></dt>
<dd>
<p>Leading spaces added to each field. Default: <code>4L</code>.</p>
</dd>
<dt><code>sep_at</code></dt>
<dd>
<p>The character width to separate value string and field
string. Default: <code>29L</code> which is the same as IDF Editor.</p>
</dd>
<dt><code>all</code></dt>
<dd>
<p>If <code>TRUE</code>, all available fields defined in IDD for the
class that objects belong to will be returned. Default:
<code>FALSE</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$to_string()⁠</code> returns the text format of current object.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get string format object
mat$to_string()

# get string format of object, and decrease the space between field values and
# field names
mat$to_string(sep_at = 15)

# get string format of object, and decrease the leading space of field values
mat$to_string(leading = 0)
}

</pre>
</div>


<hr>
<a id="method-IdfObject-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Print <code>IdfObject</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$print(comment = TRUE, auto_sep = TRUE, brief = FALSE, all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>comment</code></dt>
<dd>
<p>If <code>FALSE</code>, all comments are not included.</p>
</dd>
<dt><code>auto_sep</code></dt>
<dd>
<p>If <code>TRUE</code>, values and field names are separated at
the largest character length of values. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>brief</code></dt>
<dd>
<p>If <code>TRUE</code>, only OBJECT part is printed. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>all</code></dt>
<dd>
<p>If <code>TRUE</code>, all fields defined in Idd are printed even
they do not exist in current object. Default: <code>FALSE</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p><code style="white-space: pre;">⁠$print()⁠</code> prints the <code>IdfObject</code>. Basically, the print output can be
divided into 3 parts:
</p>

<ul>
<li>
<p> OBJECT: Class name, object id and name (if applicable).
</p>
</li>
<li>
<p> COMMENTS: Object comments if exist.
</p>
</li>
<li>
<p> VALUES: fields and values of current <code>IdfObject</code>. Required fields are marked
with start <code>*</code>. String values are quoted. Numeric values are printed as
they are. Blank string values are printed as <code style="white-space: pre;">⁠&lt;"Blank"&gt;⁠</code> and blank number
values are printed as <code style="white-space: pre;">⁠&lt;Blank&gt;⁠</code>.
</p>
</li>
</ul>
<h5>Returns</h5>

<p>The <code>IdfObject</code> itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# print the object without comment
mat$print(comment = FALSE)

# print the object, and auto separate field values and field names at the
# largetst character length of field values
mat$print(auto_sep = TRUE)
}

</pre>
</div>


<hr>
<a id="method-IdfObject-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Note</h3>


<ul>
<li>
<p> Only one single list is allowed, e.g. <code>idfobj$set(lst1)</code> where <code>lst1 &lt;- list(field1 = value1)</code> is allowed, but <code>idfobj$set(lst1, lst2)</code> is not.
</p>
</li>
<li>
<p> You can delete a field by assigning <code>NULL</code> to it, e.g. <code>iddobj$set(fld = NULL)</code> means to delete the value of field <code>fld</code>. If <code>.default</code> is FALSE,
also <code>fld</code> is not a required field and the index of <code>fld</code> is larger than
the number minimum fields required for that class, it will be deleted.
Otherwise it will be left as blank. If <code>.default</code> is <code>TRUE</code>, that field
will be filled with default value if applicable and left as blank if not.
</p>
</li>
<li>
<p> By default, trailing empty fields that are not required will be removed and
only minimum required fields are kept. You can keep the trailing empty
fields by setting <code>.empty</code> to <code>TRUE</code>.
</p>
</li>
<li>
<p> New fields that currently do not exist in that object can also be set. They
will be automatically added on the fly.
</p>
</li>
<li>
<p> Field name matching is <strong>case-insensitive</strong>. For convenience,
underscore-style field names are also allowed, e.g. <code>eNd_MoNtH</code> is
equivalent to <code style="white-space: pre;">⁠End Month⁠</code>.
</p>
</li>
<li>
<p> If not all field names are given, positions of those values without field
names are determined after those values with names. E.g. in
<code>model$set(Construction = list("out_layer", name = "name"))</code>, <code>"out_layer"</code>
will be treated as the value of field <code style="white-space: pre;">⁠Outside Layer⁠</code> in <code>Construction</code>, as
value of field <code>Name</code> has been given as <code>"name"</code>.
</p>
</li>
</ul>
<p>eplusr also provides custom S3 method of <code style="white-space: pre;">⁠$&lt;-⁠</code> and
<code>[[&lt;-</code> which makes it more convenient to set a single field value of an
<code>IdfObject</code>. Basically, <code>idfobj$FieldName &lt;- value</code> and <code>idfobj[[Field]]
&lt;- value</code> is equivalent to <code>idfobj$set(FieldName = value)</code> and
<code>idfobjset(Field = value)</code>.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p>Idf class
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## ------------------------------------------------
## Method `IdfObject$new`
## ------------------------------------------------

## Not run: 
# example model shipped with eplusr from EnergyPlus v8.8
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8
idf &lt;- read_idf(path_idf, use_idd(8.8, "auto"))

roof &lt;- IdfObject$new(26, parent = idf)

# get the IdfObject of material named "C5 - 4 IN HW CONCRETE"
mat &lt;- idf$Material[["C5 - 4 IN HW CONCRETE"]]

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$version`
## ------------------------------------------------

## Not run: 
# get version
roof$version()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$parent`
## ------------------------------------------------

## Not run: 
roof$parent()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$id`
## ------------------------------------------------

## Not run: 
roof$id()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$name`
## ------------------------------------------------

## Not run: 
roof$name()

# NA will be returned if the class does not have name attribute. For example,
# "Version" class
idf$Version$name()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$group_name`
## ------------------------------------------------

## Not run: 
roof$group_name()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$class_name`
## ------------------------------------------------

## Not run: 
roof$class_name()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$definition`
## ------------------------------------------------

## Not run: 
roof$definition()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$comment`
## ------------------------------------------------

## Not run: 
# get object comments
roof$comment()

# add new object comments
roof$comment(c("This is a material named `WD01`", "This object has an ID of 47"))
roof$comment()

# append new comments
roof$comment("This is an appended comment")
roof$comment()

# prepend new comments
roof$comment("This is a prepended comment", append = FALSE)
roof$comment()

# wrap long comments
roof$comment("This is a very long comment that is needed to be wrapped.", width = 30)
roof$comment()

# delete old comments and add new one
roof$comment("This is the only comment", append = NULL)
roof$comment()

# delete all comments
roof$comment(NULL)
roof$comment()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$value`
## ------------------------------------------------

## Not run: 
# get all existing field values
str(mat$value())

# get values of field 1, 3, 5
str(mat$value(c(1, 3, 5)))

# get character format values instead of a named list
mat$value(c(1, 3, 5), simplify = TRUE)

# get values of all field even those that are not set
str(roof$value())
str(roof$value(all = TRUE))

# get field values using shortcuts
mat$Roughness
mat[["Specific_Heat"]]
mat[c(1,2)]
mat[c("Name", "Density")]

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$set`
## ------------------------------------------------

## Not run: 
# set field values
mat$set(name = "new_name", Thickness = 0.02)
mat[c("Name", "Thickness")]

# When `default` argument is set to TRUE and input field values are empty, i.e.
# NULL, the field values will be reset to defaults.
mat[c("Thermal Absorptance", "Solar Absorptance")]

mat$set(visible_absorptance = NULL, Solar_Absorptance = NULL, .default = TRUE)
mat[c("Visible Absorptance", "Solar Absorptance")]

# set field values using shortcuts
mat$Name &lt;- "another_name"
mat$Name
mat[["Thickness"]] &lt;- 0.019
mat$Thickness

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$value_possible`
## ------------------------------------------------

## Not run: 
mat$value_possible()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$validate`
## ------------------------------------------------

## Not run: 
mat$validate()

# check at predefined validate level
mat$validate("none")
mat$validate("draft")
mat$validate("final")

# custom validate checking components
mat$validate(custom_validate(auto_field = TRUE, choice = TRUE))

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$is_valid`
## ------------------------------------------------

## Not run: 
mat$is_valid()

mat$definition()$field_range("Density")
eplusr_option(validate_level = "none") # have to set validate to "none" to do so
mat$Density &lt;- -1
eplusr_option(validate_level = "final") # change back to "final" validate level
mat$is_valid()

# check at predefined validate level
mat$is_valid("none")
mat$is_valid("draft")
mat$is_valid("final")

# custom validate checking components
mat$is_valid(custom_validate(auto_field = TRUE, choice = TRUE))

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$value_relation`
## ------------------------------------------------

## Not run: 
# check each layer's reference of a construction named FLOOR
roof$value_relation("zone name", "ref_to")

# check where is this construction being used
roof$value_relation("name", direction = "ref_by")

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$ref_to_object`
## ------------------------------------------------

## Not run: 
# get other objects that this object refereces
mat$ref_to_object() # not referencing other objects

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$ref_by_object`
## ------------------------------------------------

## Not run: 
# get other objects that reference this object
mat$ref_by_object() # referenced by construction "FLOOR"

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$ref_to_node`
## ------------------------------------------------

## Not run: 
if (is_avail_eplus(8.8)) {
    path &lt;- file.path(eplus_config(8.8)$dir, "ExampleFiles/5Zone_Transformer.idf")
    idf_5z &lt;- read_idf(path)
    idf_5z$NodeList$OutsideAirInletNodes$ref_to_node()
}

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$has_ref_to`
## ------------------------------------------------

## Not run: 
mat$has_ref_to()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$has_ref_by`
## ------------------------------------------------

## Not run: 
mat$has_ref_by()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$has_ref_node`
## ------------------------------------------------

## Not run: 
mat$has_ref_node()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$has_ref`
## ------------------------------------------------

## Not run: 
# check if having any referenced objects or is referenced by other objects
mat$has_ref()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$to_table`
## ------------------------------------------------

## Not run: 
# get all object data in a data.table format without field units
str(mat$to_table(unit = FALSE))

# get all object data in a data.table format where all field values are put in a
# list column and field names without unit
str(mat$to_table(string_value = FALSE, unit = FALSE))

# get all object data in a data.table format, including tailing empty fields
str(idf$Zone$`ZONE ONE`$to_table(all = TRUE))

# get all object data in a data.table format where each field becomes a column
str(mat$to_table(wide = TRUE))

# group extensible by extensible group number
surf &lt;- idf$BuildingSurface_Detailed[["Zn001:Roof001"]]
surf$to_table(group_ext = "group")

# group extensible by extensible group number and convert into a wide table
surf$to_table(group_ext = "group", wide = TRUE)

# group extensible by extensible field index
surf$to_table(group_ext = "index")

# group extensible by extensible field index and convert into a wide table
surf$to_table(group_ext = "index", wide = TRUE)

# when grouping extensible, 'string_value' and 'unit' still take effect
surf$to_table(group_ext = "index", wide = TRUE, string_value = FALSE, unit = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$to_string`
## ------------------------------------------------

## Not run: 
# get string format object
mat$to_string()

# get string format of object, and decrease the space between field values and
# field names
mat$to_string(sep_at = 15)

# get string format of object, and decrease the leading space of field values
mat$to_string(leading = 0)

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$print`
## ------------------------------------------------

## Not run: 
# print the object without comment
mat$print(comment = FALSE)

# print the object, and auto separate field values and field names at the
# largetst character length of field values
mat$print(auto_sep = TRUE)

## End(Not run)

</code></pre>


</div>