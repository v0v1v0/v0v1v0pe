<div class="container">

<table style="width: 100%;"><tr>
<td>bckdengpd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Boundary Corrected Kernel Density Estimate and GPD Tail Extreme Value Mixture Model</h2>

<h3>Description</h3>

<p>Density, cumulative distribution function, quantile function and
random number generation for the extreme value mixture model with 
boundary corrected kernel density estimate for bulk
distribution upto the threshold and conditional GPD above threshold. The parameters
are the bandwidth <code>lambda</code>, threshold <code>u</code>
GPD scale <code>sigmau</code> and shape <code>xi</code> and tail fraction <code>phiu</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dbckdengpd(x, kerncentres, lambda = NULL,
  u = as.vector(quantile(kerncentres, 0.9)), sigmau = sqrt(6 *
  var(kerncentres))/pi, xi = 0, phiu = TRUE, bw = NULL,
  kernel = "gaussian", bcmethod = "simple", proper = TRUE,
  nn = "jf96", offset = NULL, xmax = NULL, log = FALSE)

pbckdengpd(q, kerncentres, lambda = NULL,
  u = as.vector(quantile(kerncentres, 0.9)), sigmau = sqrt(6 *
  var(kerncentres))/pi, xi = 0, phiu = TRUE, bw = NULL,
  kernel = "gaussian", bcmethod = "simple", proper = TRUE,
  nn = "jf96", offset = NULL, xmax = NULL, lower.tail = TRUE)

qbckdengpd(p, kerncentres, lambda = NULL,
  u = as.vector(quantile(kerncentres, 0.9)), sigmau = sqrt(6 *
  var(kerncentres))/pi, xi = 0, phiu = TRUE, bw = NULL,
  kernel = "gaussian", bcmethod = "simple", proper = TRUE,
  nn = "jf96", offset = NULL, xmax = NULL, lower.tail = TRUE)

rbckdengpd(n = 1, kerncentres, lambda = NULL,
  u = as.vector(quantile(kerncentres, 0.9)), sigmau = sqrt(6 *
  var(kerncentres))/pi, xi = 0, phiu = TRUE, bw = NULL,
  kernel = "gaussian", bcmethod = "simple", proper = TRUE,
  nn = "jf96", offset = NULL, xmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>quantiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kerncentres</code></td>
<td>
<p>kernel centres (typically sample data vector or scalar)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>bandwidth for kernel (as half-width of kernel) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>threshold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmau</code></td>
<td>
<p>scale parameter (positive)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xi</code></td>
<td>
<p>shape parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phiu</code></td>
<td>
<p>probability of being above threshold <code class="reqn">[0, 1]</code> or <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>bandwidth for kernel (as standard deviations of kernel) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>kernel name (<code>default = "gaussian"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bcmethod</code></td>
<td>
<p>boundary correction method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proper</code></td>
<td>
<p>logical, whether density is renormalised to integrate to unity (where needed)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn</code></td>
<td>
<p>non-negativity correction method (simple boundary correction only)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>offset added to kernel centres (logtrans only) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmax</code></td>
<td>
<p>upper bound on support (copula and beta kernels only) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical, if TRUE then log density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>quantiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>logical, if FALSE then upper tail probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>cumulative probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size (positive integer)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Extreme value mixture model combining boundary corrected kernel density (BCKDE)
estimate for the bulk below the threshold and GPD for upper tail. The user chooses
from a wide range of boundary correction methods designed to cope with a lower bound
at zero and potentially also both upper and lower bounds.
</p>
<p>Some boundary correction methods require a secondary correction for
negative density estimates of which two methods are implemented. Further, some
methods don't necessarily give a density which integrates to one, so an option
is provided to renormalise to be proper.
</p>
<p>It assumes there is a lower bound at zero, so prior transformation of data is
required for a alternative lower bound (possibly including negation to allow
for an upper bound).
</p>
<p>The user can pre-specify <code>phiu</code> permitting a parameterised value for the
tail fraction <code class="reqn">\phi_u</code>. Alternatively, when <code>phiu=TRUE</code> the tail fraction
is estimated as the tail fraction from the BCKDE bulk model.
</p>
<p>The alternate bandwidth definitions are discussed in the
<code>kernels</code>, with the <code>lambda</code> as the default.
The <code>bw</code> specification is the same as used in the
<code>density</code> function.
</p>
<p>The possible kernels are also defined in <code>kernels</code>
with the <code>"gaussian"</code> as the default choice.
</p>
<p>The cumulative distribution function with tail fraction <code class="reqn">\phi_u</code> defined by the
upper tail fraction of the BCKDE (<code>phiu=TRUE</code>), upto the threshold
<code class="reqn">x \le u</code>, given by:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = H(x)</code>
</p>

<p>and above the threshold <code class="reqn">x &gt; u</code>:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = H(u) + [1 - H(u)] G(x)</code>
</p>

<p>where <code class="reqn">H(x)</code> and <code class="reqn">G(X)</code> are the BCKDE and conditional GPD
cumulative distribution functions respectively.
</p>
<p>The cumulative distribution function for pre-specified <code class="reqn">\phi_u</code>, upto the
threshold <code class="reqn">x \le u</code>, is given by:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = (1 - \phi_u) H(x)/H(u)</code>
</p>

<p>and above the threshold <code class="reqn">x &gt; u</code>:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \phi_u + [1 - \phi_u] G(x)</code>
</p>

<p>Notice that these definitions are equivalent when <code class="reqn">\phi_u = 1 - H(u)</code>.
</p>
<p>Unlike the standard KDE, there is no general rule-of-thumb bandwidth for all the
BCKDE, with only certain methods having a guideline in the literature, so none
have been implemented. Hence, a bandwidth must always be specified and you should
consider using <code>fbckdengpd</code> of 
<code>fbckden</code> function for cross-validation
MLE for bandwidth.
</p>
<p>See <code>gpd</code> for details of GPD upper tail component and 
<code>dbckden</code> for details of BCKDE bulk component.
</p>


<h3>Value</h3>

<p><code>dbckdengpd</code> gives the density, 
<code>pbckdengpd</code> gives the cumulative distribution function,
<code>qbckdengpd</code> gives the quantile function and 
<code>rbckdengpd</code> gives a random sample.
</p>


<h3>Boundary Correction Methods</h3>

<p>See <code>dbckden</code> for details of BCKDE methods.
</p>


<h3>Warning</h3>

<p>The <code>"simple"</code>, <code>"renorm"</code>, <code>"beta1"</code>, <code>"beta2"</code>, <code>"gamma1"</code> 
and <code>"gamma2"</code> boundary correction methods may require renormalisation using
numerical integration which can be very slow. In particular, the numerical integration
is extremely slow for the <code>kernel="uniform"</code>, due to the adaptive quadrature in
the <code>integrate</code> function
being particularly slow for functions with step-like behaviour.
</p>


<h3>Acknowledgments</h3>

<p>Based on code
by Anna MacDonald produced for MATLAB.
</p>


<h3>Note</h3>

<p>Unlike most of the other extreme value mixture model functions the 
<code>bckdengpd</code> functions have not been vectorised as
this is not appropriate. The main inputs (<code>x</code>, <code>p</code> or <code>q</code>)
must be either a scalar or a vector, which also define the output length.
The <code>kerncentres</code> can also be a scalar or vector.
</p>
<p>The kernel centres <code>kerncentres</code> can either be a single datapoint or a vector
of data. The kernel centres (<code>kerncentres</code>) and locations to evaluate density (<code>x</code>)
and cumulative distribution function (<code>q</code>) would usually be different.
</p>
<p>Default values are provided for all inputs, except for the fundamentals 
<code>kerncentres</code>, <code>x</code>, <code>q</code> and <code>p</code>. The default sample size for 
<code>rbckdengpd</code> is 1.
</p>
<p>The <code>xmax</code> option is only relevant for the beta and copula methods, so a
warning is produced if this is not <code>NULL</code> for in other methods.
The <code>offset</code> option is only relevant for the <code>"logtrans"</code> method, so a
warning is produced if this is not <code>NULL</code> for in other methods.
</p>
<p>Missing (<code>NA</code>) and Not-a-Number (<code>NaN</code>) values in <code>x</code>,
<code>p</code> and <code>q</code> are passed through as is and infinite values are set to
<code>NA</code>. None of these are not permitted for the parameters or kernel centres.
</p>
<p>Error checking of the inputs (e.g. invalid probabilities) is carried out and
will either stop or give warning message as appropriate.
</p>


<h3>Author(s)</h3>

<p>Yang Hu and Carl Scarrott <a href="mailto:carl.scarrott@canterbury.ac.nz">carl.scarrott@canterbury.ac.nz</a>.
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Kernel_density_estimation">http://en.wikipedia.org/wiki/Kernel_density_estimation</a>
</p>
<p><a href="http://en.wikipedia.org/wiki/Generalized_Pareto_distribution">http://en.wikipedia.org/wiki/Generalized_Pareto_distribution</a>
</p>
<p>Scarrott, C.J. and MacDonald, A. (2012). A review of extreme value
threshold estimation and uncertainty quantification. REVSTAT - Statistical
Journal 10(1), 33-59. Available from <a href="http://www.ine.pt/revstat/pdf/rs120102.pdf">http://www.ine.pt/revstat/pdf/rs120102.pdf</a>
</p>
<p>Bowman, A.W. (1984). An alternative method of cross-validation for the smoothing of
density estimates. Biometrika 71(2), 353-360.
</p>
<p>Duin, R.P.W. (1976). On the choice of smoothing parameters for Parzen estimators of
probability density functions. IEEE Transactions on Computers C25(11), 1175-1179.
</p>
<p>MacDonald, A., Scarrott, C.J., Lee, D., Darlow, B., Reale, M. and Russell, G. (2011).
A flexible extreme value mixture model. Computational Statistics and Data Analysis
55(6), 2137-2157.
</p>
<p>MacDonald, A., C. J. Scarrott, and D. S. Lee (2011). Boundary correction, consistency
and robustness of kernel densities using extreme value theory. Submitted.
Available from: <a href="http://www.math.canterbury.ac.nz/~c.scarrott">http://www.math.canterbury.ac.nz/~c.scarrott</a>.
</p>
<p>Wand, M. and Jones, M.C. (1995). Kernel Smoothing. Chapman &amp;&amp; Hall.
</p>


<h3>See Also</h3>

<p><code>gpd</code>, <code>kernels</code>, 
<code>kfun</code>,
<code>density</code>, <code>bw.nrd0</code>
and <code>dkde</code> in <code>ks</code> package.
</p>
<p>Other kdengpd: <code>fbckdengpd</code>,
<code>fgkg</code>, <code>fkdengpdcon</code>,
<code>fkdengpd</code>, <code>fkden</code>,
<code>gkg</code>, <code>kdengpdcon</code>,
<code>kdengpd</code>, <code>kden</code>
</p>
<p>Other bckden: <code>bckdengpdcon</code>,
<code>bckden</code>, <code>fbckdengpdcon</code>,
<code>fbckdengpd</code>, <code>fbckden</code>,
<code>fkden</code>, <code>kden</code>
</p>
<p>Other bckdengpd: <code>bckdengpdcon</code>,
<code>bckden</code>, <code>fbckdengpdcon</code>,
<code>fbckdengpd</code>, <code>fbckden</code>,
<code>fkdengpd</code>, <code>gkg</code>,
<code>kdengpd</code>, <code>kden</code>
</p>
<p>Other bckdengpdcon: <code>bckdengpdcon</code>,
<code>bckden</code>, <code>fbckdengpdcon</code>,
<code>fbckdengpd</code>, <code>fbckden</code>,
<code>fkdengpdcon</code>, <code>gkgcon</code>,
<code>kdengpdcon</code>
</p>
<p>Other fbckdengpd: <code>fbckdengpd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
set.seed(1)
par(mfrow = c(2, 2))

kerncentres=rgamma(500, shape = 1, scale = 2)
xx = seq(-0.1, 10, 0.01)
hist(kerncentres, breaks = 100, freq = FALSE)
lines(xx, dbckdengpd(xx, kerncentres, lambda = 0.5, bcmethod = "reflect"),
xlab = "x", ylab = "f(x)")
abline(v = quantile(kerncentres, 0.9))

plot(xx, pbckdengpd(xx, kerncentres, lambda = 0.5, bcmethod = "reflect"),
xlab = "x", ylab = "F(x)", type = "l")
lines(xx, pbckdengpd(xx, kerncentres, lambda = 0.5, xi = 0.3, bcmethod = "reflect"),
xlab = "x", ylab = "F(x)", col = "red")
lines(xx, pbckdengpd(xx, kerncentres, lambda = 0.5, xi = -0.3, bcmethod = "reflect"),
xlab = "x", ylab = "F(x)", col = "blue")
legend("topleft", paste("xi =",c(0, 0.3, -0.3)),
      col=c("black", "red", "blue"), lty = 1, cex = 0.5)

kerncentres = rweibull(1000, 2, 1)
x = rbckdengpd(1000, kerncentres, lambda = 0.1, phiu = TRUE, bcmethod = "reflect")
xx = seq(0.01, 3.5, 0.01)
hist(x, breaks = 100, freq = FALSE)         
lines(xx, dbckdengpd(xx, kerncentres, lambda = 0.1, phiu = TRUE, bcmethod = "reflect"),
xlab = "x", ylab = "f(x)")

lines(xx, dbckdengpd(xx, kerncentres, lambda = 0.1, xi=-0.2, phiu = 0.1, bcmethod = "reflect"),
xlab = "x", ylab = "f(x)", col = "red")
lines(xx, dbckdengpd(xx, kerncentres, lambda = 0.1, xi=0.2, phiu = 0.1, bcmethod = "reflect"),
xlab = "x", ylab = "f(x)", col = "blue")
legend("topleft", c("xi = 0", "xi = 0.2", "xi = -0.2"),
      col=c("black", "red", "blue"), lty = 1)

## End(Not run)

</code></pre>


</div>