<div class="container">

<table style="width: 100%;"><tr>
<td>test.robustness</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Test model robustness.</h2>

<h3>Description</h3>

<p>This function takes a definition of weight transformation 
limits and corresponding minimum and maximum numbers of end-members to 
model all end-member scenarios in accordance with these parameters. Based 
on the output the user can decide on robust end-members.
</p>


<h3>Usage</h3>

<pre><code class="language-R">test.robustness(
  X,
  q,
  l,
  P,
  c,
  classunits,
  ID,
  rotation = "Varimax",
  ol.rej,
  mRt.rej,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Numeric matrix with m samples (rows) and n variables (columns).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Numeric vector with number of end-members to be modelled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l</code></td>
<td>
<p>Numeric vector specifying the weight tranformation limits, i.e.
quantiles; default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>Numeric matrix, optional alternative input parameters for q and l,
either of the form m:3 with m variations in the columns q.min, q.max, l or
of the form m:2 with m variations in the columns q, l.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>Numeric scalar specifying the constant sum scaling parameter, e.g.
1, 100, 1000; default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classunits</code></td>
<td>
<p>Numeric vector, optional class units (e.g. phi classes or
micrometers) of the same length as columns of X.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ID</code></td>
<td>
<p>Numeric or character vector, optional sample IDs of the same
length as columns of X.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotation</code></td>
<td>
<p>Character scalar, rotation type, default is "Varimax" (cf.
Dietze et al., 2012). One out of the rotations provided in GPArotation is
possible (cf. <code>rotations</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ol.rej</code></td>
<td>
<p>Numeric scalar, optional rejection threshold for overlapping
criterion.  All model runs with overlapping end-members greater than the
specified integer will be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mRt.rej</code></td>
<td>
<p>Numeric scalar, optional rejection threshold for mean total
explained variance criterion. All modelled end-members below the specified
value will be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>Logical scalar, optional graphical output of the results,
default is FALSE. If set to TRUE, end-member loadings and end-member scores
are plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to the plot function (see details).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function value <code>$loadings</code> is redundant but was added for user
convenience.<br> Since the
function returns two plots, additional graphical parameters must be
specified as vector with the first element for the first plot and the second
element for the second plot. If graphical parameters are natively vectors
(e.g. a sequence of colours), they must be specified as matrices with each
vector as a row. If colours are specified, <code>colour</code> should be used
instead of <code>col</code>. <code>ylim</code> can only be modified for the first plot.
See example section for further advice.
</p>


<h3>Value</h3>

<p>A list with objects </p>
<table>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Vector with q.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l</code></td>
<td>
<p>Vector with
l.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modes</code></td>
<td>
<p>Vector with mode class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mRt</code></td>
<td>
<p>Vector with mean total
explained variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ol</code></td>
<td>
<p>Vector with n overlapping end-members.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>Matrix with normalised rescaled end-member loadings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vqsn</code></td>
<td>
<p>Matrix with rescaled end-member loadings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vqn</code></td>
<td>
<p>Matrix
with normalised factor loadings.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>References</h3>

<p>Dietze E, Hartmann K, Diekmann B, IJmker J, Lehmkuhl F, Opitz S,
Stauch G, Wuennemann B, Borchers A. 2012. An end-member algorithm for
deciphering modern detrital processes from lake sediments of Lake Donggi
Cona, NE Tibetan Plateau, China. Sedimentary Geology 243-244: 169-180. <br></p>


<h3>Examples</h3>

<pre><code class="language-R">
## load example data set
data(example_X)

## Example 1 - perform the most simple test
q  &lt;- 4:7
l &lt;- seq(from = 0, to = 0.1, by = 0.02)

M1  &lt;- test.robustness(X = X, q = q, l = l, 
                       ol.rej = 1, mRt.rej = 0.8, 
                       plot = TRUE,
                       colour = c(4, 7),
                       xlab = c(expression(paste("Grain size (", phi, ")", 
                                                 sep = "")), 
                                expression(paste("Grain size (", phi, ")", 
                                                 sep = ""))))

## Example 2 -  perform the test without rejection criteria and plots
P  &lt;- cbind(rep(q[1], length(l)),
            rep(q[3], length(l)),
            l)
M2  &lt;- test.robustness(X = X, P = P)

## Plot 1 - end-member loadings which do not overlap and yielded mRt &gt; 0.80.
plot(M2$Vqsn[1,], type = "l", ylim = c(0, max(M2$Vqsn, na.rm = TRUE)),
     main = "End-member loadings")
  for (i in 2:nrow(M2$Vqsn)) lines(M2$Vqsn[i,])

# Plot 2 - histogram of mode positions
hist(M2$modes,
     breaks = 1:ncol(X), 
     main = "Mode positions",
     xlab = "Class")

# Plot 3 - positions of modelled end-member modes by number of end-members
# Note how scatter in end-member position decreases for the "correct" number 
# of modelled end-members (6) and an appropriate weight limit (ca. 0.1).
ii &lt;- order(M2$q, M2$modes)
modes &lt;- t(rbind(M2$modes, M2$q))[ii,]
plot(modes[,1],
     seq(1, nrow(modes)), 
     main = "Model overview",
     xlab = "Class", 
     ylab = "EM number in model run", 
     pch = as.character(modes[,2]), 
     cex = 0.7)

# Illustrate mode positions as stem-and-leave-plot, useful as a simple
# check, which mode maxima are consistently fall into which grain-size 
# class (useful to define "limits" in robust.EM).
stem(M2$modes, scale = 2)


</code></pre>


</div>