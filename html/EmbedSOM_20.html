<div class="container">

<table style="width: 100%;"><tr>
<td>SOM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build a self-organizing map</h2>

<h3>Description</h3>

<p>Build a self-organizing map
</p>


<h3>Usage</h3>

<pre><code class="language-R">SOM(
  data,
  xdim = 10,
  ydim = 10,
  zdim = NULL,
  batch = F,
  rlen = 10,
  alphaA = c(0.05, 0.01),
  radiusA = stats::quantile(nhbrdist, 0.67) * c(1, 0),
  alphaB = alphaA * c(-negAlpha, -0.1 * negAlpha),
  radiusB = negRadius * radiusA,
  negRadius = 1.33,
  negAlpha = 0.1,
  epochRadii = seq(radiusA[1], radiusA[2], length.out = rlen),
  init = FALSE,
  initf = Initialize_PCA,
  distf = 2,
  codes = NULL,
  importance = NULL,
  coordsFn = NULL,
  nhbr.method = "maximum",
  noMapping = F,
  parallel = F,
  threads = if (parallel) 0 else 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Matrix containing the training data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xdim</code></td>
<td>
<p>Width of the grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ydim</code></td>
<td>
<p>Hight of the grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zdim</code></td>
<td>
<p>Depth of the grid, causes the grid to be 3D if set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch</code></td>
<td>
<p>Use batch training (default <code>FALSE</code> chooses online training, which is more like FlowSOM)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rlen</code></td>
<td>
<p>Number of training epochs; or number of times to loop over the training data in online training</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphaA</code></td>
<td>
<p>Start and end learning rate for online learning (only for online training)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radiusA</code></td>
<td>
<p>Start and end radius</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphaB</code></td>
<td>
<p>Start and end learning rate for the second radius (only for online training)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radiusB</code></td>
<td>
<p>Start and end radius (only for online training; make sure it is larger than radiusA)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negRadius</code></td>
<td>
<p>easy way to set radiusB as a multiple of default radius
(use lower value for higher dimensions)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negAlpha</code></td>
<td>
<p>the same for alphaB</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epochRadii</code></td>
<td>
<p>Vector of length <code>rlen</code> with precise epoch radii (only for batch training)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>Initialize cluster centers in a non-random way</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initf</code></td>
<td>
<p>Use the given initialization function if init==T
(default: Initialize_PCA)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distf</code></td>
<td>
<p>Distance function (1=manhattan, 2=euclidean, 3=chebyshev, 4=cosine)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>codes</code></td>
<td>
<p>Cluster centers to start with</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>importance</code></td>
<td>
<p>array with numeric values. Columns of <code>data</code> will be scaled according to importance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coordsFn</code></td>
<td>
<p>Function to generate/transform grid coordinates (e.g. <code>tSNECoords()</code>). If <code>NULL</code> (default), the grid is the canonical SOM grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nhbr.method</code></td>
<td>
<p>Way of computing grid distances, passed as <code style="white-space: pre;">⁠method=⁠</code> to <code>stats::dist()</code> function. Defaults to <code>maximum</code> (square neighborhoods); use <code>euclidean</code> for round neighborhoods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noMapping</code></td>
<td>
<p>If TRUE, do not compute the mapping (default FALSE). Makes the process quicker by 1 <code>rlen</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Parallelize the batch training by setting appropriate <code>threads</code>. Defaults to FALSE. Always use <code>batch=TRUE</code> for fully parallelized version, online training is not parallelizable. Passed to <code>MapDataToCodes()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threads</code></td>
<td>
<p>Number of threads of the batch training (has no effect on online training). Defaults to 0 (chooses maximum available hardware threads) if <code>parallel==TRUE</code> or 1 (single thread) if <code>parallel==FALSE</code>. Passed to <code>MapDataToCodes()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A map useful for embedding (<code>EmbedSOM()</code> function) or further analysis, e.g. clustering.
</p>


<h3>See Also</h3>

<p>FlowSOM::SOM
</p>


</div>