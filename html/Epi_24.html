<div class="container">

<table style="width: 100%;"><tr>
<td>boxes.MS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Draw boxes and arrows for illustration of multistate models.
</h2>

<h3>Description</h3>

<p>Boxes can be drawn with text (<code>tbox</code>) or a cross (<code>dbox</code>),
and arrows pointing between the boxes (<code>boxarr</code>) can be drawn
automatically not overlapping the boxes. The <code>boxes</code> method for
<code>Lexis</code> objects generates displays of states with
person-years and transitions with events or rates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">   tbox( txt, x, y, wd, ht,
         font=2, lwd=2,
         col.txt=par("fg"),
         col.border=par("fg"),
         col.bg="transparent" )
   dbox( x, y, wd, ht=wd,
         font=2, lwd=2, cwd=5,
         col.cross=par("fg"),
         col.border=par("fg"),
         col.bg="transparent"  )
   boxarr( b1, b2, offset=FALSE, pos=0.45, ... )
## S3 method for class 'Lexis'
boxes( obj,
                    boxpos = FALSE,
                     wmult = 1.20,
                     hmult = 1.20 + 0.85*(!show.Y),
                       cex = 1.40,
                    show   = inherits( obj, "Lexis" ),
                    show.Y = show,
                   scale.Y = 1,
                  digits.Y = 1,
                   show.BE = FALSE,
                    BE.sep = c("","","          ",""),
                    show.D = show,
                   scale.D = FALSE,
                  digits.D = as.numeric(as.logical(scale.D)),
                    show.R = show &amp; is.numeric(scale.R),
                   scale.R = 1,
                  digits.R = as.numeric(as.logical(scale.R)),
                    DR.sep = if( show.D ) c("\n(",")") else c("",""),
                     eq.wd = TRUE,
                     eq.ht = TRUE,
                        wd,
                        ht,
                    subset = NULL,
                   exclude = NULL,
                      font = 1,
                       lwd = 2,
                   col.txt = par("fg"),
                col.border = col.txt,
                    col.bg = "transparent",
                   col.arr = par("fg"),
                   lwd.arr = lwd,
                  font.arr = font,
                   pos.arr = 0.45,
                   txt.arr = NULL,
               col.txt.arr = col.arr,
                offset.arr = 2,
                             ... )
## S3 method for class 'matrix'
boxes( obj, ... )
## S3 method for class 'MS'
boxes( obj, sub.st, sub.tr, cex=1.5, ... )
   fillarr( x1, y1, x2, y2, gap=2, fr=0.8,
            angle=17, lwd=2, length=par("pin")[1]/30, ... )
   </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>txt</code></td>
<td>
<p>Text to be placed inside the box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>x-coordinate of center of box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>y-coordinate of center of box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wd</code></td>
<td>
<p>width of boxes in percentage of the plot width.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ht</code></td>
<td>
<p>height of boxes in percentage of the plot height.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>font</code></td>
<td>
<p>Font for the text. Defaults to 2 (=bold).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>Line width of the box borders.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.txt</code></td>
<td>
<p>Color for the text in boxes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.border</code></td>
<td>
<p>Color of the box border.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.bg</code></td>
<td>
<p>Background color for the interior of the box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to be passed on to the call of other functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cwd</code></td>
<td>
<p>Width of the lines in the cross.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.cross</code></td>
<td>
<p>Color of the cross.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b1</code></td>
<td>
<p>Coordinates of the "from" box. A vector with 4 components,
<code>x</code>, <code>y</code>, <code>w</code>, <code>h</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b2</code></td>
<td>
<p>Coordinates of the "to" box; like <code>b1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Logical. Should the arrow be offset a bit to the left.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos</code></td>
<td>
<p>Numerical between 0 and 1, determines the position of the point
on the arrow which is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>A <code>Lexis</code> object or a transition matrix; that
is a square matrix indexed by state in both dimensions, and the
<code class="reqn">(i,j)</code>th entry different from <code>NA</code> if a transition <code class="reqn">i</code>
to <code class="reqn">j</code> can occur. If <code>show.D=TRUE</code>, the arrows between
states are annotated by these numbers. If <code>show.Y=TRUE</code>, the
boxes representing states are annotated by the numbers in the
diagonal of <code>obj</code>.
</p>
<p>For <code>boxes.matrix</code> <code>obj</code> is a matrix and for
<code>boxes.MS</code>, <code>obj</code> is an <code>MS.boxes</code> object (see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boxpos</code></td>
<td>
<p>If <code>TRUE</code> the boxes are positioned  equidistantly on a
circle, if <code>FALSE</code> (the default) you are queried to
click on the screen for the positions. This argument can also
be a named list with elements <code>x</code> and
<code>y</code>, both numerical vectors, giving the centers of
the boxes. These must be numbers between 0 and 100
indicating percentages of the display in the two directions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wmult</code></td>
<td>
<p>Multiplier for the width of the box relative to the width of the
text in the box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hmult</code></td>
<td>
<p>Multiplier for the height of the box relative to the height of the
text in the box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex</code></td>
<td>
<p>Character expansion for text in the box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show</code></td>
<td>
<p>Should person-years and transitions be put in the plot.
Ignored if <code>obj</code> is not a <code>Lexis</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.Y</code></td>
<td>
<p>If logical: Should person-years be put in the boxes.
If numeric: Numbers to put in boxes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.Y</code></td>
<td>
<p>What scale should be used for annotation of person-years.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits.Y</code></td>
<td>
<p>How many digits after the decimal point should be used for the
person-years.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.BE</code></td>
<td>
<p>Logical. Should number of persons beginning
resp. ending follow up in each state be shown? If given as character
"nz" or "noz" the numbers will be shown, but zeros omitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BE.sep</code></td>
<td>
<p>Character vector of length 4, used for annotation of the
number of persons beginning and ending in each state: 1st element
precedes no. beginning, 2nd trails it, 3rd precedes the no. ending
(defaults to 8 spaces), and the 4th trails the no. ending.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.D</code></td>
<td>
<p>Should no. transitions be put alongside the arrows.
Ignored if <code>obj</code> is not a <code>Lexis</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.D</code></td>
<td>
<p>Synonymous with <code>scale.R</code>, retained for compatibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits.D</code></td>
<td>
<p>Synonymous with <code>digits.R</code>, retained for compatibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.R</code></td>
<td>
<p>Should the transition rates be shown on the arrows?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.R</code></td>
<td>
<p>If this a scalar, rates instead of no. transitions are printed
at the arrows, scaled by <code>scale.R</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits.R</code></td>
<td>
<p>How many digits after the decimal point should be used for the
rates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DR.sep</code></td>
<td>
<p>Character vector of length 2. If rates are shown, the
first element is inserted before and the second after the rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eq.wd</code></td>
<td>
<p>Should boxes all have the same width?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eq.ht</code></td>
<td>
<p>Should boxes all have the same height?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>Draw only boxes and arrows for a subset of the states.
Can be given either as a numerical vector or character
vector state names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>Exclude states from the plot. The complementary of <code>subset</code>.
Ignored if <code>subset</code> is given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.arr</code></td>
<td>
<p>Color of the arrows between boxes.
A vector of character strings, the arrows are referred to as the
row-wise sequence of non-NA elements of the transition matrix.
Thus the first ones refer to the transitions out of state 1, in
order of states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd.arr</code></td>
<td>
<p>Line widths of the arrows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>font.arr</code></td>
<td>
<p>Font of the text annotation the arrows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.arr</code></td>
<td>
<p>Numerical between 0 and 1, determines the position on
the arrows where the text is written.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>txt.arr</code></td>
<td>
<p>Text put on the arrows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.txt.arr</code></td>
<td>
<p>Colors for text on the arrows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset.arr</code></td>
<td>
<p>The amount offset between arrows representing
two-way transitions, that is where there are arrows both ways
between two boxes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub.st</code></td>
<td>
<p>Subset of the states to be drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub.tr</code></td>
<td>
<p>Subset of the transitions to be drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>x-coordinate of the starting point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y1</code></td>
<td>
<p>y-coordinate of the starting point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2</code></td>
<td>
<p>x-coordinate of the end point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y2</code></td>
<td>
<p>y-coordinate of the end point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gap</code></td>
<td>
<p>Length of the gap between the box and the ends of the arrows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fr</code></td>
<td>
<p>Length of the arrow as the fraction of the distance between the
boxes. Ignored unless given explicitly, in which case any value
given for <code>gap</code> is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>angle</code></td>
<td>
<p>What angle should the arrow-head have?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length</code></td>
<td>
<p>Length of the arrow head in inches. Defaults to 1/30 of the
physical width of the plot.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions are designed to facilitate the drawing of multistate
models, mainly by automatic calculation of the arrows between boxes.
</p>
<p><code>tbox</code> draws a box with centered text, and returns a vector of
location, height and width of the box. This is used when drawing
arrows between boxes. <code>dbox</code> draws a box with a cross,
symbolizing a death state. <code>boxarr</code> draws an arrow between two
boxes, making sure it does not intersect the boxes. Only straight
lines are drawn.
</p>
<p><code>boxes.Lexis</code> takes as input a Lexis object sets up an empty plot
area (with axes 0 to 100 in both directions) and if
<code>boxpos=FALSE</code> (the default) prompts you to click on the
locations for the state boxes, and then draws arrows implied by the
actual transitions in the <code>Lexis</code> object. The default is to
annotate the transitions with the number of transitions.
</p>
<p>A transition matrix can also be supplied, in which case the row/column
names are used as state names, diagonal elements taken as
person-years, and off-diagonal elements as number of transitions.
This also works for <code>boxes.matrix</code>.
</p>
<p>Optionally returns the R-code reproducing the plot in a file, which
can be useful if you want to produce exactly the same plot with
differing arrow colors etc.
</p>
<p><code>boxarr</code> draws an arrow between two boxes, on the line connecting
the two box centers. The <code>offset</code> argument is used to offset the
arrow a bit to the left (as seen in the direction of the arrow) on order
to accommodate arrows both ways between boxes. <code>boxarr</code> returns a named
list with elements <code>x</code>, <code>y</code> and <code>d</code>, where the two former
give the location of a point on the arrow used for printing (see argument
<code>pos</code>) and the latter is a unit vector in the
direction of the arrow, which is used by <code>boxes.Lexis</code> to
position the annotation of arrows with the number of transitions.
</p>
<p><code>boxes.MS</code> re-draws what <code>boxes.Lexis</code> has done based on the
object of class <code>MS</code> produced by <code>boxes.Lexis</code>. The point
being that the <code>MS</code> object is easily modifiable, and thus it is a
machinery to make variations of the plot with different color
annotations etc.
</p>
<p><code>fill.arr</code> is just a utility drawing nicer arrows than the default
<code>arrows</code> command, basically by using filled arrow-heads; called
by <code>boxarr</code>.
</p>


<h3>Value</h3>

<p>The functions <code>tbox</code> and <code>dbox</code> return the location and
dimension of the boxes, <code>c(x,y,w,h)</code>, which are designed to be used
as input to the <code>boxarr</code> function.
</p>
<p>The <code>boxarr</code> function returns the coordinates (as a named
list with names <code>x</code> and <code>y</code>) of a point on the
arrow, designated to be used for annotation of the arrow.
</p>
<p>The function <code>boxes.Lexis</code> returns an <code>MS</code> object, a list with
five elements: 1) <code>Boxes</code> - a data frame with one row
per box and columns
<code>xx</code>,
<code>yy</code>,
<code>wd</code>,
<code>ht</code>,
<code>font</code>,
<code>lwd</code>,
<code>col.txt</code>,
<code>col.border</code> and
<code>col.bg</code>,
2) an object <code>State.names</code> with names of states (possibly an
expression, hence not possible to include as a column in <code>Boxes</code>),
3) a matrix <code>Tmat</code>, the transition matrix, 4) a data
frame, <code>Arrows</code> with one row per transition and columns:
<code>lwd.arr</code>,
<code>col.arr</code>,
<code>pos.arr</code>,
<code>col.txt.arr</code>,
<code>font.arr</code> and
<code>offset.arr</code> and
5) an object <code>Arrowtext</code> with names of states (possibly an
expression, hence not possible to include as a column in
<code>Arrows</code>)
</p>
<p>An <code>MS</code> object is used as input to
<code>boxes.MS</code>, the primary use is to modify selected entries in
the <code>MS</code> object first, e.g. colors, or supply
sub-setting arguments in order to produce displays that have the
same structure, but with different colors etc.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen</p>


<h3>See Also</h3>

<p><code>tmat.Lexis</code>, <code>legendbox</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">par( mar=c(0,0,0,0), cex=1.5 )
plot( NA,
      bty="n",
      xlim=0:1*100, ylim=0:1*100, xaxt="n", yaxt="n", xlab="", ylab="" )
bw  &lt;- tbox( "Well"    , 10, 60, 22, 10, col.txt="blue" )
bo  &lt;- tbox( "other Ca", 45, 80, 22, 10, col.txt="gray" )
bc  &lt;- tbox( "Ca"      , 45, 60, 22, 10, col.txt="red" )
bd  &lt;- tbox( "DM"      , 45, 40, 22, 10, col.txt="blue" )
bcd &lt;- tbox( "Ca + DM" , 80, 60, 22, 10, col.txt="gray" )
bdc &lt;- tbox( "DM + Ca" , 80, 40, 22, 10, col.txt="red" )
      boxarr( bw, bo , col=gray(0.7), lwd=3 )
# Note the argument adj= can takes values outside (0,1)
text( boxarr( bw, bc , col="blue", lwd=3 ),
      expression( lambda[Well] ), col="blue", adj=c(1,-0.2), cex=0.8 )
      boxarr( bw, bd , col=gray(0.7) , lwd=3 )
      boxarr( bc, bcd, col=gray(0.7) , lwd=3 )
text( boxarr( bd, bdc, col="blue", lwd=3 ),
      expression( lambda[DM] ), col="blue", adj=c(1.1,-0.2), cex=0.8 )

# Set up a transition matrix allowing recovery
tm &lt;- rbind( c(NA,1,1), c(1,NA,1), c(NA,NA,NA) )
rownames(tm) &lt;- colnames(tm) &lt;- c("Cancer","Recurrence","Dead")
tm
boxes.matrix( tm, boxpos=TRUE )

# Illustrate texting of arrows
boxes.Lexis( tm, boxpos=TRUE, txt.arr=c("en","to","tre","fire") )
zz &lt;- boxes( tm, boxpos=TRUE, txt.arr=c(expression(lambda[C]),
                                        expression(mu[C]),
                                        "recovery",
                                        expression(mu[R]) ) )

# Change color of a box
zz$Boxes[3,c("col.bg","col.border")] &lt;- "green"
boxes( zz )

# Set up a Lexis object
data(DMlate)
str(DMlate)
dml &lt;- Lexis( entry=list(Per=dodm, Age=dodm-dobth, DMdur=0 ),
               exit=list(Per=dox),
        exit.status=factor(!is.na(dodth),labels=c("DM","Dead")),
               data=DMlate[1:1000,] )

# Cut follow-up at Insulin
dmi &lt;- cutLexis( dml, cut=dml$doins, new.state="Ins", pre="DM" )
summary( dmi )
boxes( dmi, boxpos=TRUE )
boxes( dmi, boxpos=TRUE, show.BE=TRUE )
boxes( dmi, boxpos=TRUE, show.BE="nz" )
boxes( dmi, boxpos=TRUE, show.BE="nz", BE.sep=c("In:","      Out:","") )

# Set up a bogus recovery date just to illustrate two-way transitions
dmi$dorec &lt;- dmi$doins + runif(nrow(dmi),0.5,10)
dmi$dorec[dmi$dorec&gt;dmi$dox] &lt;- NA
dmR &lt;- cutLexis( dmi, cut=dmi$dorec, new.state="DM", pre="Ins" )
summary( dmR )
boxes( dmR, boxpos=TRUE )
boxes( dmR, boxpos=TRUE, show.D=FALSE )
boxes( dmR, boxpos=TRUE, show.D=FALSE, show.Y=FALSE )
boxes( dmR, boxpos=TRUE, scale.R=1000 )
MSobj &lt;- boxes( dmR, boxpos=TRUE, scale.R=1000, show.D=FALSE )
MSobj &lt;- boxes( dmR, boxpos=TRUE, scale.R=1000, DR.sep=c(" (",")") )
class( MSobj )
boxes( MSobj )
MSobj$Boxes[1,c("col.txt","col.border")] &lt;- "red"
MSobj$Arrows[1:2,"col.arr"] &lt;- "red"
boxes( MSobj )
    </code></pre>


</div>