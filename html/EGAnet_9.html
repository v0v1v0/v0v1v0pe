<div class="container">

<table style="width: 100%;"><tr>
<td>community.consensus</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Applies the Consensus Clustering Method (Louvain only)</h2>

<h3>Description</h3>

<p>Applies the consensus clustering method introduced by (Lancichinetti &amp; Fortunato, 2012).
The original implementation of this method applies a community detection algorithm repeatedly
to the same network. With stochastic networks, the algorithm is likely to identify different
community solutions with many repeated applications.
</p>


<h3>Usage</h3>

<pre><code class="language-R">community.consensus(
  network,
  order = c("lower", "higher"),
  resolution = 1,
  consensus.method = c("highest_modularity", "iterative", "most_common", "lowest_tefi"),
  consensus.iter = 1000,
  correlation.matrix = NULL,
  allow.singleton = FALSE,
  membership.only = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>network</code></td>
<td>
<p>Matrix or <code>igraph</code> network object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"higher"</code>.
Whether <code>"lower"</code> or <code>"higher"</code> order memberships from
the Louvain algorithm should be obtained for the consensus.
The <code>"lower"</code> order Louvain memberships are from the first
initial pass of the Louvain algorithm whereas the <code>"higher"</code>
order Louvain memberships are from the last pass of the Louvain
algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resolution</code></td>
<td>
<p>Numeric (length = 1).
A parameter that adjusts modularity to allow the algorithm to
prefer smaller (<code>resolution</code> &gt; 1) or larger
(0 &lt; <code>resolution</code> &lt; 1) communities.
Defaults to <code>1</code> (standard modularity computation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>consensus.method</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"most_common"</code>.
Available options for arriving at a consensus (<em>Note</em>:
All methods except <code>"iterative"</code> are considered experimental
until validated):
</p>

<ul>
<li> <p><code>"highest_modularity"</code> — <strong>EXPERIMENTAL.</strong> Selects the community solution with the highest modularity across
the applications. Modularity is a reasonable metric for identifying the number
of communities in a network but it comes with limitations (e.g., resolution limit)
</p>
</li>
<li> <p><code>"iterative"</code> — The original approach proposed by Lancichinetti &amp; Fortunato (2012). See
"Details" for more information
</p>
</li>
<li> <p><code>"most_common"</code> — Selects the community solution that appears the most
frequently across the applications. The idea behind this method is that the solution
that appears most often will be the most likely solution for the algorithm as well
as most reproducible. Can be less stable as the number of nodes increase requiring
a larger value for <code>consensus.iter</code>.  This method is the <strong>default</strong>
</p>
</li>
<li> <p><code>"lowest_tefi"</code> — <strong>EXPERIMENTAL.</strong> Selects the community solution with the lowest Total Entropy
Fit Index (<code>tefi</code>) across the applications. TEFI is a reasonable metric
to identify the number of communities in a network based on Golino, Moulder et al. (2020)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>consensus.iter</code></td>
<td>
<p>Numeric (length = 1).
Number of algorithm applications to the network.
Defaults to <code>1000</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correlation.matrix</code></td>
<td>
<p>Symmetric matrix.
Used for computation of <code>tefi</code>.
Only needed when <code>consensus.method = "tefi"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow.singleton</code></td>
<td>
<p>Boolean (length = 1).
Whether singleton or single node communities should be allowed.
Defaults to <code>FALSE</code>.
When <code>FALSE</code>, singleton communities will be set to
missing (<code>NA</code>); otherwise, when <code>TRUE</code>, singleton
communities will be allowed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>membership.only</code></td>
<td>
<p>Boolean.
Whether the memberships only should be output.
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to obtain all output for the
community detection algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not actually used but makes it easier for general functionality
in the package</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The goal of the consensus clustering method is to identify a stable solution across
algorithm applications to derive a "consensus" clustering. The standard or "iterative"
approach is to apply the community detection algorithm <em>N</em> times. Then, a co-occurrence
matrix is created representing how often each pair of nodes co-occurred across the
applications. Based on some cut-off value (e.g., 0.30), co-occurrences below this value
are set to zero, forming a "new" sparse network. The procedure proceeds until all nodes
co-occur with all other nodes in their community (or a proportion of 1.00).
</p>
<p>Variations of this procedure are also available in this package but are
<strong>experimental</strong>. Use these experimental procedures with caution.
More work is necessary before these experimental procedures are validated
</p>
<p><em>At this time, seed setting for consensus clustering is not supported</em>
</p>


<h3>Value</h3>

<p>Returns either a vector with the selected solution
or a list when <code>membership.only = FALSE</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>selected_solution</code></td>
<td>
<p>Resulting solution from the consensus method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memberships</code></td>
<td>
<p>Matrix of memberships across the consensus iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proportion_table</code></td>
<td>
<p>For methods that use frequency, a table that
reports those frequencies alongside their corresponding memberships</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Louvain algorithm</strong> <br>
Blondel, V. D., Guillaume, J.-L., Lambiotte, R., &amp; Lefebvre, E. (2008).
Fast unfolding of communities in large networks.
<em>Journal of Statistical Mechanics: Theory and Experiment</em>, <em>2008</em>(10), P10008.
</p>
<p><strong>Consensus clustering</strong> <br>
Lancichinetti, A., &amp; Fortunato, S. (2012).
Consensus clustering in complex networks.
<em>Scientific Reports</em>, <em>2</em>(1), 1–7.
</p>
<p><strong>Entropy fit indices</strong> <br>
Golino, H., Moulder, R. G., Shi, D., Christensen, A. P., Garrido, L. E., Nieto, M. D., Nesselroade, J., Sadana, R., Thiyagarajan, J. A., &amp; Boker, S. M. (2020).
Entropy fit indices: New fit measures for assessing the structure and dimensionality of multiple latent variables.
<em>Multivariate Behavioral Research</em>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load data
wmt &lt;- wmt2[,7:24]

# Estimate correlation matrix
correlation.matrix &lt;- auto.correlate(wmt)

# Estimate network
network &lt;- EBICglasso.qgraph(data = wmt)

# Compute standard Louvain with highest modularity approach
community.consensus(
  network,
  consensus.method = "highest_modularity"
)

# Compute standard Louvain with iterative (original) approach
community.consensus(
  network,
  consensus.method = "iterative"
)

# Compute standard Louvain with most common approach
community.consensus(
  network,
  consensus.method = "most_common"
)

# Compute standard Louvain with lowest TEFI approach
community.consensus(
  network,
  consensus.method = "lowest_tefi",
  correlation.matrix = correlation.matrix
)

</code></pre>


</div>