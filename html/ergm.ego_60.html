<div class="container">

<table style="width: 100%;"><tr>
<td>summary_formula.egor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculation of ERGM-style summary statistics for <code>egor</code>
objects.</h2>

<h3>Description</h3>

<p>Used to calculate the specified network statistics inferred from a
<code>egor</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'egor'
summary_formula(object, ..., basis = NULL, individual = FALSE, scaleto = NULL)

## S3 method for class 'ergm.ego_svystat'
x * y
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An <code>ergm</code>-style formula with a
<code>egor</code> object as the LHS.
</p>
<p>For a list of currently implemented egocentric terms for the RHS, see
<code>ergm.ego-terms</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used at this time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis</code></td>
<td>
<p>An optional <code>egor</code> object relative to which the
statistics should be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>individual</code></td>
<td>
<p>If <code>FALSE</code> (the default), calculate the estimated
per-capita statistics, weighted according to the ego weights, then scale
them up to a network of size <code>scaleto</code>.
</p>
<p>If <code>TRUE</code>, calculate each ego's individual contribution to the
specified network statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleto</code></td>
<td>
<p>Size of a hypothetical network to which to scale the
statistics. Defaults to the number of egos in the dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>see <code>*.svystat</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>individual==FALSE</code>, an <code>ergm.ego_svystat</code> object, which is a subclass of svystat—effectively a named vector of statistics. If
<code>individual==TRUE</code>, a matrix with a row for each ego, giving that ego's
contribution to the network statistic.
</p>


<h3>Functions</h3>


<ul><li> <p><code> * </code>: A multiplication method that takes into account which statistics are scalable.
</p>
</li></ul>
<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>References</h3>


<ul>
<li>
<p> Pavel N. Krivitsky and Martina Morris (2017). "Inference for social network models from egocentrically sampled data, with application to understanding persistent racial disparities in HIV prevalence in the US." <em>Annals of Applied Statistics</em>, 11(1): 427–455. <a href="https://doi.org/10.1214/16-AOAS1010">doi:10.1214/16-AOAS1010</a>
</p>
</li>
<li>
<p> Pavel N. Krivitsky, Mark S. Handcock, and Martina Morris (2011). "Adjusting for
Network Size and Composition Effects in Exponential-Family Random Graph
Models." <em>Statistical Methodology</em>, 8(4): 319–339. <a href="https://doi.org/10.1016/j.stamet.2011.01.005">doi:10.1016/j.stamet.2011.01.005</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>summary_formula</code>,
<code>summary_formula.ergm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(faux.mesa.high)
fmh.ego &lt;- as.egor(faux.mesa.high)
(nw.summ &lt;- summary(faux.mesa.high~edges+degree(0:3)+nodematch("Race")+
                    nodematch("Sex")+absdiff("Grade")+nodemix("Grade")))

(ego.summ &lt;- summary(fmh.ego~edges+degree(0:3)+nodematch("Race")+nodematch("Sex")+
                     absdiff("Grade")+nodemix("Grade"),
                     scaleto=network.size(faux.mesa.high)))

stopifnot(isTRUE(all.equal(as.vector(nw.summ),as.vector(ego.summ))))


(ego.summ2 &lt;- summary(fmh.ego ~ edges + meandeg + degree(0:2)))
vcov(ego.summ2)

ego.summ2 * 2 # edges and degrees scales, meandeg doesn't
vcov(ego.summ2 * 2)

</code></pre>


</div>