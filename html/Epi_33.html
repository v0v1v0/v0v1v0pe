<div class="container">

<table style="width: 100%;"><tr>
<td>ci.cum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Compute cumulative sum of estimates. </h2>

<h3>Description</h3>

<p>Computes the cumulative sum of parameter functions and the
standard error of it. Used for computing the cumulative rate, or the
survival function based on a <code>glm</code> with parametric baseline.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ci.cum( obj,
    ctr.mat = NULL,
     subset = NULL,
       intl = NULL,
      alpha = 0.05,
        Exp = TRUE,
     ci.Exp = FALSE,
     sample = FALSE )
ci.surv( obj,
    ctr.mat = NULL,
     subset = NULL,
       intl = NULL,
      alpha = 0.05,
        Exp = TRUE,
     sample = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>A model object (of class <code>lm</code>, <code>glm</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctr.mat</code></td>
<td>
<p>Matrix or data frame.
</p>
<p>If <code>ctr.mat</code> is a matrix, it should be a contrast matrix to be
multiplied to the parameter vector, i.e. the desired linear function of
the parameters.
</p>
<p>If it is a data frame it should have columns corresponding to a
prediction data frame for <code>obj</code>, see details for
<code>ci.lin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p> Subset of the parameters of the model to which a matrix
<code>ctr.mat</code> should be applied. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intl</code></td>
<td>
<p> Interval length for the cumulation. Either a constant or a
numerical vector of length <code>nrow(ctr.mat)</code>. If omitted taken as
the difference between the two first elments if the first column in
<code>ctr.mat</code>, assuming that that holds the time scale. A note is
issued in this case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Significance level used when computing confidence limits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Exp</code></td>
<td>
<p>Should the parameter function be exponentiated before it is
cumulated?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.Exp</code></td>
<td>
<p>Should the confidence limits for the cumulative rate be
computed on the log-scale, thus ensuring that exp(-cum.rate) is always
in [0,1]?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample</code></td>
<td>
<p>Should a sample of the original parameters be used to
compute a cumulative rate?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The purpose of <code>ci.cum</code> is to the compute cumulative rate
(integrated intensity) at a set of points based on a model for the
rates. <code>ctr.mat</code> is a matrix which, when premultiplied to the
parameters of the model returns the (log)rates at a set of equidistant
time points. If log-rates are returned from the prediction method for
the model, the they should be exponentiated before cumulated, and the
variances computed accordingly. Since the primary use is for log-linear
Poisson models the <code>Exp</code> parameter defaults to TRUE.
</p>
<p>Each row in the object supplied via <code>ctr.mat</code> is assumed to
represent a midpoint of an interval. <code>ci.cum</code> will then return the
cumulative rates at the <em>end</em> of these intervals. <code>ci.surv</code>
will return the survival probability at the <em>start</em> of each of
these intervals, assuming the the first interval starts at 0 - the first
row of the result is <code>c(1,1,1)</code>.
</p>
<p>The <code>ci.Exp</code> argument ensures that the confidence intervals for the
cumulative rates are always positive, so that exp(-cum.rate) is always
in [0,1].
</p>


<h3>Value</h3>

<p>A matrix with 3 columns: Estimate, lower and upper c.i.  If
<code>sample</code> is TRUE, a single sampled vector is returned, if
<code>sample</code> is numeric a matrix with <code>sample</code> columns is
returned, each column a cumulative rate based on a random sample from
the distribution of the parameter estimates.
</p>
<p><code>ci.surv</code> returns a 3 column matrix with estimate, lower and
upper confidence bounds for the survival function.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p> See also <code>ci.lin</code>, <code>ci.pred</code> </p>


<h3>Examples</h3>

<pre><code class="language-R"># Packages required for this example
library( splines )
library( survival )
data( lung )
par( mfrow=c(1,2) )

# Plot the Kaplan-meier-estimator
plot( survfit( Surv( time, status==2 ) ~ 1, data=lung ) )

# Declare data as Lexis
lungL &lt;- Lexis(exit = list(tfd=time),
               exit.status = (status == 2) * 1,
               data = lung)
summary(lungL)

# Split the follow-up every 10 days
sL &lt;- splitLexis(lungL, "tfd", breaks=seq(0,1100,10))
summary(sL)

# Fit a Poisson model with a natural spline for the effect of time (left
# end points of intervals are used as covariate)
mp &lt;- glm(cbind(lex.Xst == 1, lex.dur)
          ~ Ns(tfd,knots = c(0, 50, 100, 200, 400, 700)),
          family = poisreg,
            data = sL)

# mp is now a model for the rates along the time scale tfd
# prediction data frame for select time points on this time scale
nd &lt;- data.frame(tfd = seq(5,995,10)) # *midpoints* of intervals
Lambda &lt;- ci.cum ( mp, nd, intl=10 )
surv   &lt;- ci.surv( mp, nd, intl=10 )

# Put the estimated survival function on top of the KM-estimator
# recall the ci.surv return the survival at *start* of intervals
matshade(nd$tfd - 5, surv, col = "Red", alpha = 0.15)

# Extract and plot the fitted intensity function
lambda &lt;- ci.pred(mp, nd) * 365.25 # mortality 
matshade(nd$tfd, lambda, log = "y", ylim = c(0.2, 5), plot = TRUE,
          xlab = "Time since diagnosis",
          ylab = "Mortality per year")

# same thing works with gam from mgcv
library(mgcv)
mg &lt;- gam(cbind(lex.Xst == 1, lex.dur) ~ s(tfd), family = poisreg, data=sL )
matshade(nd$tfd - 5, ci.surv(mg, nd, intl=10), plot=TRUE,
         xlab = "Days since diagnosis", ylab="P(survival)")
matshade(nd$tfd  , ci.pred(mg, nd) * 365.25, plot=TRUE, log="y",
         xlab = "Days since diagnosis", ylab="Mortality per 1 py")
</code></pre>


</div>