<div class="container">

<table style="width: 100%;"><tr>
<td>read.odbc.ffdf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Read data from a ODBC connection into an ffdf.</h2>

<h3>Description</h3>

<p>Read data from a ODBC connection into an <code>ffdf</code>. This can for example be used to import
large datasets from Oracle, SQLite, MySQL, PostgreSQL, Hive or other SQL databases into R. <br></p>


<h3>Usage</h3>

<pre><code class="language-R">read.odbc.ffdf(
  query = NULL,
  odbcConnect.args = list(dsn = NULL, uid = "", pwd = ""),
  odbcDriverConnect.args = list(connection = ""),
  odbcQuery.args = list(),
  sqlGetResults.args = list(),
  x = NULL,
  nrows = -1,
  first.rows = NULL,
  next.rows = NULL,
  levels = NULL,
  appendLevels = TRUE,
  asffdf_args = list(),
  BATCHBYTES = getOption("ffbatchbytes"),
  VERBOSE = FALSE,
  colClasses = NULL,
  transFUN = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>the SQL query to execute on the ODBC connection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>odbcConnect.args</code></td>
<td>
<p>a list of arguments to pass to ODBC's <code>odbcConnect</code> (like dsn, uid, pwd). See the examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>odbcDriverConnect.args</code></td>
<td>
<p>a list of arguments to pass to ODBC's <code>odbcDriverConnect</code> (like connection). If you want to 
connect using odbcDriverConnect instead of odbcConnect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>odbcQuery.args</code></td>
<td>
<p>a list of arguments to pass to ODBC's <code>odbcQuery</code>, like rows_at_time. Defaults to an empty list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqlGetResults.args</code></td>
<td>
<p>a list containing optional parameters which will be passed to <code>sqlGetResults</code>.
Defaults to an empty list. The max parameter will be overwritten with first.rows and next.rows when importing in batches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>NULL or an optional ffdf object to which the read records are appended. 
See documentation in <code>read.table.ffdf</code> for more details and the example below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrows</code></td>
<td>
<p>Number of rows to read from the query resultset. Default value of -1 reads in all rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first.rows</code></td>
<td>
<p>chunk size (rows) to read for first chunk from the query resultset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>next.rows</code></td>
<td>
<p>chunk size (rows) to read sequentially for subsequent chunks from the query resultset. Currently, this must be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>optional specification of factor levels. A list with as names the names the columns of the data.frame 
fetched in the first.rows, containing levels of the factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>appendLevels</code></td>
<td>
<p>logical. A vector of permissions to expand levels for factor columns. See documentation in <code>read.table.ffdf</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asffdf_args</code></td>
<td>
<p>further arguments passed to <code>as.ffdf</code> (ignored if 'x' gives an ffdf object)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BATCHBYTES</code></td>
<td>
<p>integer: bytes allowed for the size of the data.frame storing the result of reading one chunk. 
See documentation in <code>read.table.ffdf</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VERBOSE</code></td>
<td>
<p>logical: TRUE to verbose timings for each processed chunk (default FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colClasses</code></td>
<td>
<p>See documentation in <code>read.table.ffdf</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transFUN</code></td>
<td>
<p>function applied to the data frame after each chunk is retreived by <code>sqlGetResults</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional parameters passed on to transFUN</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Opens up the ODBC connection using <code>RODBC::odbcConnect</code> or <code>RODBC::odbcDriverConnect</code>, 
sends the query using <code>RODBC::odbcQuery</code> and retrieves
the results in batches of next.rows rows using <code>RODBC::sqlGetResults</code>. Heavily borrowed from <code>read.table.ffdf</code>
</p>


<h3>Value</h3>

<p>An ffdf object unless the query returns zero records in which case the function will return the data.frame
returned by <code>sqlGetResults</code> and possibly transFUN.
</p>


<h3>See Also</h3>

<p><code>read.table.ffdf, read.dbi.ffdf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##
## Using the sqlite database (smalldb.sqlite3) in the /inst folder of the package
## set up the sqlite ODBC driver (www.stats.ox.ac.uk/pub/bdr/RODBC-manual.pd) 
## and call it 'smalltestsqlitedb' 
##
## Not run: 
require(RODBC)
x &lt;- read.odbc.ffdf(
query = "select * from testdata limit 10000",
odbcConnect.args = list(
 dsn="smalltestsqlitedb", uid = "", pwd = "", 
 believeNRows = FALSE, rows_at_time = 1), 
nrows = -1, 
first.rows = 100, next.rows = 1000, VERBOSE = TRUE)

## End(Not run)
</code></pre>


</div>