<div class="container">

<table style="width: 100%;"><tr>
<td>edecob</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Event DEtection using COnfidence Bounds</h2>

<h3>Description</h3>

<p>Calculate a smoother of longitudinal data of the same measure and bootstrap the errors of the autoregressive
model fitted on the smoother to form simultaneous
confidence bounds of a certain level (mathematical details below).
Define an event if the simultaneous confidence bound is
within a chosen interval for a predefined amount of time. When data from
multiple sources is provided, the calculation will be done separately for
each source.
</p>


<h3>Usage</h3>

<pre><code class="language-R">edecob(
  data,
  smoother = "mov_med",
  resample_method = "all",
  min_change_dur = 84,
  conf_band_lvl = 0.95,
  bt_tot_rep = 100,
  time_unit = "day",
  detect = "below",
  detect_factor = 1,
  bline_period = 14,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame in long format containing the data for which events
is to be detected. This means that each measurement corresponds to a row
and the columns are (in order): source (the device or person from which the
data was collected), point in time, and
measurement value. If custom detection bounds are chosen, the folloing two
columns must be added: lower detection bound, and upper detection bound.
</p>
<p>The source is expected to
be a string; the time point are integers; measurements, and detection bounds are expected to be numerical.
The detection bounds are in absolute value in the same unit as the
values and each is expected to be identical for the same source.
</p>
<p>In case detection is wanted for a one sided change (e.g. give an event if
the confidence bounds drop below a threshold) then the upper or lower detection
bound can be chosen to be Inf or -Inf respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoother</code></td>
<td>
<p>A string specifying which smoother is to be used. Use <code>mov_med</code> for the
moving median. When using the moving median, the parameter <code>med_win</code> must
be given to specify the size of the window over which the moving median is
to be taken. Defaults to the moving median.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resample_method</code></td>
<td>
<p>A string that determines how to resample the errors of the
autoregression for the bootstrap. Default is <code>all</code>, meaning that the epsilon of a
certain time point are resampled from all time points. <code>past</code> only
considers epsilon corresponding to a time point prior to the one being
resampled. <code>window</code> resamples the epsilon from the window given by
<code>resample_win</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_change_dur</code></td>
<td>
<p>The minimal number of time units that the confidence bounds
need to stay inside the detection bounds in order for an event to be
detected. Defaults to 84, i.e. 12 weeks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf_band_lvl</code></td>
<td>
<p>The confidence level for the simultaneous confidence
bands. Defaults to 0.95. When detection of events using only the smoother
is desired, <code>conf_band_lvl</code> can be chosen to be 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bt_tot_rep</code></td>
<td>
<p>The number of iterations for the bootstrap computation. Because of
run time, it is recommended to keep this number below 500. Defaults to 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_unit</code></td>
<td>
<p>A string containing the unit of time used, in singular form.
Defaults to day.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detect</code></td>
<td>
<p>A string specifying how the detection bounds are to be chosen.
<code>below</code>, <code>above</code>, and <code>custom</code> can be chosen. <code>below</code>
detects decreases in value, <code>above</code> detects increases in value, and
<code>custom</code> can be used to manually add detection bounds for each subject.
When <code>above</code> or <code>below</code> are used, the detection bound will be x percent
above or below the median of the first y days, where x is <code>detect_factor</code>
and y is <code>detect period</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detect_factor</code></td>
<td>
<p>A number specifying the factor by which the median of
the fist <code>bline_period</code> days is to be multiplied to obtain the
detection bounds. E.g. 0.9 sets the detection bound 10 percent below the
said median.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bline_period</code></td>
<td>
<p>A number specifying the number of time units from which
data should be taken to calculate the median to obtain the detection bounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters to be given to the function. Possible
parameters for the model are <code>order</code> and <code>min_pts_in_win</code>. For
the moving median, a <code>med_win</code> is required. When resampling from
window, a <code>resample_win</code> may be given.
</p>
<p>The parameter <code>min_pts_in_win</code>
defines the minimal number of
measurements required to be in the time window for the median to be calculated.
Defaults to 1.
</p>
<p>If the parameter <code>order</code> is given, that number will be the (maximal)
order of the autoregressive model. If no <code>order</code> is given, it will be
determined using the Akaike information criterion.
</p>
<p>When the moving
median is used as the smoother, <code>med_win</code> is expected. If no <code>med_win</code> is
given, it will default to <code>c(-42, 42)</code>.
</p>
<p>When resampling from window, one can choose the window size for the
resampling window with <code>resample_win</code> by giving a window like e.g. <code>c(-14,14)</code>..</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For the moving median, the med_win is the total size of the window, meaning
that for the value corresponding to day x, the data points from day
x + <code>med_win[1]</code> to x + <code>med_win[2]</code> will be used for the calculation
of the median.
</p>
<p>If there is no data for two times <code>med_win[2]-med_win[1]</code> consecutive time units, there
will be time points at which no confidence bound can be calculated. In this
case, it will be assumed that the confidence bound is outside of the
detection interval when detecting sustained change.
</p>
<p>In case there are multiple instances where the algorithm would detect a
sustained change (i.e. if after the first sustained change the confidence
bounds leave the detection interval and then return into it
for longer than <code>min_change_dur</code> time units) then only the first
sustained change would be detected.
</p>
<p>Please note that the event onset could be on a date where there are no actual
measurements. This can happen when there is a gap in the data. In this case, the
confidence bounds will extend into the gap.
If the confidence bounds in this period are outside the detection interval and
remain outside for the next <code>min_change_duration</code> time units,
the event onset will be in this gap.
</p>
<p>The censoring date is based on the last date where the confidence bounds can be
calculated. We do not extend the confidence bounds to the last data point so
that the confidence bounds don't change in case we obtain new measurements
with time points later than the latest time point at which we have a measurement.
</p>
<p>The <code>edecob</code> function runs the functions <code>mov_med</code>, <code>smoother_resid</code>,
<code>bt_smoother</code>, <code>conf_band</code>, and <code>detect_event</code> in this order
for all subjects given. If desired, the functions can also manually be
applied for the data to obtain e.g. the confidence bands. Note that in order
to run one of these functions, the output of the previous functions are needed.
</p>


<h3>Value</h3>

<p>The output <code>data</code> is a list containing as many elements as
the number of sources in <code>data</code> plus one. Every element in this list
will again be a list named after the corresponding sources. Each of
these lists contains the following elements: </p>

<dl>
<dt><code>event</code></dt>
<dd>
<p>gives a list with four values: <code>event_detected</code>,
<code>event_onset</code>, <code>event_duration</code>, and <code>event_stop</code>.
</p>
<dl>
<dt><code>event_detected</code></dt>
<dd>
<p>gives
whether an event was detected</p>
</dd>
<dt><code>event_onset</code></dt>
<dd>
<p>gives the first time point at which the upper or lower bound
of the confidence band is inside the detection bounds, and after which it
stays inside the detection bounds for at least <code>min_change_dur</code>
consecutive time units</p>
</dd> <dt><code>event_duration</code></dt>
<dd>
<p>gives the number of time units the upper or lower bound
of the confidence band stays inside the detection bounds
after <code>event_onset</code></p>
</dd> <dt><code>event_stop</code></dt>
<dd>
<p>gives whether the confidence
bounds stay inside the detection bounds until
the last time point at which we can calculate the confidence bound or not.</p>
</dd>
</dl>
</dd>
<dt><code>conf_band</code></dt>
<dd>
<p>gives a data frame containing the confidence bands.
The columns are source, time point, lower bound, and upper
bound of the confidence band.</p>
</dd>
<dt><code>smoother_pts</code></dt>
<dd>
<p>gives a data frame containing the smoother.
The columns are source, time point, and the smoother</p>
</dd>
<dt><code>data</code></dt>
<dd>
<p>gives the data but with four additional columns:
<code>event_detected</code>, <code>event_onset</code>, <code>event_duration</code>, and
<code>event_stop</code>. They contain the same values as in <code>event</code>.</p>
</dd>
<dt><code>detec_lower</code></dt>
<dd>
<p>gives the lower detection bound.</p>
</dd>
<dt><code>detec_upper</code></dt>
<dd>
<p>gives the upper detection bound.</p>
</dd>
<dt><code>smoother</code></dt>
<dd>
<p>gives the smoother used.</p>
</dd>
<dt><code>resample_method</code></dt>
<dd>
<p>gives the resampling method used for the bootstrap.</p>
</dd>
<dt><code>min_change_dur</code></dt>
<dd>
<p>gives the smallest consecutive number of time units
the confidence bounds must stay within the detection bounds in order for an event to be detected.</p>
</dd>
<dt><code>conf_band_lvl</code></dt>
<dd>
<p>gives the level of the simultaneous confidence band.</p>
</dd>
<dt><code>bt_tot_rep</code></dt>
<dd>
<p>gives the total amount of bootstrap repetitions performed.</p>
</dd>
<dt><code>call</code></dt>
<dd>
<p>gives the function call.</p>
</dd>
<dt><code>col_names</code></dt>
<dd>
<p>gives the original column names of the data.</p>
</dd>
<dt><code>time_unit</code></dt>
<dd>
<p>gives the unit of time used.</p>
</dd>
</dl>
<p>The last element in the output <code>data</code> is called <code>event_info</code> and
is a data frame containing the information from <code>event</code> from each
patient. <code>event_info</code> will thus have the following columns:
<code>source</code>, <code>event_detected</code>, <code>event_onset</code>,
<code>event_duration</code>, and <code>event_stop</code>.
</p>


<h3>Mathematical background</h3>

<p>The mathematical background will be explained in the following sections.
</p>


<h3>Moving Median</h3>

<p>Consider a sample <code class="reqn">X_1,\dots, X_n</code> of size <code class="reqn">n</code> and the
reordering <code class="reqn">X_{(1)},\dots, X_{(n)}</code> such
that <code class="reqn">X_{(1)} \le X_{(2)} \le \dots \le X_{(n)}</code>, commonly
called the order statistic. Then for <code class="reqn">n</code> even the median usually
defined as </p>
<p style="text-align: center;"><code class="reqn">median(X_1,\dots, X_n) = X_{(k)}, \mathrm{where} \; k = n/2.</code>
</p>
<p> In the
case where <code class="reqn">n</code> is odd the median is
defined as </p>
<p style="text-align: center;"><code class="reqn">median(X_1,\dots, X_n) = 1/2(X_{(k)} + X_{(k+1)}), \mathrm{where} \; k = n/2.</code>
</p>
<p> Let the
study days at which the measurements <code class="reqn">X_1, \dots, X_n</code> were taken
be <code class="reqn">t_1, \dots, t_n</code>.
Let <code class="reqn">T</code> a fixed positive amount of time. Then the moving median at time
point <code class="reqn">t</code> with window size <code class="reqn">T</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">S(t) = median({X_j | t - T/2 \le t_j \le t + T/2}).</code>
</p>



<h3>The Model</h3>

<p>An autoregressive (AR) model is used to model the residuals of the smoother <code class="reqn">\eta</code>:
</p>
<p style="text-align: center;"><code class="reqn">Y(t) = S(t) + \eta(t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\eta(t) = \sum^p_{j = 1} \phi_j \eta(t - j) + \epsilon</code>
</p>
<p> where
variable <code class="reqn">t</code> is the study day, <code class="reqn">Y(t)</code> the data point at study day <code class="reqn">t</code>,
<code class="reqn">S(t)</code> a smoother, <code class="reqn">\eta(t)</code> the difference between the smoother
and the measurement at study day <code class="reqn">t</code>, <code class="reqn">p</code>
the order of the AR model, <code class="reqn">\phi_j</code> the coefficients of the AR model, and
<code class="reqn">\epsilon</code> the error of the AR model. The order is calculated using the
Akaike information criterion (AIC) if it was not given in the function call.
</p>


<h3>Bootstrap</h3>

<p>In the following, the star * denotes a bootstrapped value. The bootstrap
procedure is as follows:
</p>

<ol>
<li>
<p> Compute the smoother <code class="reqn">S(t)</code>.
</p>
</li>
<li>
<p> Compute the residuals <code class="reqn">\eta(t_i) = Y(t_i) - S(t_i)</code>.
</p>
</li>
<li>
<p> Fit an AR(p) model to <code class="reqn">\eta(t_i)</code> to obtain the coefficients
<code class="reqn">\phi_1,\dots, \phi_p</code> and <code class="reqn">\epsilon(t_i) = \eta(t_i) -
    \sum^p_{j = 1} \phi_j \eta(t_i - t_{i-j})</code> the error of the AR model.
</p>
</li>
<li>
<p> Randomly choose a <code class="reqn">\epsilon(t_i)^*</code> with replacement from <code class="reqn">\epsilon(t_{p+1}),\dots,
    \epsilon(t_n)</code> to obtain </p>
<p style="text-align: center;"><code class="reqn">Y(t_i)^* = S(t_i) + \eta(t_i)^*,</code>
</p>
<p> where  </p>
<p style="text-align: center;"><code class="reqn">\eta(t_i)^* = \sum^p_{j = 1} \phi_j \eta(t_{i-j})^*+ \epsilon(t_{i-j})^*</code>
</p>
<p> the bootstrapped residuals of the smoother.
</p>
</li>
<li>
<p> Compute <code class="reqn">S(.)^* = g(Y(t_1),\dots, Y(t_n))</code> where <code class="reqn">g</code> is the
function with which the smoother is calculated.
</p>
</li>
<li>
<p> Repeat steps 4 and 5 <code>bt_tot_rep</code> times to obtain <code class="reqn">S(t_i)^*_b</code> for <code class="reqn">\beta = 1,\dots,</code>
<code>bt_tot_rep</code>.
</p>
</li>
</ol>
<h3>Calculation of the Confidence Bounds</h3>

<p>The confidence bounds are calculated as follows:
</p>

<ol>
<li>
<p> We compute the quantiles </p>
<p style="text-align: center;"><code class="reqn"> q_x(t_i), q_{1-x}(t_i) i = 1,\dots, N</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">q_x(t_i) = inf\left\{u; P^*[S(t_i)^*_b - S(t_i) \le u] \ge x\right\} </code>
</p>
<p> is a
pointwise bootstrap quantile, <code class="reqn">S(t_i)^*_b</code> the bootstrapped smoother,
and <code class="reqn">N</code> the number of measurements or rows in <code>data</code>, in our case the number of rows.
</p>
</li>
<li>
<p> We vary the pointwise error <code class="reqn">x</code> until </p>
<p style="text-align: center;"><code class="reqn">P^*[q_x(t_i) \le S(t_i)^*_b - S(t_i) \le q_{1-x}(t_i) \forall i = 1,\dots, N] \approx 1-\alpha.</code>
</p>

<p>In other words, until the ratio of bootstrap curves that have all their points within
<code class="reqn">[q_x(t_i), q_{1-x}(t_i)]</code> is approximately <code class="reqn">1-\alpha</code>.
</p>
</li>
<li>
<p> We define
</p>
<p style="text-align: center;"><code class="reqn"> I_n(t_i) = [S(t_i) +  q_x(t_i), S(t_i) + q_{1-x}(t_i)] \forall i = 1,\dots, N</code>
</p>

<p>the confidence bounds. Then <code class="reqn">{I_n(t_i); i = 1,\dots, N}</code> is a consistent simultaneous confidence band of level <code class="reqn">1-\alpha</code>.
</p>
</li>
</ol>
<h3>References</h3>

<p>Bühlmann, P. (1998). Sieve Bootstrap for Smoothing in
Nonstationary Time Series. <em>The Annals of Statistics</em>, 26(1), 48-83.
</p>
<p>Hogg, R., McKean, J. and Craig, A. (2014).
<em>Introduction to mathematical statistics.</em> Harlow: Pearson Education.
</p>


<h3>See Also</h3>

<p><code>summary.edecob</code>, <code>plot.edecob</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(edecob)

# Let us examine the example_data dataset
head(example_data, 3)
#&gt;     subject study_day jump_height
#&gt; 1 Subject 1         1    58.13024
#&gt; 2 Subject 1         5    59.48988
#&gt; 3 Subject 1         9    54.14774

# We apply the main fuction of the package onto our example_data
example_event &lt;- edecob(example_data, med_win = c(-21,21), bt_tot_rep = 10,
                        min_change_dur = 70)
names(example_event)
#&gt; [1] "Subject 1"  "Subject 2"  "event_info"

# example_event contains the event data for each source
plot(example_event$`Subject 1`)
plot(example_event$`Subject 2`)

# example_event also contains a data frame containing the event information for all patients
example_event$event_info
#&gt;           event_detected event_onset event_duration event_stop
#&gt; Subject 1           TRUE         119            134       TRUE
#&gt; Subject 2          FALSE         306             60      FALSE

# Using this data frame, we can draw a survival plot
library("survival")
plot(survfit(Surv(time = event_onset, event = event_detected) ~ 1,
             data = example_event$event_info),
     conf.int = FALSE, xlim = c(0,350), ylim = c(0,1), mark.time = TRUE,
     xlab = "Time point", ylab = "Survival probability", main = "Survival plot")
</code></pre>


</div>