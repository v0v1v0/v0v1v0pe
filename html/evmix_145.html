<div class="container">

<table style="width: 100%;"><tr>
<td>kernels</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kernel functions</h2>

<h3>Description</h3>

<p>Functions for commonly used kernels for kernel density estimation. The
density and cumulative distribution functions are provided.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kdgaussian(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kduniform(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kdtriangular(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kdepanechnikov(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kdbiweight(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kdtriweight(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kdtricube(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kdparzen(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kdcosine(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kdoptcosine(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kpgaussian(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kpuniform(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kptriangular(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kpepanechnikov(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kpbiweight(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kptriweight(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kptricube(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kpparzen(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kpcosine(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kpoptcosine(x = 0, lambda = NULL, bw = NULL, kerncentres = 0)

kdz(z, kernel = "gaussian")

kpz(z, kernel = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>location to evaluate KDE (single scalar or vector)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>bandwidth for kernel (as half-width of kernel) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>bandwidth for kernel (as standard deviations of kernel) or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kerncentres</code></td>
<td>
<p>kernel centres (typically sample data vector or scalar)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>standardised location put into kernel <code>z = (x-kerncentres)/lambda</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>kernel name (<code>default = "gaussian"</code>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Functions for the commonly used kernels for kernel density estimation. The
density and cumulative distribution functions are provided. Each function can accept the
bandwidth specified as either:
</p>

<ol>
<li> <p><code>bw</code> - in terms of number of standard deviations of the kernel, consistent
with the defined values in the <code>density</code> function in
the <code>R</code> base libraries
</p>
</li>
<li> <p><code>lambda</code> - in terms of half-width of kernel
</p>
</li>
</ol>
<p>If both bandwidths are given as <code>NULL</code> then the default bandwidth is <code>lambda=1</code>. If
either one is specified then this will be used. If both are specified then <code>lambda</code>
will be used.
</p>
<p>All the kernels have bounded support <code class="reqn">[-\lambda, \lambda]</code>, except the normal
(<code>"gaussian"</code>) which is unbounded. In the latter, both bandwidths are the same
<code>bw=lambda</code> and equal to the standard deviation.
</p>
<p>Typically,a single location <code>x</code> at which to evaluate kernel is given along with
vector of kernel centres. As such, they are designed to be used with 
<code>sapply</code> to loop over vector of locations at which to evaluate KDE. 
Alternatively, a vector of locations <code>x</code> can be given with a single scalar kernel centre
<code>kerncentres</code>, which is commonly used when locations are pre-standardised by
<code>(x-kerncentres)/lambda</code> and <code>kerncentre=0</code>. A warnings is given if both the
evaluation locations and kernel centres are vectors as this is not often needed so is
likely to be a user error.
</p>
<p>If no kernel centres are provided then by default it is set to zero (i.e. x is at middle of kernel).
</p>
<p>The following kernels are implemented, with relevant ones having definitions
consistent with those of the <code>density</code> function,
except where specified:
</p>

<ul>
<li> <p><code>gaussian</code> or <code>normal</code>
</p>
</li>
<li> <p><code>uniform</code> or <code>rectangular</code> - same as <code>"rectangular"</code> in 
<code>density</code> function
</p>
</li>
<li> <p><code>triangular</code>
</p>
</li>
<li> <p><code>epanechnikov</code>
</p>
</li>
<li> <p><code>biweight</code>
</p>
</li>
<li> <p><code>triweight</code>
</p>
</li>
<li> <p><code>tricube</code>
</p>
</li>
<li> <p><code>parzen</code>
</p>
</li>
<li> <p><code>cosine</code>
</p>
</li>
<li> <p><code>optcosine</code>
</p>
</li>
</ul>
<p>The kernel densities are all normalised to unity. See Wikipedia reference below
for their definitions.
</p>
<p>Each kernel's functions can be called individually, or the global functions
<code>kdz</code> and <code>kpz</code> for the density and
cumulative distribution function can apply any particular kernel which is specified by the
<code>kernel</code> input. These global functions take the standardised locations
<code>z = (x - kerncentres)/lambda</code>.
</p>


<h3>Value</h3>

<p>codekd*  and <code>kp*</code> give the
density and cumulative distribution functions for each kernel respectively, where
<code>*</code> is the kernel name. <code>kdz</code> and
<code>kpz</code> are the equivalent global functions for all of the 
kernels.
</p>


<h3>Author(s)</h3>

<p>Carl Scarrott <a href="mailto:carl.scarrott@canterbury.ac.nz">carl.scarrott@canterbury.ac.nz</a>.
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Kernel_density_estimation">http://en.wikipedia.org/wiki/Kernel_density_estimation</a>
</p>
<p><a href="http://en.wikipedia.org/wiki/Kernel_(statistics)">http://en.wikipedia.org/wiki/Kernel_(statistics)</a>
</p>
<p>Wand, M. and Jones, M.C. (1995). Kernel Smoothing. Chapman &amp;&amp; Hall.
</p>


<h3>See Also</h3>

<p><code>density</code>, <code>kden</code>
and <code>bckden</code>.
</p>
<p>Other kernels: <code>kfun</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">xx = seq(-2, 2, 0.01)
plot(xx, kdgaussian(xx), type = "l", col = "black",ylim = c(0, 1.2))
lines(xx, kduniform(xx), col = "grey")
lines(xx, kdtriangular(xx), col = "blue")
lines(xx, kdepanechnikov(xx), col = "darkgreen")
lines(xx, kdbiweight(xx), col = "red")
lines(xx, kdtriweight(xx), col = "purple")
lines(xx, kdtricube(xx), col = "orange")
lines(xx, kdparzen(xx), col = "salmon")
lines(xx, kdcosine(xx), col = "cyan")
lines(xx, kdoptcosine(xx), col = "goldenrod")
legend("topright", c("Gaussian", "uniform", "triangular", "Epanechnikov",
"biweight", "triweight", "tricube", "Parzen", "cosine", "optcosine"), lty = 1,
col = c("black", "grey", "blue", "darkgreen", "red", "purple", "orange",
  "salmon", "cyan", "goldenrod"))

</code></pre>


</div>