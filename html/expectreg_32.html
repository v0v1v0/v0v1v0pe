<div class="container">

<table style="width: 100%;"><tr>
<td>Mqreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Semiparametric M-Quantile Regression
</h2>

<h3>Description</h3>

<p>Robust M-quantiles are estimated using an iterative penalised reweighted least squares approach.
Effects using quadratic penalties can be included, such as P-splines, Markov random fields or Kriging.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Mqreg(formula, data = NULL, smooth = c("schall", "acv", "fixed"), 
      estimate = c("iprls", "restricted"),lambda = 1, tau = NA, robust = 1.345,
      adaptive = FALSE, ci = FALSE, LSMaxCores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>An R formula object consisting of the response variable, '~'
and the sum of all effects that should be taken into consideration.
Each effect has to be given through the function <code>rb</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Optional data frame containing the variables used in the model, if the data is not explicitely given in the
formula.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate</code></td>
<td>

<p>Character string defining the estimation method that is used to fit the expectiles. Further detail on all available methods is given below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>

<p>There are different smoothing algorithms that should prevent overfitting.
The 'schall' algorithm iterates the smoothing penalty <code>lambda</code> until it converges,
the asymmetric cross-validation 'acv' minimizes a score-function using <code>nlm</code>
or the function uses a fixed penalty.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>The fixed penalty can be adjusted. Also serves as starting value for
the smoothing algorithms.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>In default setting, the expectiles (0.01,0.02,0.05,0.1,0.2,0.5,0.8,0.9,0.95,0.98,0.99) are calculated.
You may specify your own set of expectiles in a vector. The option may be set to 'density' for the calculation
of a dense set of expectiles that enhances the use of <code>cdf.qp</code> and <code>cdf.bundle</code> afterwards.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>

<p>Robustness constant in M-estimation. See <code>Details</code> for definition.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>

<p>Logical. Whether the robustness constant is adapted along the covariates.  	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>

<p>Whether a covariance matrix for confidence intervals and the summary function is calculated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LSMaxCores</code></td>
<td>

<p>How many cores should maximal be used by parallelization
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the least squares approach the following loss function is minimised:
</p>
<p><code class="reqn"> S = \sum_{i=1}^{n}{ w_p(y_i - m_i(p))^2} </code>
</p>
<p>with weights
</p>
<p><code class="reqn"> w_p(u) = (-(1-p)*c*(u_i&lt; -c)+(1-p)*u_i*(u_i&lt;0 \&amp; u_i&gt;=-c)+p*u_i*(u_i&gt;=0 \&amp; u_i&lt;c)+p*c*(u_i&gt;=c)) / u_i </code>
</p>
<p>for quantiles and
</p>
<p><code class="reqn"> w_p(u) = -(1-p)*c*(u_i&lt; -c)+(1-p)*u_i*(u_i&lt;0 \&amp; u_i&gt;=-c)+p*u_i*(u_i&gt;=0 \&amp; u_i&lt;c)+p*c*(u_i&gt;=c) </code>
</p>
<p>for expectiles, with standardised residuals <code class="reqn">u_i = 0.6745*(y_i - m_i(p)) / median(y-m(p))</code> and robustness constant c.
</p>


<h3>Value</h3>

<p>An object of class 'expectreg', which is basically a list consisting of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda </code></td>
<td>
<p>The final smoothing parameters for all expectiles and for all effects in a list.
For the restricted and the bundle regression there are only the mean and the residual lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercepts </code></td>
<td>
<p>The intercept for each expectile.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p> A matrix of all the coefficients, for each base element
a row and for each expectile a column. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p> The fitted values for each observation and all expectiles,
separately in a list for each effect in the model,
sorted in order of ascending covariate values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p> Vector of the response variable. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p> List with the values of the covariates. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p> The formula object that was given to the function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asymmetries</code></td>
<td>
<p> Vector of fitted expectile asymmetries as given by argument <code>expectiles</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effects</code></td>
<td>
<p> List of characters giving the types of covariates. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>helper</code></td>
<td>
<p> List of additional parameters like neighbourhood structure for spatial effects or 'phi' for kriging. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p> Complete design matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p> Fitted values <code class="reqn"> \hat{y} </code>. </p>
</td>
</tr>
</table>
<p><code>plot</code>, <code>predict</code>, <code>resid</code>,
<code>fitted</code>, <code>effects</code>
and further convenient methods are available for class 'expectreg'.
</p>


<h3>Author(s)</h3>

<p>Monica Pratesi <br>
University Pisa <br><a href="https://www.unipi.it">https://www.unipi.it</a> <br></p>
<p>M. Giovanna Ranalli <br>
University Perugia <br><a href="https://www.unipg.it">https://www.unipg.it</a> <br></p>
<p>Nicola Salvati <br>
University Perugia <br><a href="https://www.unipg.it">https://www.unipg.it</a> <br></p>
<p>Fabian Otto-Sobotka <br>
University Oldenburg <br><a href="https://uol.de">https://uol.de</a> <br></p>


<h3>References</h3>

<p>Pratesi M, Ranalli G and Salvati N (2009)
<em>Nonparametric M-quantile regression using penalised splines</em>
Journal of Nonparametric Statistics, 21:3, 287-304.
</p>
<p>Otto-Sobotka F, Ranalli G, Salvati N, Kneib T (2019)
<em>Adaptive Semiparametric M-quantile Regression</em>
Econometrics and Statistics 11, 116-129.
</p>


<h3>See Also</h3>

<p><code>expectreg.ls</code>, <code>rqss</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data("lidar", package = "SemiPar")

m &lt;- Mqreg(logratio~rb(range,"pspline"),data=lidar,smooth="f",
                        tau=c(0.05,0.5,0.95),lambda=10)
plot(m,rug=FALSE)

</code></pre>


</div>