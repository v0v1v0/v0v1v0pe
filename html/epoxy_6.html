<div class="container">

<table style="width: 100%;"><tr>
<td>epoxy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Epoxy string interpolation</h2>

<h3>Description</h3>

<p>These functions power the knitr chunk engines and are wrappers around
<code>glue::glue()</code>, with a few extra conveniences provided by <span class="pkg">epoxy</span>.
</p>

<ul>
<li> <p><code>epoxy()</code> is super <code>glue::glue()</code>.
</p>
</li>
<li> <p><code>epoxy_html()</code> is super <code>glue::glue()</code> with HTML-specific defaults.
</p>
</li>
<li> <p><code>epoxy_latex()</code> is super <code>glue::glue()</code> with LaTeX-specific defaults.
</p>
</li>
</ul>
<p>Each of these functions can be called directly or used as a knitr chunk
engine where the chunk text is handled as if it were a string passed into the
function version. When used as a knitr chunk engine, the function arguments
can be passed in as chunk options.
</p>
<p>All of <code>epoxy()</code>, <code>epoxy_html()</code> and <code>epoxy_latex()</code> use
<code>epoxy_transform_inline()</code> by default. This transformer brings a concise
inline-formatting syntax that you can read more about in
<code>?epoxy_transform_inline</code>.
</p>
<p><code>epoxy_html()</code> also includes an inline transformation syntax that makes it
easier to wrap the expression text in HTML elements with a specific ID or
a set of classes. Learn more about this syntax in <code>?epoxy_transform_html</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">epoxy(
  ...,
  .data = NULL,
  .sep = "",
  .envir = parent.frame(),
  .open = "{",
  .close = "}",
  .na = "",
  .null = "",
  .comment = character(),
  .literal = FALSE,
  .trim = FALSE,
  .transformer = NULL,
  .collapse = NULL,
  .style = lifecycle::deprecated()
)

epoxy_html(
  ...,
  .data = NULL,
  .sep = "",
  .envir = parent.frame(),
  .open = "{{",
  .close = "}}",
  .na = "",
  .null = "",
  .comment = "",
  .literal = FALSE,
  .trim = FALSE,
  .transformer = NULL,
  .collapse = NULL
)

epoxy_latex(
  ...,
  .data = NULL,
  .sep = "",
  .envir = parent.frame(),
  .open = "&lt;&lt;",
  .close = "&gt;&gt;",
  .na = "",
  .null = "",
  .comment = "",
  .literal = FALSE,
  .trim = FALSE,
  .transformer = NULL,
  .collapse = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>[<code>expressions</code>]<br> Unnamed arguments are taken to be expression
string(s) to format. Multiple inputs are concatenated together before formatting.
Named arguments are taken to be temporary variables available for substitution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>A data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.sep</code></td>
<td>
<p>[<code>character(1)</code>: ‘""’]<br> Separator used to separate elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.envir</code></td>
<td>
<p>[<code>environment</code>: <code>parent.frame()</code>]<br> Environment to evaluate each expression in. Expressions are
evaluated from left to right. If <code>.x</code> is an environment, the expressions are
evaluated in that environment and <code>.envir</code> is ignored. If <code>NULL</code> is passed, it is equivalent to <code>emptyenv()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.open</code></td>
<td>
<p>[<code>character(1)</code>: ‘\{’]<br> The opening delimiter around
the template variable or expression. Doubling the full delimiter escapes
it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.close</code></td>
<td>
<p>[<code>character(1)</code>: ‘\}’]<br> The closing delimiter
around the template variable or expression. Doubling the full delimiter
escapes it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.na</code></td>
<td>
<p>[<code>character(1)</code>: ‘NA’]<br> Value to replace <code>NA</code> values
with. If <code>NULL</code> missing values are propagated, that is an <code>NA</code> result will
cause <code>NA</code> output. Otherwise the value is replaced by the value of <code>.na</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.null</code></td>
<td>
<p>[<code>character(1)</code>: ‘character()’]<br> Value to replace
NULL values with. If <code>character()</code> whole output is <code>character()</code>. If
<code>NULL</code> all NULL values are dropped (as in <code>paste0()</code>). Otherwise the
value is replaced by the value of <code>.null</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.comment</code></td>
<td>
<p>[<code>character(1)</code>: ‘#’]<br> Value to use as the comment
character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.literal</code></td>
<td>
<p>[<code>boolean(1)</code>: ‘FALSE’]<br> Whether to treat single or
double quotes, backticks, and comments as regular characters (vs. as
syntactic elements), when parsing the expression string. Setting <code>.literal = TRUE</code> probably only makes sense in combination with a custom
<code>.transformer</code>, as is the case with <code>glue_col()</code>. Regard this argument
(especially, its name) as experimental.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.trim</code></td>
<td>
<p>[<code>logical(1)</code>: ‘TRUE’]<br> Whether to trim the input
template with <code>trim()</code> or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.transformer</code></td>
<td>
<p>A transformer function or transformer chain created with
<code>epoxy_transform()</code>. Alternatively, a character vector of epoxy transformer
names, e.g. <code>c("bold", "collapse")</code> or a list of epoxy transformers, e.g.
<code>list(epoxy_transform_bold(), epoxy_transform_collapse())</code>.
</p>
<p>In <span class="pkg">epoxy</span>, you'll most likely want to use the defaults or consult
<code>epoxy_transform()</code> for more information. See also <code>glue::glue()</code> for more
information on transformers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.collapse</code></td>
<td>
<p>A character string used to collapse a vector result into a
single value. If <code>NULL</code> (the default), the result is not collapsed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.style</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a> Please use <code>.transformer</code>
instead.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a transformed string, using <code>glue::glue()</code> but with the
additional transformers provided to the <code>.transformer</code> argument of
<code>epoxy()</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>use_epoxy_knitr_engines()</code> for knitr engines powered by these epoxy
functions.
</p>
</li>
<li> <p><code>epoxy_mustache()</code> for more powerful templating needs when you don't
need epoxy's inline formatting syntax.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">movie &lt;- bechdel[1, ]
movies &lt;- bechdel[2:4, ]

# A basic example with a single row of data
epoxy("{.emph movie$title} ({movie$year}) was directed by {movie$director}.")

# Or vectorized over multiple rows of data
epoxy("* {.emph movies$title} ({movies$year}) was directed by {movies$director}.")

# You can provide the data frame to `.data` to avoid repeating `data$`
epoxy("{.emph title} ({year}) was directed by {director}.", .data = movie)
epoxy("* {.emph title} ({year}) was directed by {director}.", .data = movies)

# Inline transformers can be nested
epoxy("I'd be happy to watch {.or {.italic title}}.", .data = movies)
epoxy("They were directed by {.and {.bold director}}.", .data = movies)

# Learn more about inline transformers in ?epoxy_transform_inline
epoxy("The budget for {.emph title} was {.dollar budget}.", .data = movie)

# --------- HTML and LaTeX variants ---------
# There are also HTML and LaTeX variants of epoxy.
# Each uses default options that are most natural for the format.

# epoxy_html() uses `{{ expr }}` for delimiters
epoxy_html("I'd be happy to watch {{ title }}.", .data = movie)
# It also supports an HTML transformer syntax
epoxy_html("I'd be happy to watch {{em.movie-title title}}.", .data = movie)
# Or use the inline transformer syntax, which uses `@` instead of `.` in HTML
epoxy_html("I'd be happy to watch {{@or {{@emph title}} }}.", .data = movies)

# epoxy_latex() uses `&lt;&lt; expr &gt;&gt;` for delimiters
epoxy_latex("I'd be happy to watch &lt;&lt;.or &lt;&lt;.emph title &gt;&gt; &gt;&gt;.", .data = movies)
</code></pre>


</div>