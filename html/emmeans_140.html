<div class="container">

<table style="width: 100%;"><tr>
<td>update.emmGrid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Update an <code>emmGrid</code> object</h2>

<h3>Description</h3>

<p>Objects of class <code>emmGrid</code> contain several settings that affect such things as
what arguments to pass to <code>summary.emmGrid</code>. 
The <code>update</code> method allows safer management of these settings than
by direct modification of its slots.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'emmGrid'
update(object, ..., silent = FALSE)

## S3 replacement method for class 'emmGrid'
levels(x) &lt;- value

## S3 method for class 'summary_emm'
update(object, by.vars, mesg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An <code>emmGrid</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Options to be set. These must match a list of known options (see
Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Logical value. If <code>FALSE</code> (the default), a message is
displayed if any options are not matched. If <code>TRUE</code>, no messages are
shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an <code>emmGrid</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p><code>list</code> or replacement levels. See the documentation for
<code>update.emmGrid</code> with the <code>levels</code> argument, 
as well as the section below on “Replaciong levels”</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by.vars, mesg</code></td>
<td>
<p>Attributes that can be altered in <code>update.summary_emm</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an updated <code>emmGrid</code> object.
</p>
<p><code>levels&lt;-</code> replaces the levels of the object in-place.
See the section on replacing levels for details.
</p>


<h3>Details</h3>

<p>The names in <code>...</code> are partially matched against those that are valid, and if a match is found, it adds or replaces the current setting. The valid names are
</p>

<dl>
<dt>
<code>tran</code>, <code>tran2</code>
</dt>
<dd>
<p>(<code>list</code> or <code>character</code>) specifies
the transformation which, when inverted, determines the results displayed by
<code>summary.emmGrid</code>, <code>predict.emmGrid</code>, or <code>emmip</code> when
<code>type="response"</code>. The value may be the name of a standard
transformation from <code>make.link</code> or additional ones supported by
name, such as <code>"log2"</code>; or, for a custom transformation, a <code>list</code>
containing at least the functions <code>linkinv</code> (the inverse of the
transformation) and <code>mu.eta</code> (the derivative thereof). The
<code>make.tran</code> function returns such lists for a number of popular
transformations. See the help page of <code>make.tran</code> for details as
well as information on the additional named transformations that are
supported. <code>tran2</code> is just like <code>tran</code> except it is a second
transformation (i.e., a response transformation in a generalized linear
model).</p>
</dd>
<dt><code>tran.mult</code></dt>
<dd>
<p>Multiple for <code>tran</code>. For example, for the
response transformation ‘<span class="samp">⁠2*sqrt(y)⁠</span>’ (or ‘<span class="samp">⁠sqrt(y) + sqrt(y + 1)⁠</span>’,
for that matter), we should have <code>tran = "sqrt"</code> and <code>tran.mult =
2</code>. If absent, a multiple of 1 is assumed.</p>
</dd>
<dt><code>tran.offset</code></dt>
<dd>
<p>Additive constant before a transformation is applied.
For example, a response transformation of <code>log(y + pi)</code> has
<code>tran.offset  = pi</code>. If no value is present, an offset of 0 is assumed.</p>
</dd>
<dt><code>estName</code></dt>
<dd>
<p>(<code>character</code>) is the column label used for
displaying predictions or EMMs.</p>
</dd>
<dt><code>inv.lbl</code></dt>
<dd>
<p>(<code>character)</code>) is the column label to use for
predictions or EMMs when <code>type="response"</code>.</p>
</dd>
<dt><code>by.vars</code></dt>
<dd>
<p>(<code>character)</code> vector or <code>NULL</code>) the variables
used for grouping in the summary, and also for defining subfamilies in a call
to <code>contrast</code>.</p>
</dd>
<dt><code>pri.vars</code></dt>
<dd>
<p>(<code>character</code> vector) are the names of the grid
variables that are not in <code>by.vars</code>. Thus, the combinations of their
levels are used as columns in each table produced by <code>summary.emmGrid</code>.</p>
</dd>
<dt><code>alpha</code></dt>
<dd>
<p>(numeric) is the default significance level for tests, in
<code>summary.emmGrid</code> as well as <code>plot.emmGrid</code>
when ‘<span class="samp">⁠CIs = TRUE⁠</span>’. Be cautious that methods that depend on
specifying <code>alpha</code> are prone to abuse. See the
discussion in <a href="../doc/basics.html#pvalues"><code>vignette("basics", "emmeans")</code></a>.</p>
</dd>
<dt><code>adjust</code></dt>
<dd>
<p>(<code>character)</code>) is the default for the <code>adjust</code>
argument in <code>summary.emmGrid</code>.</p>
</dd>
<dt><code>cross.adjust</code></dt>
<dd>
<p>(<code>character)</code>) is the default for the <code>cross.adjust</code>
argument in <code>summary.emmGrid</code> (used for adjusting between groups).</p>
</dd>
<dt><code>famSize</code></dt>
<dd>
<p>(integer) is the number of means involved in a family of
inferences; used in Tukey adjustment</p>
</dd>
<dt><code>infer</code></dt>
<dd>
<p>(<code>logical</code> vector of length 2) is the default value
of <code>infer</code> in <code>summary.emmGrid</code>.</p>
</dd>
<dt><code>level</code></dt>
<dd>
<p>(numeric) is the default confidence level, <code>level</code>,
in <code>summary.emmGrid</code>. <em>Note:</em> You must specify all five letters 
of ‘level’ to distinguish it from the slot name ‘levels’.</p>
</dd>
<dt><code>df</code></dt>
<dd>
<p>(numeric) overrides the default degrees of freedom with a
specified single value.</p>
</dd>
<dt><code>calc</code></dt>
<dd>
<p>(list) additional calculated columns. See <code>summary.emmGrid</code>.</p>
</dd>
<dt><code>null</code></dt>
<dd>
<p>(numeric) null hypothesis for <code>summary</code> or
<code>test</code> (taken to be zero if missing).</p>
</dd>
<dt><code>side</code></dt>
<dd>
<p>(numeric or character) <code>side</code> specification for for
<code>summary</code> or <code>test</code> (taken to be zero if missing).</p>
</dd>
<dt><code>sigma</code></dt>
<dd>
<p>(numeric) Error SD to use in predictions and for bias-adjusted
back-transformations</p>
</dd>
<dt><code>delta</code></dt>
<dd>
<p>(numeric) <code>delta</code> specification for <code>summary</code>
or <code>test</code> (taken to be zero if missing).</p>
</dd>
<dt>
<code>predict.type</code> or <code>type</code>
</dt>
<dd>
<p>(character) sets the default method
of displaying predictions in <code>summary.emmGrid</code>,
<code>predict.emmGrid</code>, and <code>emmip</code>. Valid values are
<code>"link"</code> (with synonyms <code>"lp"</code> and <code>"linear"</code>), or
<code>"response"</code>.</p>
</dd>
<dt>
<code>bias.adjust</code>, <code>frequentist</code>
</dt>
<dd>
<p>(logical) These
are used by <code>summary</code> if the value of these arguments are not specified.</p>
</dd>
<dt><code>estType</code></dt>
<dd>
<p>(<code>character</code>) is used internally to determine 
what <code>adjust</code> methods are appropriate. It should match one of 
‘<span class="samp">⁠c("prediction", "contrast", "pairs")⁠</span>’. As an example of why this is needed,
the Tukey adjustment should only be used for pairwise comparisons 
(<code>estType = "pairs"</code>); if <code>estType</code> is some other string, Tukey
adjustments are not allowed.</p>
</dd>
<dt><code>avgd.over</code></dt>
<dd>
<p>(<code>character)</code> vector) are the names of the 
variables whose levels are averaged over in obtaining marginal averages of 
predictions, i.e., estimated marginal means. Changing this might produce a 
misleading printout, but setting it to <code>character(0)</code> will suppress the 
“averaged over” message in the summary.</p>
</dd>
<dt><code>initMesg</code></dt>
<dd>
<p>(<code>character</code>) is a string that is added to the
beginning of any annotations that appear below the <code>summary.emmGrid</code>
display.</p>
</dd>
<dt><code>methDesc</code></dt>
<dd>
<p>(<code>character</code>) is a string that may be used for
creating names for a list of <code>emmGrid</code> objects. </p>
</dd>
<dt><code>nesting</code></dt>
<dd>
<p>(Character or named <code>list</code>) specifies the nesting
structure. See “Recovering or overriding model information” in the
documentation for <code>ref_grid</code>. The current nesting structure is
displayed by <code>str.emmGrid</code>.</p>
</dd>
<dt><code>levels</code></dt>
<dd>
<p>named <code>list</code> of new levels for the elements of the
current <code>emmGrid</code>. The list name(s) are used as new variable names, and
if needed, the list is expanded using <code>expand.grid</code>. These results replace
current variable names and levels. This specification changes the <code>levels</code>,
<code>grid</code>, <code>roles</code>, and <code>misc</code> slots in the updated <code>emmGrid</code>,
and resets <code>pri.vars</code>, <code>by.vars</code>, <code>adjust</code>, <code>famSize</code>,
and <code>avgd.over</code>. In addition, if there is nesting of factors, that may be 
altered; a warning is issued if it involves something other than mere name changes.
<em>Note:</em> All six letters of <code>levels</code> is needed in order to distinguish
it from <code>level</code>.</p>
</dd>
<dt><code>submodel</code></dt>
<dd>
<p><code>formula</code> or <code>character</code> value specifying a 
submodel (requires this feature being supported by underlying methods 
for the model class). When specified, the <code>linfct</code> slot is replaced by 
its aliases for the specified sub-model. Any factors in the sub-model that 
do not appear in the model matrix are ignored, as are any interactions that 
are not in the main model, and any factors associate with multivariate responses. 
The estimates displayed are then computed as if 
the sub-model had been fitted. (However, the standard errors will be based on the
error variance(s) of the full model.) 
<em>Note:</em> The formula should refer only to predictor names, <em>excluding</em> any
function calls (such as <code>factor</code> or <code>poly</code>) that appear in the 
original model formula. See the example.
</p>
<p>The character values allowed should partially 
match <code>"minimal"</code> or <code>"type2"</code>. With <code>"minimal"</code>, the sub-model
is taken to be the one only involving the surviving factors in <code>object</code>
(the ones averaged over being omitted). Specifying <code>"type2"</code> is the same as
<code>"minimal"</code> except only the highest-order term in the submodel is retained,
and all effects not containing it are orthogonalized-out. Thus, in a purely linear
situation such as an <code>lm</code> model, the joint test
of the modified object is in essence a type-2 test as in <code>car::Anova</code>.
</p>
<p>For some objects such as generalized linear models, specifying <code>submodel</code>
will typically not produce the same estimates or type-2 tests as would be
obtained by actually fitting a separate model with those specifications.
The reason is that those models are fitted by iterative-reweighting methods,
whereas the <code>submodel</code> calculations preserve the final weights used in
fitting the full model.</p>
</dd>
<dt>(any other slot name)</dt>
<dd>
<p>If the name matches an element of
<code>slotNames(object)</code> other than <code>levels</code>, that slot is replaced by 
the supplied value, if it is of the required class (otherwise an error occurs). 
</p>
<p>The user must be very careful in
replacing slots because they are interrelated; for example, the lengths
and dimensions of <code>grid</code>, <code>linfct</code>, <code>bhat</code>, and <code>V</code> must
conform.</p>
</dd>
</dl>
<h3>Replacing levels</h3>

<p>The <code>levels&lt;-</code> method uses <code>update.emmGrid</code> to replace the
levels of one or more factors. This method allows selectively replacing
the levels of just one factor (via subsetting operators), whereas 
<code>update(x, levels = list(...))</code> requires a list of <em>all</em> factors
and their levels. If any factors are to be renamed, we must replace all
levels and include the new names in the replacements. See the examples.
</p>


<h3>Method for <code>summary_emm</code> objects</h3>

<p>This method exists so that we can change the way a summary is displayed,
by changing the by variables or the annotations.
</p>


<h3>Note</h3>

<p>When it makes sense, an option set by <code>update</code> will persist into 
future results based on that object. But some options are disabled as well.
For example, a <code>calc</code> option will be nulled-out if <code>contrast</code>
is called, because it probably will not make sense to do the same 
calculations on the contrast results, and in fact the variable(s) needed
may not even still exist.
<code>factor(percent)</code>.
</p>


<h3>See Also</h3>

<p><code>emm_options</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Using an already-transformed response:
pigs.lm &lt;- lm(log(conc) ~ source * factor(percent), data = pigs)

# Reference grid that knows about the transformation
# and asks to include the sample size in any summaries:
pigs.rg &lt;- update(ref_grid(pigs.lm), tran = "log", 
                    predict.type = "response",
                    calc = c(n = ~.wgt.))
emmeans(pigs.rg, "source")

# Obtain estimates for the additive model
# [Note that the submodel refers to 'percent', not 'factor(percent)']
emmeans(pigs.rg, "source", submodel = ~ source + percent)

# Type II ANOVA
joint_tests(pigs.rg, submodel = "type2")

## Changing levels of one factor
newrg &lt;- pigs.rg
levels(newrg)$source &lt;- 1:3
newrg

## Unraveling a previously standardized covariate
zd = scale(fiber$diameter)
fibz.lm &lt;- lm(strength ~ machine * zd, data = fiber)
(fibz.rg &lt;- ref_grid(fibz.lm, at = list(zd = -2:2)))   ### 2*SD range
lev &lt;- levels(fibz.rg)
levels(fibz.rg) &lt;- list (
    machine = lev$machine,
    diameter = with(attributes(zd), 
                    `scaled:center` + `scaled:scale` * lev$zd) )
fibz.rg

### Compactify results with a by variable
update(joint_tests(pigs.rg, by = "source"), by = NULL)
</code></pre>


</div>