<div class="container">

<table style="width: 100%;"><tr>
<td>eff.ini.maxeig.general</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>General matrix maximal eigenpair</h2>

<h3>Description</h3>

<p>Calculate the maximal eigenpair for the general matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eff.ini.maxeig.general(A, v0_tilde = NULL, z0 = NULL, z0numeric, xi = 1,
  digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>The input general matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v0_tilde</code></td>
<td>
<p>The unnormalized initial vector <code class="reqn">\tilde{v0}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z0</code></td>
<td>
<p>The type of initial <code class="reqn">z_0</code> used to calculate the approximation of <code class="reqn">\rho(Q)</code>.
There are three types: 'fixed', 'Auto' and 'numeric' corresponding to three choices
of <code class="reqn">z_0</code> in paper.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z0numeric</code></td>
<td>
<p>The numerical value assigned to initial <code class="reqn">z_0</code> as an approximation of
<code class="reqn">\rho(Q)</code> when z_0='numeric'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xi</code></td>
<td>
<p>The coefficient used to form the convex combination of <code class="reqn">\delta_1^{-1}</code> and
<code class="reqn">(v_0,-Q*v_0)_\mu</code>, it should between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>The approximating eigenfunction of the corresponding eigenvector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>eff.ini.maxeig.tri</code> for the tridiagonal matrix maximal 
eigenpair by rayleigh quotient iteration algorithm.
<code>eff.ini.maxeig.shift.inv.tri</code> for the tridiagonal matrix 
maximal eigenpair by shifted inverse iteration algorithm.
</p>


<h3>Examples</h3>

<pre><code class="language-R">A = matrix(c(1, 1, 3, 2, 2, 2, 3, 1, 1), 3, 3)
eff.ini.maxeig.general(A, v0_tilde = rep(1, dim(A)[1]), z0 = 'fixed')

A = matrix(c(1, 1, 3, 2, 2, 2, 3, 1, 1), 3, 3)
eff.ini.maxeig.general(A, v0_tilde = rep(1, dim(A)[1]), z0 = 'Auto')

##Symmetrizing A converge to second largest eigenvalue
A = matrix(c(1, 3, 9, 5, 2, 14, 10, 6, 0, 11, 11, 7, 0, 0, 1, 8), 4, 4)
S = (t(A) + A)/2
N = dim(S)[1]
a = diag(S[-1, -N])
b = diag(S[-N, -1])
c = rep(NA, N)
c[1] = -diag(S)[1] - b[1]
c[2:(N - 1)] = -diag(S)[2:(N - 1)] - b[2:(N - 1)] - a[1:(N - 2)]
c[N] = -diag(S)[N] - a[N - 1]

z0ini = eff.ini.maxeig.tri(a, b, c, xi = 7/8)$z[1]
eff.ini.maxeig.general(A, v0_tilde = rep(1, dim(A)[1]), z0 = 'numeric',
z0numeric = 28 - z0ini)
</code></pre>


</div>