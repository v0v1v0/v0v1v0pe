<div class="container">

<table style="width: 100%;"><tr>
<td>braid_rows</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bind lists of list of multiple data frames by row</h2>

<h3>Description</h3>

<p>Row binds the matching innermost data frames in a list of lists. This is
essentially a list inversion <code>purrr::list_transpose()</code> with row-binding
<code>dplyr::bind_rows()</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">braid_rows(list)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>list</code></td>
<td>
<p>A list of lists of <code>data.frame</code>s where matching innermost
elements must be bound together row-wise.</p>
</td>
</tr></table>
<h3>Value</h3>

<p>A list of <code>data.frame</code>s with the combined information from the inputted list.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># A simple example
lst &lt;- lapply(1:5, function(x) {
  list(
    "A" = data.frame("first" = x, "second" = rnorm(x)),
    "B" = data.frame("info" = 1, "other" = 3)
  )
})
braid_rows(lst)

# An example with an additional layer and jagged innermost info
lapply(c(28, 186, 35), function(len) {
  lapply(c("a", "b"), function(x) {
    res &lt;- list(
      "descriptive" = data.frame(
         risk = len,
         event = x,
         var = 1,
         other = 2
       ),
      "results" = data.frame(
         risk = len,
         event = x,
         important = 4:7,
         new = 3:6
      )
    )
    if (len &lt; 30) {
      res &lt;- c(res, list("additional" = data.frame(helps = "extra data")))
    }
    return(res)
  }) |&gt; braid_rows()
}) |&gt; braid_rows()


</code></pre>


</div>