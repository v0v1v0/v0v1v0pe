<div class="container">

<table style="width: 100%;"><tr>
<td>ci.fevd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Confidence Intervals
</h2>

<h3>Description</h3>

<p>Confidence intervals for parameters and return levels using fevd objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'fevd'
ci(x, alpha = 0.05, type = c("return.level", "parameter"), 
    return.period = 100, which.par, R = 502, ...)

## S3 method for class 'fevd.bayesian'
ci(x, alpha = 0.05, type = c("return.level", "parameter"),
    return.period = 100, which.par = 1, FUN = "mean", burn.in = 499, tscale = FALSE,
    ...)

## S3 method for class 'fevd.lmoments'
ci(x, alpha = 0.05, type = c("return.level", "parameter"),
    return.period = 100, which.par, R = 502, tscale = FALSE,
    return.samples = FALSE, ...)

## S3 method for class 'fevd.mle'
ci(x, alpha = 0.05, type = c("return.level", "parameter"),
    return.period = 100, which.par, R = 502, method = c("normal",
        "boot", "proflik"), xrange = NULL, nint = 20, verbose = FALSE,
    tscale = FALSE, return.samples = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>list object returned by <code>fevd</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>numeric between 0 and 1 giving the desired significance level (i.e., the (1 - <code>alpha</code>) * 100 percent confidence level; so that the default <code>alpha</code> = 0.05 corresponds to a 95 percent confidence level).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character specifying if confidence intervals (CIs) are desired for return level(s) (default) or one or more parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.period</code></td>
<td>
<p>numeric vector giving the return period(s) for which it is desired to calculate the corresponding return levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> optional arguments to the <code>profliker</code> function.  For example, if it is desired to see the plot (recommended), use <code>verbose</code> = TRUE.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.par</code></td>
<td>
<p>numeric giving the index (indices) for which parameter(s) to calculate CIs.  Default is to do all of them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>character string naming a function to use to estimate the parameters from the MCMC sample.  The function is applied to each column of the <code>results</code> component of the returned <code>fevd</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn.in</code></td>
<td>
<p>The first <code>burn.in</code> values are thrown out before calculating anything from the MCMC sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>the number of bootstrap iterations to do.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> character naming which method for obtaining CIs should be used.  Default (“normal”) uses a normal approximation, and in the case of return levels (or transformed scale) applies the delta method using the parameter covariance matrix.  Option “boot” employs a parametric bootstrap that simulates data from the fitted model, and then fits the EVD to each simulated data set to obtain a sample of parameters or return levels.  Currently, only the percentile method of calculating the CIs from the sample is available.  Finally, “proflik” uses function <code>profliker</code> to calculate the profile-likelihood function for the parameter(s) of interest, and tries to find the upcross level between this function and the appropriate chi-square critical value (see details).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tscale</code></td>
<td>
<p>For the GP df, the scale parameter is a function of the shape parameter and the threshold.  When plotting the parameters, for example, against thresholds to find a good threshold for fitting the GP df, it is imperative to transform the scale parameter to one that is independent of the threshold.  In particular, <code>tscale</code> = scale - shape * threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xrange, nint</code></td>
<td>
<p>arguments to <code>profliker</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.samples</code></td>
<td>
<p>logical; should the bootstrap samples be returned?  If so, CIs will not be calculated and only the sample of parameters (return levels) are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>logical; should progress information be printed to the screen?  For profile likelihood method (<code>method</code> = “proflik”), if TRUE, the profile-likelihood will also be plotted along with a horizontal line through the chi-square critical value.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Confidence Intervals (<code>ci</code>):
</p>
<p><code>ci</code>: The <code>ci</code> method function will take output from <code>fevd</code> and calculate confidence intervals (or credible intervals in the case of Bayesian estimation) in an appropriate manner based on the estimation method.  There is no need for the user to call <code>ci.fevd</code>, <code>ci.fevd.lmoments</code>, <code>ci.fevd.bayesian</code> or <code>ci.fevd.mle</code>; simply use <code>ci</code> and it will access the correct functions.
</p>
<p>Currently, for L-moments, the only method available in this software is to apply a parameteric bootstrap, which is also available for the MLE/GMLE methods.  A parametric bootstrap is performed via the following steps.
</p>
<p>1. Simulate a sample of size n = lenght of the original data from the fitted model.
</p>
<p>2. Fit the EVD to the simulated sample and store the resulting parameter estimates (and perhaps any combination of them, such as return levels).
</p>
<p>3. Repeat steps 1 and 2 many times (to be precise, <code>R</code> times) to obtain a sample from the population df of the parameters (or combinations thereof).
</p>
<p>4. From the sample resulting form the above steps, calculate confidence intervals.  In the present code, the only option is to do this by taking the alpha/2 and 1 - alpha/2 quantiles of the sample (i.e., the percentile method).  However, if one uses <code>return.samples</code> = TRUE, then the sample is returned instead of confidence intervals allowing one to apply some other method if they so desire.
</p>
<p>As far as guidance on how large <code>R</code> should be, it is a trial and error decision.  Usually, one wants the smallest value (to make it as fast as possible) that still yields accurate results.  Generally, this means doing it once with a relatively low number (say <code>R</code> = 100), and then doing it again with a higher number, say <code>R</code> = 250.  If the results are very different, then do it again with an even higher number.  Keep doing this until the results do not change drastically.
</p>
<p>For MLE/GMLE, the normal approximation (perhaps using the delta method, e.g., for return levels) is used if <code>method</code> = “normal”.  If <code>method</code> = “boot”, then parametric bootstrap CIs are found.  Finally, if <code>method</code> = “profliker”, then bounds based on the profile likelihood method are found (see below for more details).
</p>
<p>For Bayesian estimation, the alpha/2 and 1 - alpha/2 percentiles of the resulting MCMC sample (after removing the first <code>burn.in</code> values) are used.  If return levels are desired, then they are first calculated for each MCMC iteration, and the same procedure is applied.  Note that the MCMC samples are availabel in the <code>fevd</code> output for this method, so any other procedure for finding CIs can be done by the savvy user.
</p>
<p>Finding CIs based on the profile-likelihood method:
</p>
<p>The profile likelihood method is often the best method for finding accurate CIs for the shape parameter and for return levels associated with long return periods (where their distribution functions are generally skewed so that, e.g., the normal approximation is not a good approximation).  The profile likelihood for a parameter is obtained by maximizing the likelihood over the other parameters of the model for each of a range (<code>xrange</code>) of values.  An approximation confidence region can be obtained using the deviance function D = 2 * (l(theta.hat) - l_p(theta)), where l(theta.hat) is the likelihood for the original model evaluated at their estimates and l_p(theta) is the likelihood of the parameter of interest (optimized over the remaining parameters), which approximately follows a chi-square df with degrees of freedom equal ot the number of parameters in the model less the one of interest.  The confidence region is then given by
</p>
<p>C_alpha = the set of theta_1 s.t. D &lt;= q,
</p>
<p>where q is the 1 - alpha quantile of the chi-square df with degrees of freedom equal to 1 and theta_1 is the parameter of interest.  If we let m represent the maximum value of the profile likelihood (i.e., m = max(l_p(theta))), then consider a horizontal line through m - q.  All values of theta_1 that yield a profile likelihood value above this horizontal line are within the confidence region, C_alpha (i.e., the range of these values represents the (1 - alpha) * 100 percent CI for the parameter of interest).  For combinations of parameters, such as return levels, the same technique is applied by transforming the parameters in the likelihood to reflect the desired combination.
</p>
<p>To use the profile-likelihood approach, it is necessary to choose an <code>xrange</code> argument that covers the entire confidence interval and beyond (at least a little), and the <code>nint</code> argument may be important here too (this argument gives the number of points to try in fitting a spline function to the profile likelihood, and smaller values curiously tend to be better, but not too small!  Smaller values are also more efficient).  Further, one should really look at the plot of the profile-likelihood to make sure that this is the case, and that resulting CIs are accurately estimated (perhaps using the <code>locator</code> function to be sure).  Nevertheless, an attempt is made to find the limits automatically.  To look at the plot along with the horizontal line, m - q, and vertical lines through the MLE (thin black dashed) and the CIs (thick dashed blue), use the <code>verbose</code> = TRUE argument in the call to <code>ci</code>.  This is not an explicit argument, but available nonetheless (see examples below).
</p>
<p>See any text on EVA/EVT for more details (e.g., Coles 2001; Beirlant et al 2004; de Haan and Ferreira 2006).
</p>


<h3>Value</h3>

<p>Either a numeric vector of length 3 (if only one parameter/return level is used) or a matrix.  In either case, they will have class “ci”.
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>References</h3>

<p>Beirlant, J., Goegebeur, Y., Teugels, J. and Segers, J. (2004). <em>Statistics of Extremes: Theory and Applications</em>.  Chichester, West Sussex, England, UK: Wiley, ISBN 9780471976479, 522pp.
</p>
<p>Coles, S.  (2001). <em>An introduction to statistical modeling of extreme values</em>, London: Springer-Verlag.
</p>
<p>de Haan, L. and Ferreira, A. (2006). <em>Extreme Value Theory: An Introduction</em>.  New York, NY, USA: Springer, 288pp.
</p>


<h3>See Also</h3>

<p><code>fevd</code>, <code>ci.rl.ns.fevd.bayesian</code>, <code>ci</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(Fort)

fit &lt;- fevd(Prec, Fort, threshold = 2, type = "GP",
    units = "inches", verbose = TRUE)

ci(fit, type = "parameter")

## Not run: 
ci(fit, type = "return.level", method = "proflik",
    xrange = c(3.5,7.75), verbose = TRUE)
# Can check using locator(2).

ci(fit, method = "boot")


## End(Not run)

</code></pre>


</div>