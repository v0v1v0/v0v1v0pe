<div class="container">

<table style="width: 100%;"><tr>
<td>emulator-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Bayesian Emulation of Computer Programs
</h2>

<h3>Description</h3>


<p> Allows one to estimate the output of a computer program,
 as a function of the input parameters, without actually running it.
 The computer program is assumed to be a Gaussian process, whose
 parameters are estimated using Bayesian techniques that give a PDF of
 expected program output.  This PDF is conditional on a training set
 of runs, each consisting of a point in parameter space and the model
 output at that point.  The emphasis is on complex codes that take
 weeks or months to run, and that have a large number of undetermined
 input parameters; many climate prediction models fall into this
 class.  The emulator essentially determines Bayesian posterior
 estimates of the PDF of the output of a model, conditioned on results
 from previous runs and a user-specified prior linear model.  The
 package includes functionality to evaluate quadratic forms 
 efficiently. 
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
<td style="text-align: left;">
Package: </td>
<td style="text-align: left;"> emulator</td>
</tr>
<tr>
<td style="text-align: left;">
Type: </td>
<td style="text-align: left;"> Package</td>
</tr>
<tr>
<td style="text-align: left;">
Title: </td>
<td style="text-align: left;"> Bayesian Emulation of Computer Programs</td>
</tr>
<tr>
<td style="text-align: left;">
Version: </td>
<td style="text-align: left;"> 1.2-24</td>
</tr>
<tr>
<td style="text-align: left;">
Authors@R: </td>
<td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
<td style="text-align: left;">
VignetteBuilder: </td>
<td style="text-align: left;"> knitr</td>
</tr>
<tr>
<td style="text-align: left;">
Depends: </td>
<td style="text-align: left;"> R (&gt;= 3.0.1), mvtnorm</td>
</tr>
<tr>
<td style="text-align: left;">
Suggests: </td>
<td style="text-align: left;"> knitr,rmarkdown</td>
</tr>
<tr>
<td style="text-align: left;">
Maintainer: </td>
<td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td style="text-align: left;">
Description: </td>
<td style="text-align: left;"> 
 Allows one to estimate the output of a computer program,
 as a function of the input parameters, without actually running it.
 The computer program is assumed to be a Gaussian process, whose
 parameters are estimated using Bayesian techniques that give a PDF of
 expected program output.  This PDF is conditional on a training set
 of runs, each consisting of a point in parameter space and the model
 output at that point.  The emphasis is on complex codes that take
 weeks or months to run, and that have a large number of undetermined
 input parameters; many climate prediction models fall into this
 class.  The emulator essentially determines Bayesian posterior
 estimates of the PDF of the output of a model, conditioned on results
 from previous runs and a user-specified prior linear model.  The
 package includes functionality to evaluate quadratic forms 
 efficiently. </td>
</tr>
<tr>
<td style="text-align: left;">
License: </td>
<td style="text-align: left;"> GPL</td>
</tr>
<tr>
<td style="text-align: left;">
URL: </td>
<td style="text-align: left;"> https://github.com/RobinHankin/emulator</td>
</tr>
<tr>
<td style="text-align: left;">
BugReports: </td>
<td style="text-align: left;"> https://github.com/RobinHankin/emulator/issues</td>
</tr>
<tr>
<td style="text-align: left;">
Author: </td>
<td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Index of help topics:
</p>
<pre>
OO2002                  Implementation of the ideas of Oakley and
                        O'Hagan 2002
betahat.fun             Calculates MLE coefficients of linear fit
corr                    correlation function for calculating A
emulator-package        Bayesian Emulation of Computer Programs
estimator               Estimates each known datapoint using the others
                        as datapoints
expert.estimates        Expert estimates for Goldstein input parameters
interpolant             Interpolates between known points using
                        Bayesian estimation
latin.hypercube         Latin hypercube design matrix
makeinputfiles          Makes input files for condor runs of goldstein
model                   Simple model for concept checking
optimal.scales          Use optimization techniques to find the optimal
                        scales
pad                     Simple pad function
prior.b                 Prior linear fits
quad.form               Evaluate a quadratic form efficiently
regressor.basis         Regressor basis function
results.table           Results from 100 Goldstein runs
s.chi                   Variance estimator
sample.n.fit            Sample from a Gaussian process and fit an
                        emulator to the points
scales.likelihood       Likelihood of roughness parameters
sigmahatsquared         Estimator for sigma squared
toy                     A toy dataset
tr                      Trace of a matrix
</pre>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li>
<p>J. Oakley 1999. “Bayesian uncertainty analysis for complex
computer codes”, PhD thesis, University of Sheffield.
</p>
</li>
<li>
<p>R. K. S. Hankin 2005. “Introducing BACCO, an R bundle for
Bayesian analysis of computer code output”, Journal of Statistical
Software, 14(16)
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## More detail given in optimal.scales.Rd
scales_true  &lt;- c(1,1,1,1,1,4)

## and a real (linear) relation:
real.relation &lt;- function(x){sum( (1:6)*x )}

## Now a design matrix:
val  &lt;- latin.hypercube(100,6)

## apply the real relation:
d &lt;- apply(val,1,real.relation)

## and add some suitably correlated Gaussian noise:
A &lt;- corr.matrix(val,scales=scales_true)
d.noisy &lt;-  as.vector(rmvnorm(n=1,mean=apply(val,1,real.relation), 0.3*A))

## Now try to predict the values at points x:

x &lt;- latin.hypercube(20,6)
predicted &lt;- int.qq(x,d.noisy,xold=val, Ainv=solve(A),pos.def.matrix=diag(scales_true))
observed &lt;- apply(x,1,real.relation)

par(pty='s')
plot(predicted,observed,xlim=c(4,18),ylim=c(4,18))
abline(0,1)

</code></pre>


</div>