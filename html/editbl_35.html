<div class="container">

<table style="width: 100%;"><tr>
<td>e_rows_insert.tbl_dbi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>rows_insert implementation for DBI backends.</h2>

<h3>Description</h3>

<p>rows_insert implementation for DBI backends.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'tbl_dbi'
e_rows_insert(x, y, by = NULL, ..., copy = FALSE, in_place = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>A pair of data frames or data frame extensions (e.g. a tibble).
<code>y</code> must have the same columns of <code>x</code> or a subset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>An unnamed character vector giving the key columns. The key columns
must exist in both <code>x</code> and <code>y</code>. Keys typically uniquely identify each row,
but this is only enforced for the key values of <code>y</code> when <code>rows_update()</code>,
<code>rows_patch()</code>, or <code>rows_upsert()</code> are used.
</p>
<p>By default, we use the first column in <code>y</code>, since the first column is
a reasonable place to put an identifier variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in_place</code></td>
<td>
<p>Should <code>x</code> be modified in place? This argument is only
relevant for mutable backends (e.g. databases, data.tables).
</p>
<p>When <code>TRUE</code>, a modified version of <code>x</code> is returned invisibly;
when <code>FALSE</code>, a new object representing the resulting changes is returned.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Mainly a wrapper around <code>rows_insert</code>.
Allows for specific implementations should the behavior differ from what's needed by <code>editbl</code>.
Reason for separate method is to avoid conflicts on package loading.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>x</code>. The order of the rows and columns of <code>x</code>
is preserved as much as possible. The output has the following properties:
</p>

<ul>
<li> <p><code>rows_update()</code> and <code>rows_patch()</code> preserve the number of rows;
<code>rows_insert()</code>, <code>rows_append()</code>, and <code>rows_upsert()</code> return all existing
rows and potentially new rows; <code>rows_delete()</code> returns a subset of the
rows.
</p>
</li>
<li>
<p> Columns are not added, removed, or relocated, though the data may be
updated.
</p>
</li>
<li>
<p> Groups are taken from <code>x</code>.
</p>
</li>
<li>
<p> Data frame attributes are taken from <code>x</code>.
</p>
</li>
</ul>
<p>If <code>in_place = TRUE</code>, the result will be returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Jasper Schelfhout
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(dplyr)

# Set up a test table
conn &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
artists_df &lt;- data.frame(
         ArtistId = c(1,2),
         Name = c("AC/DC", "The Offspring")
)
DBI::dbWriteTable(conn, "Artist", artists_df)     
 
# Insert new row
artists &lt;- tbl(conn, "Artist")
DBI::dbBegin(conn)
e_rows_insert(artists,
 data.frame(ArtistId = 999, Name = "testArtist"),
 in_place = TRUE)

DBI::dbRollback(conn)
DBI::dbDisconnect(conn)

</code></pre>


</div>