<div class="container">

<table style="width: 100%;"><tr>
<td>Kmm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Mark-weighted K-function </h2>

<h3>Description</h3>

<p>This is a functional data summary for marked point patterns that measures the joint pattern of points and marks at different scales determined by <code class="reqn">r</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Kmm(mippp, r = 1:10, nsim=NULL)

## S3 method for ploting objects of class 'ecespa.kmm':
## S3 method for class 'ecespa.kmm'
plot(x, type="Kmm.n", q=0.025, 
            xlime=NULL, ylime=NULL,  maine=NULL, add=FALSE, kmean=TRUE,
            ylabe=NULL, xlabe=NULL, lty=c(1,2,3), col=c(1,2,3), lwd=c(1,1,1),
             ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mippp</code></td>
<td>
<p> A marked point pattern. An object with the <code>ppp</code> format of <span class="pkg">spatstat</span>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p> Sequence of distances at which <code>Kmm</code> is estimated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p> Number of simulated point patterns to be generated when computing the envelopes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> An object of class 'ecespa.kmm'. The result of applying <code>Kmm</code> to a marked point pattern.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of mark-weighted K-function to plot. One of <code>"Kmm"</code> ("plain" mark-weighted K-function) or 
<code>"Kmm.n"</code> (normalized mark-weighted K-function). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Quantile for selecting the simulation envelopes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlime</code></td>
<td>
<p>Max and min coordinates for the x-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylime</code></td>
<td>
<p>Max and min coordinates for the y-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maine</code></td>
<td>
<p>Title to add to the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>Logical. Should the kmm.object be added to a previous plot? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmean</code></td>
<td>
<p>Logical. Should the mean of the simulated Kmm envelopes be ploted?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylabe</code></td>
<td>
<p>Text  or expression to label the y-axis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlabe</code></td>
<td>
<p>Text  or expression to label the x-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p>Vector with the line type for the estimated Kmm function, the simulated envelopes and the mean of the simulated envelopes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>Vector with the color for the estimated Kmm function, the simulated envelopes and the mean of the simulated envelopes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>Vector with the line width for the estimated Kmm function, the simulated envelopes and the mean of the simulated envelopes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional graphical parameters passed to plot.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Penttinnen (2006) defines <code class="reqn">Kmm(r)</code>, the mark-weighted <code class="reqn">K</code>-function  of a stationary marked point process <code class="reqn">X</code>, 
so that </p>
<p style="text-align: center;"><code class="reqn">lambda*Kmm(r) = Eo[sum(mo*mn)]/mu^2</code>
</p>
<p> where <code class="reqn">lambda</code> is the intensity of the process, 
i.e. the expected number of points of <code class="reqn">X</code> per unit area, <code class="reqn">Eo[ ] </code> denotes expectation (given that there is a point at the origin); 
<code class="reqn">m0</code> and <code class="reqn">mn</code> are the marks attached to every two points of the process separated by a distance <code class="reqn">&lt;= r</code>  and <code class="reqn">mu</code>
is the mean mark. It measures the joint pattern of marks and points at the scales determmined by <code class="reqn">r</code>. If all the marks are set to 1,
then <code class="reqn">lambda*Kmm(r)</code> equals the expected number of additional random points within 
a distance <code class="reqn">r</code> of a typical random point of <code class="reqn">X</code>, i.e. <code class="reqn">Kmm</code> becomes the conventional Ripley's <code class="reqn">K</code>-function for unmarked point processes.
As the <code class="reqn">K</code>-function measures clustering or regularity among the points regardless of the marks, one can separate clustering of marks with the
<em>normalized weighted K-function</em> </p>
<p style="text-align: center;"><code class="reqn">Kmm.normalized(r) = Kmm(r)/K(r)</code>
</p>
<p> If the process is independently marked, <code class="reqn">Kmm(r)</code> equals <code class="reqn">K(r)</code> so the 
normalized mark-weighted <code class="reqn">K</code>-function will equal 1 for all distances <code class="reqn">r</code>.
</p>
<p>If <code>nsim != NULL</code>, <code>Kmm</code>  computes  <em>'simulation envelopes'</em> from the simulated point patterns. These are simulated from <code>nsim</code> random permutations
of the marks over the points coordinates. This is a kind of pointwise test of <code class="reqn">Kmm(r) == 1 </code> or <code class="reqn">normalized Kmm(r) == 1</code> for a given <code class="reqn">r</code>.  
</p>


<h3>Value</h3>

<p><code>Kmm</code> returns an object of class <code>'ecespa.kmm'</code>, basically a list with the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>dataname </code></td>
<td>
<p>Name of the analyzed point pattern.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r </code></td>
<td>
<p>Sequence of distances at which <code>Kmm</code> is estimated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>Number of simulations for computing the envelopes, or <code>NULL</code> if none.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmm </code></td>
<td>
<p>Mark-weighted <code class="reqn">K</code>-function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmm.n </code></td>
<td>
<p>Normalized mark-weighted <code class="reqn">K</code>-function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmmsim </code></td>
<td>
<p>Matrix of simulated  mark-weighted <code class="reqn">K</code>-functions, or or <code>NULL</code> if none.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmmsim.n </code></td>
<td>
<p>Matrix of simulated  normalized mark-weighted <code class="reqn">K</code>-functions, or or <code>NULL</code> if none.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This implementation estimates <code class="reqn">Kmm(r)</code> without any correction of border effects, so it must be used with caution. However, as <code class="reqn">K(r)</code> is 
also estimed without correction it migth compensate the border effects on the normalized <code class="reqn">Kmm</code>-function.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot </p>


<h3>References</h3>

<p>De la Cruz, M. 2008. Métodos para analizar datos puntuales. 
En: <em>Introducción al Análisis Espacial de Datos en Ecología y Ciencias Ambientales: Métodos y Aplicaciones </em> 
(eds. Maestre, F. T., Escudero, A. y Bonet, A.), pp 76-127. Asociación Española de Ecología Terrestre, Universidad Rey Juan Carlos
y Caja de Ahorros del Mediterráneo, Madrid.
</p>
<p>Penttinen, A. 2006. Statistics for Marked Point Patterns. In <em>The Yearbook of the Finnish Statistical Society</em>, pp. 70-91. 
</p>


<h3>See Also</h3>

<p><code>markcorr</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">
  ## Figure 3.10 of De la Cruz (2008):
  # change r to r=1:100
  
   r = seq(1,100, by=5)
  
  data(seedlings1)
  
  data(seedlings2)
  
  s1km &lt;- Kmm(seedlings1, r=r)
  
  s2km &lt;- Kmm(seedlings2, r=r)
  
  plot(s1km, ylime=c(0.6,1.2), lwd=2, maine="", xlabe="r(cm)")

  plot(s2km,  lwd=2, lty=2, add=TRUE )

  abline(h=1, lwd=2, lty=3)
  
  legend(x=60, y=1.2, legend=c("Hs_C1", "Hs_C2", "H0"),
	 lty=c(1, 2, 3), lwd=c(3, 2, 2), bty="n")
## Not run: 
## A pointwise test of normalized Kmm == 1 for seedlings1:

   s1km.test &lt;- Kmm(seedlings1, r=1:100, nsim=99)

   plot(s1km.test,  xlabe="r(cm)")

  
## End(Not run)
</code></pre>


</div>