<div class="container">

<table style="width: 100%;"><tr>
<td>horvitz_thompson</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Horvitz-Thompson estimator for two-armed trials</h2>

<h3>Description</h3>

<p>Horvitz-Thompson estimators that are unbiased for designs in
which the randomization scheme is known
</p>


<h3>Usage</h3>

<pre><code class="language-R">horvitz_thompson(
  formula,
  data,
  blocks,
  clusters,
  simple = NULL,
  condition_prs,
  condition_pr_mat = NULL,
  ra_declaration = NULL,
  subset,
  condition1 = NULL,
  condition2 = NULL,
  se_type = c("youngs", "constant", "none"),
  ci = TRUE,
  alpha = 0.05,
  return_condition_pr_mat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class formula, as in <code>lm</code>, such as
<code>Y ~ Z</code> with only one variable on the right-hand side, the treatment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blocks</code></td>
<td>
<p>An optional bare (unquoted) name of the block variable. Use
for blocked designs only. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusters</code></td>
<td>
<p>An optional bare (unquoted) name of the variable that
corresponds to the clusters in the data; used for cluster randomized
designs. For blocked designs, clusters must be within blocks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simple</code></td>
<td>
<p>logical, optional. Whether the randomization is simple
(TRUE) or complete (FALSE). This is ignored if <code>blocks</code> are specified,
as all blocked designs use complete randomization, or either
<code>ra_declaration</code> or <code>condition_pr_mat</code> are passed. Otherwise, it
defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition_prs</code></td>
<td>
<p>An optional bare (unquoted) name of the variable with
the condition 2 (treatment) probabilities. See details. May also use a single
number for the condition 2 probability if it is constant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition_pr_mat</code></td>
<td>
<p>An optional 2n * 2n matrix of marginal and joint
probabilities of all units in condition1 and condition2. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ra_declaration</code></td>
<td>
<p>An object of class <code>"ra_declaration"</code>, from
the <code>declare_ra</code> function in the <span class="pkg">randomizr</span>
package. This is the third way that one can specify a design for this
estimator. Cannot be used along with any of <code>condition_prs</code>,
<code>blocks</code>, <code>clusters</code>, or <code>condition_pr_mat</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An optional bare (unquoted) expression specifying a subset of
observations to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition1</code></td>
<td>
<p>value in the treatment vector of the condition
to be the control. Effects are
estimated with <code>condition1</code> as the control and <code>condition2</code> as the
treatment. If unspecified, <code>condition1</code> is the "first" condition and
<code>condition2</code> is the "second" according to levels if the treatment is a
factor or according to a sortif it is a numeric or character variable (i.e
if unspecified and the treatment is 0s and 1s, <code>condition1</code> will by
default be 0 and <code>condition2</code> will be 1). See the examples for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition2</code></td>
<td>
<p>value in the treatment vector of the condition to be the
treatment. See <code>condition1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se_type</code></td>
<td>
<p>can be one of <code>c("youngs", "constant", "none")</code> and corresponds
the estimator of the standard errors. Default estimator uses Young's
inequality (and is conservative) while the other uses a constant treatment
effects assumption and only works for simple randomized designs at the
moment. If "none" then standard errors will not be computed which may speed up run time if only the point estimate is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>logical. Whether to compute and return p-values and
confidence intervals, TRUE by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The significance level, 0.05 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_condition_pr_mat</code></td>
<td>
<p>logical. Whether to return the condition
probability matrix. Returns NULL if the design is simple randomization,
FALSE by default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function implements the Horvitz-Thompson estimator for
treatment effects for two-armed trials. This estimator is useful for estimating unbiased
treatment effects given any randomization scheme as long as the
randomization scheme is known.
</p>
<p>In short, the Horvitz-Thompson estimator essentially reweights each unit
by the probability of it being in its observed condition. Pivotal to the
estimation of treatment effects using this estimator are the marginal
condition probabilities (i.e., the probability that any one unit is in
a particular treatment condition). Pivotal to estimating the variance
whenever the design is more complicated than simple randomization are the
joint condition probabilities (i.e., the probabilities that any two units
have a particular set of treatment conditions, either the same or
different). The estimator we provide here considers the case with two
treatment conditions.
</p>
<p>Users interested in more details can see the
<a href="https://declaredesign.org/r/estimatr/articles/mathematical-notes.html">mathematical notes</a>
for more information and references, or see the references below.
</p>
<p>There are three distinct ways that users can specify the design to the
function. The preferred way is to use
the <code>declare_ra</code> function in the <span class="pkg">randomizr</span>
package. This function takes several arguments, including blocks, clusters,
treatment probabilities, whether randomization is simple or not, and more.
Passing the outcome of that function, an object of class
<code>"ra_declaration"</code> to the <code>ra_declaration</code> argument in this function,
will lead to a call of the <code>declaration_to_condition_pr_mat</code>
function which generates the condition probability matrix needed to
estimate treatment effects and standard errors. We provide many examples
below of how this could be done.
</p>
<p>The second way is to pass the names of vectors in your <code>data</code> to
<code>condition_prs</code>, <code>blocks</code>, and <code>clusters</code>. You can further
specify whether the randomization was simple or complete using the <code>simple</code>
argument. Note that if <code>blocks</code> are specified the randomization is
always treated as complete. From these vectors, the function learns how to
build the condition probability matrix that is used in estimation.
</p>
<p>In the case
where <code>condition_prs</code> is specified, this function assumes those
probabilities are the marginal probability that each unit is in condition2
and then uses the other arguments (<code>blocks</code>, <code>clusters</code>,
<code>simple</code>) to learn the rest of the design. If users do not pass
<code>condition_prs</code>, this function learns the probability of being in
condition2 from the data. That is, none of these arguments are specified,
we assume that there was a simple randomization where the probability
of each unit being in condition2 was the average of all units in condition2.
Similarly, we learn the block-level probability of treatment within
<code>blocks</code> by looking at the mean number of units in condition2 if
<code>condition_prs</code> is not specified.
</p>
<p>The third way is to pass a <code>condition_pr_mat</code> directly. One can
see more about this object in the documentation for
<code>declaration_to_condition_pr_mat</code> and
<code>permutations_to_condition_pr_mat</code>. Essentially, this 2n * 2n
matrix allows users to specify marginal and joint marginal probabilities
of units being in conditions 1 and 2 of arbitrary complexity. Users should
only use this option if they are certain they know what they are doing.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"horvitz_thompson"</code>.
</p>
<p>The post-estimation commands functions <code>summary</code> and <code>tidy</code>
return results in a <code>data.frame</code>. To get useful data out of the return,
you can use these data frames, you can use the resulting list directly, or
you can use the generic accessor functions <code>coef</code> and
<code>confint</code>.
</p>
<p>An object of class <code>"horvitz_thompson"</code> is a list containing at
least the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>the estimated difference in totals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.error</code></td>
<td>
<p>the estimated standard error</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>the z-statistic</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>the estimated degrees of freedom</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>the p-value from a two-sided z-test using <code>coefficients</code> and <code>std.error</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.low</code></td>
<td>
<p>the lower bound of the <code>1 - alpha</code> percent confidence interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.high</code></td>
<td>
<p>the upper bound of the <code>1 - alpha</code> percent confidence interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term</code></td>
<td>
<p>a character vector of coefficient names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>the significance level specified by the user</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>the number of observations used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome</code></td>
<td>
<p>the name of the outcome variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition_pr_mat</code></td>
<td>
<p>the condition probability matrix if <code>return_condition_pr_mat</code> is TRUE</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Aronow, Peter M, and Joel A Middleton. 2013. "A Class of Unbiased Estimators of the Average Treatment Effect in Randomized Experiments." Journal of Causal Inference 1 (1): 135-54. <a href="https://doi.org/10.1515/jci-2012-0009">doi:10.1515/jci-2012-0009</a>.
</p>
<p>Aronow, Peter M, and Cyrus Samii. 2017. "Estimating Average Causal Effects Under Interference Between Units." Annals of Applied Statistics, forthcoming. <a href="https://arxiv.org/abs/1305.6156v3">https://arxiv.org/abs/1305.6156v3</a>.
</p>
<p>Middleton, Joel A, and Peter M Aronow. 2015. "Unbiased Estimation of the Average Treatment Effect in Cluster-Randomized Experiments." Statistics, Politics and Policy 6 (1-2): 39-75. <a href="https://doi.org/10.1515/spp-2013-0002">doi:10.1515/spp-2013-0002</a>.
</p>


<h3>See Also</h3>

<p><code>declare_ra</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Set seed
set.seed(42)

# Simulate data
n &lt;- 10
dat &lt;- data.frame(y = rnorm(n))

library(randomizr)

#----------
# 1. Simple random assignment
#----------
dat$p &lt;- 0.5
dat$z &lt;- rbinom(n, size = 1, prob = dat$p)

# If you only pass condition_prs, we assume simple random sampling
horvitz_thompson(y ~ z, data = dat, condition_prs = p)
# Assume constant effects instead
horvitz_thompson(y ~ z, data = dat, condition_prs = p, se_type = "constant")

# Also can use randomizr to pass a declaration
srs_declaration &lt;- declare_ra(N = nrow(dat), prob = 0.5, simple = TRUE)
horvitz_thompson(y ~ z, data = dat, ra_declaration = srs_declaration)

#----------
# 2. Complete random assignment
#----------

dat$z &lt;- sample(rep(0:1, each = n/2))
# Can use a declaration
crs_declaration &lt;- declare_ra(N = nrow(dat), prob = 0.5, simple = FALSE)
horvitz_thompson(y ~ z, data = dat, ra_declaration = crs_declaration)
# Can precompute condition_pr_mat and pass it
# (faster for multiple runs with same condition probability matrix)
crs_pr_mat &lt;- declaration_to_condition_pr_mat(crs_declaration)
horvitz_thompson(y ~ z, data = dat, condition_pr_mat = crs_pr_mat)

#----------
# 3. Clustered treatment, complete random assigment
#-----------
# Simulating data
dat$cl &lt;- rep(1:4, times = c(2, 2, 3, 3))
dat$prob &lt;- 0.5
clust_crs_decl &lt;- declare_ra(N = nrow(dat), clusters = dat$cl, prob = 0.5)
dat$z &lt;- conduct_ra(clust_crs_decl)
# Easiest to specify using declaration
ht_cl &lt;- horvitz_thompson(y ~ z, data = dat, ra_declaration = clust_crs_decl)
# Also can pass the condition probability and the clusters
ht_cl_manual &lt;- horvitz_thompson(
  y ~ z,
  data = dat,
  clusters = cl,
  condition_prs = prob,
  simple = FALSE
)
ht_cl
ht_cl_manual

# Blocked estimators specified similarly

#----------
# More complicated assignment
#----------

# arbitrary permutation matrix
possible_treats &lt;- cbind(
  c(1, 1, 0, 1, 0, 0, 0, 1, 1, 0),
  c(0, 1, 1, 0, 1, 1, 0, 1, 0, 1),
  c(1, 0, 1, 1, 1, 1, 1, 0, 0, 0)
)
arb_pr_mat &lt;- permutations_to_condition_pr_mat(possible_treats)
# Simulating a column to be realized treatment
dat$z &lt;- possible_treats[, sample(ncol(possible_treats), size = 1)]
horvitz_thompson(y ~ z, data = dat, condition_pr_mat = arb_pr_mat)

</code></pre>


</div>