<div class="container">

<table style="width: 100%;"><tr>
<td>requery_hier</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Requery hierarchical context of a segment list in an emuDB</h2>

<h3>Description</h3>

<p>Function to requery the hierarchical context of a segment list queried from an emuDB
</p>


<h3>Usage</h3>

<pre><code class="language-R">requery_hier(
  emuDBhandle,
  seglist,
  level,
  collapse = TRUE,
  resultType = "tibble",
  calcTimes = TRUE,
  timeRefSegmentLevel = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code>load_emuDB</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seglist</code></td>
<td>
<p>segment list to requery on (type: emuRsegs)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>character string: name of target level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>
<p>collapse the found items in the requested level to a sequence (concatenated with -&gt;). 
If set to <code>FALSE</code> separate items as new entries in the emuRsegs object are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resultType</code></td>
<td>
<p>type of result (either 'tibble' == default or 'emuRsegs')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calcTimes</code></td>
<td>
<p>calculate times for resulting segments (results in <code>NA</code> values for start and end 
times in emuseg/emuRsegs). As it can be very computationally expensive to 
calculate the times for large nested hierarchies, it can be turned off via this boolean parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeRefSegmentLevel</code></td>
<td>
<p>set time segment level from which to derive time information. It is only 
necessary to set this parameter if more than one child level contains time information and the queried 
parent level is of type ITEM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>be verbose. Set this to <code>TRUE</code> if you wish to choose which path to traverse on intersecting 
hierarchies. If set to <code>FALSE</code> (the default) all paths will be traversed (= legacy EMU behaviour).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A segment is defined as a single item or a chain of items from the respective level, e.g. 
if a level in a bundle instance has labels 'a', 'b' and 'c' in that order, 'a' or 'a-&gt;b' or 'a-&gt;b-&gt;c' 
are all valid segments, 'a-&gt;c' is not. For each segment of the input segment list <code>seglist</code> 
the function checks the start and end item for hierarchically linked items in the given target 
level, and based on them constructs segments in the target level. As the start item in the resulting 
segment the item with the lowest sequence index is chosen; for the end item that with the highest 
sequence index. If the parameter <code>collapse</code> is set to <code>TRUE</code> (the default), it is guaranteed 
that result and input segment list have the same length (for each input 
segment one or multiple segments on the target level was found). If multiple linked segments where found
they are collapsed into a sequence of segments ('a-&gt;b-&gt;c') and if no linked items where found an NA row 
is inserted.
</p>


<h3>Value</h3>

<p>result set object of class emuRsegs or tibble
</p>


<h3>See Also</h3>

<p><code>query</code> <code>requery_seq</code> <code>emuRsegs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

## Downward requery: find 'Phoneme' sequences of all words 'beautiful' (of level 'Text')
## Note that the resulting segments consists of phoneme sequences and have therefore 
## the same length as the word segments.

sl1 = query(ae, "Text == beautiful")
requery_hier(ae, sl1, level = "Phoneme")

## Upward requery: find all word segments that dominate a 'p' on level 'Phoneme'
## Note that the resulting segments are larger than the input segments,
## because they contain the complete words.

sl1 = query(ae, "Phonetic == p")
requery_hier(ae, sl1, level = 'Text')

## Why is there a 'p' the word 'emphazised'? Requery the whole words back down to 'Phoneme' level:

requery_hier(ae, sl1, level = 'Phoneme')

## ... because of 'stop epenthesis' a 'p' is inserted between 'm' and 'f'

## Combined requery: last phonemes of all words beginning with 'an'.
## Note that we use a regular expression 'an.*' (EQL operator '=~') in the query.

sl1=query(ae, "Text =~ an.*")
requery_seq(ae, requery_hier(ae, sl1, level = 'Phoneme'), offsetRef = 'END')


## End(Not run)
</code></pre>


</div>