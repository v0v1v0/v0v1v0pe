<div class="container">

<table style="width: 100%;"><tr>
<td>getis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Neighbourhood density function </h2>

<h3>Description</h3>

<p>Computes and plots the neighbourhood density function, a local version of the <code class="reqn">K</code>-function defined by Getis and Franklin (1987). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">getis(mippp, nx = 30, ny = 30, R = 10)

## S3 method for class 'ecespa.getis'
plot(x, type="k", dimyx=NULL, xy=NULL, eps=NULL,  color=NULL,
         contour=TRUE, points=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mippp</code></td>
<td>
<p>A point pattern. An object with the <code>ppp</code> format of <code>spatstat</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nx</code></td>
<td>
<p>Grid dimensions (for estimation) in the x-side. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ny</code></td>
<td>
<p>Grid dimensions (for estimation) in the y-side. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Radius. The distance argument <em> r</em> at which the function <code class="reqn">K</code> should be computed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Result of applying <code>getis</code> to a point pattern. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of local statistics to be ploted. One of <code>k</code> (local-<code class="reqn">K</code>), <code>l</code> (local-<code class="reqn">L</code>), <code>n</code> (local-<code class="reqn">n</code>) or <code>d</code> (deviations from CSR).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>color</code></td>
<td>
<p>A list of colors such as that generated by <code>rainbow</code>, <code>heat.colors</code>, <code>topo.colors</code>, <code>terrain.colors</code> or similar functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimyx</code></td>
<td>
<p>pixel array dimensions, will be passed to (i.e. see details in) <code>as.mask</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xy</code></td>
<td>
<p>pixel coordinates, will be passed to (i.e. see details in) <code>as.mask</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>width and height of pixels, will be passed to (i.e. see details in) <code>as.mask</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contour</code></td>
<td>
<p>Logical; if TRUE, add a contour to current plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>
<p>Logical; if TRUE, add the point pattern to current plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Additional graphical parameters passed to <code>link{plot}</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Getis and Franklin (1987) proposed the neigbourhood density function, a local version of Ripley's <code class="reqn">L</code>- function.
Given a spatial point pattern <code class="reqn">X</code>, the neigbourhood density function associated with the <em>i</em>th point in <code class="reqn">X</code> is computed by
</p>
<p style="text-align: center;"><code class="reqn">L[i](r) = sqrt((a/((n-1))*pi))*sum[j]e[i,j])</code>
</p>

<p>where the sum is over all points <em> j != i</em> that lie within a distance <em>r</em> of the <em>i</em>th point, <em>a</em> is the area of the observation window,
<em>n</em> is the number of points in <code class="reqn">X</code>, and <em>e[i,j]</em> is the isotropic edge correction term (as described in <code>Kest</code>). The value of <em>L[i](r)</em> can also
be interpreted as one of the summands that contributes to the global estimate of the <code class="reqn">L</code>-function. 
</p>
<p>The command <code>getis</code> actually computes the local <code class="reqn">K</code>-function using <code>Kcross</code>. As the main objective of <code>getis</code> is to map the local density function,  
as sugested by Gestis and Franklin (1987: 476) a grid of  points (whose density is controled by <code>nx</code> and <code>ny</code>),  is used to accurately estimate the
functions in empty or sparse areas. The S3 method  <code>plot.ecespa.getis</code>  plots the spatial distribution of  the local <code class="reqn">K</code> or <code class="reqn">L</code> function or other related local statistics, such as 
<code class="reqn">n[i](r)</code>, the number of neighbor points [=<code class="reqn"> lambda*K[i](r)</code>]  or the deviations from  the expected value of  local  <code class="reqn">L</code>  under CSR [= <code class="reqn">L[i](r) -r</code>].  It some of the arguments <code>dimyx</code>, <code>xy</code> or <code>eps</code> is provided it will use the function 
<code>interp.im</code> in <code>spatstat</code> package to interpolate the results;otherwise it will plot the estimated values at the origial grid points. 
</p>


<h3>Value</h3>

<p><code>getis</code> gives an object of class <code>ecespa.getis</code>, bassically a list with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x </code></td>
<td>
<p>x coordinates of pattern points (ahead) and grid points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y </code></td>
<td>
<p>y coordinates of pattern points (ahead) and grid points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>klocal </code></td>
<td>
<p>Estimate of local <code class="reqn">K[i](r)</code> at the point pattern points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>klocalgrid </code></td>
<td>
<p>Estimate of local <code class="reqn">K[i](r)</code> at the grid points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R </code></td>
<td>
<p>Distance <code class="reqn">r</code> at which the estimation is made.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nx </code></td>
<td>
<p>Density of the estimating grid  in the x-side. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ny </code></td>
<td>
<p>Density of the estimating grid  in the x-side. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataname </code></td>
<td>
<p>Name of the ppp object analysed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ppp </code></td>
<td>
<p>Original point pattern.</p>
</td>
</tr>
</table>
<p><code>plot.ecespa.getis</code> plots an interpolated map of the selected local statistics
</p>


<h3>Note</h3>

<p>As <code>plot.ecespa.getis</code> interpolates over rectangular grid of points, it is not apropriate to map irregular windows. In those cases, <code>Smooth.ppp</code> of <code>spatstat</code>
can be used to interpolate the local statistics (see examples).
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot </p>


<h3>References</h3>

 
<p>Getis, A. and Franklin, J. 1987. Second-order neighbourhood analysis of mapped point patterns. <em>Ecology</em> 68: 473-477. <a href="https://doi.org/10.2307/1938452">doi:10.2307/1938452</a>.
</p>


<h3>See Also</h3>

 <p><code>localK</code>, a different approach in <span class="pkg">spatstat</span>. </p>


<h3>Examples</h3>

<pre><code class="language-R">
  ## Compare with fig. 5b of Getis &amp; Franklin (1987: 476):
  
  data(ponderosa)
  
  #ponderosa12 &lt;- getis(ponderosa, nx = 30, ny = 30, R = 12)
  ponderosa12 &lt;- getis(ponderosa, nx = 20, ny = 20, R = 12)
  
  plot(ponderosa12, type = "l", dimyx=256)
  
## Not run: 
  ## Plot the same, using Smooth.ppp in spatstat
  
  ponderosa.12 &lt;- setmarks(ponderosa, ponderosa12$klocal)
  
  Z &lt;- Smooth(ponderosa.12, sigma=5, dimyx=256)
  
  plot(Z, col=topo.colors(128), main="smoothed neighbourhood density")
  
  contour(Z, add=TRUE)
  
  points(ponderosa, pch=16, cex=0.5) 
  

  ## Example with irregular window:
  
  data(letterR)
  
  X &lt;- rpoispp(50, win=letterR)
  
  X.g &lt;- getis(X, R=0.2)
  
  plot(X.g,dimyx=c(200,100))
  
   ## Plot the same, using Smooth.ppp in spatstat
    X2 &lt;- setmarks(X, X.g$klocal)
  
    Z &lt;- Smooth(X2, sigma=0.05, dimxy=256)
  
    plot(Z, col=topo.colors(128), main="smoothed neighbourhood density")
  
    contour(Z, add=TRUE)
  
    points(X, pch=16, cex=0.5)
  
    
    
## End(Not run)
</code></pre>


</div>