<div class="container">

<table style="width: 100%;"><tr>
<td>dplot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A function to plot one or more columns of EMU-trackdata as a function of
time (DEPRECATED see below)</h2>

<h3>Description</h3>

<p>A general purpose routine for plotting EMU-trackdata on a single plot.
Tracks can be aligned at an arbitrary position, length normalised or
averaged. The plots can be colour-coded for different category types.
DEPRECATED as this function does not play well with with the new 
resultType = "tibble" of <code>get_trackdata()</code>. See 
<a href="https://ips-lmu.github.io/The-EMU-SDMS-Manual/recipe-plottingSnippets.html">https://ips-lmu.github.io/The-EMU-SDMS-Manual/recipe-plottingSnippets.html</a>
for an alternative plotting routines using ggplot2.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dplot(
  x,
  labs = NULL,
  offset = 0,
  prop = TRUE,
  average = FALSE,
  xlim = NULL,
  ylim = NULL,
  lty = FALSE,
  normalise = FALSE,
  colour = TRUE,
  lwd = NULL,
  pch = NULL,
  legend = "topright",
  axes = TRUE,
  type = "l",
  n = 20,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An EMU-trackdata object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labs</code></td>
<td>
<p>A label vector with one element for each row in 'dataset'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Either: A single numeric vector between 0 and 1. 0 and 1
denote synchronize the trackdata at their temporal onsets and offsets
respectively; 0.5 denotes synchronization at the temporal midpoint, etc. Or
a numeric vector of the same length as x specifying the synchronisation
point per segment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop</code></td>
<td>
<p>A single element character vector specifying whether the tracks
should be aligned proportionally or relative to millisecond times. Defaults
to proportional alignment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>average</code></td>
<td>
<p>If TRUE, the data for each unique label in 'labs' is
averaged</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>A vector of two numeric values specifying the x-axis range</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>A vector of two numeric values specifying the y-axis range</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p>A single element logical vector. Defaults to FALSE.  If TRUE, plot
each label type in a different linetype</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalise</code></td>
<td>
<p>If TRUE, the data for each segment is linearly time
normalised so that all observations have the same length. The number of
points used in the linear time normalisation is control by the argument n.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colour</code></td>
<td>
<p>A single element logical vector. Defaults to TRUE to plot each
label type in a different colour</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>A code passed to the lwd argument in plotting functions. 'lwd'
can be either a single element numeric vector, or its length must be equal
to the number of unique types in labs. For example, if lwd=3 and if labs =
c("a", "b", "a", "c"), then the output is c(3, 3, 3, 3). Alternatively, if
lwd = c(2,3,1), then the output is c(2, 3, 2, 1) for the same example. The
default is NULL in which case all lines are drawn with lwd=1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch</code></td>
<td>
<p>A code passed to the pch argument in plotting functions.
Functions in the same way as lwd above</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>Either a character vector to plot the legend. Possible values
are: "bottomright"', '"bottom"', '"bottomleft"', '"left"', '"topleft"',
'"top"', '"topright"', '"right"' and '"center"'. This places the legend on
the inside of the plot frame at the given location. Partial argument
matching is used. Or a logical vector: legend = FALSE suppresses legend
plotting. legend = TRUE plots it at the default, legend = "topright"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes</code></td>
<td>
<p>A single element logical vector. Defaults to TRUE to plot the axes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The default line type. Default to "l" for a line plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>A single element numeric vector. Only used if normalise=TRUE. The
number of data points used to linearly time normalise each track</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>graphical options par</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code>dcut</code> <code>get_trackdata</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

   # Plot of column 1 (which happens to be the 1st formant) of an EMU-trackdata object
   dplot(dip.fdat[,1])
	

   # As above but only observations 1 to 5
   dplot(dip.fdat[1:5,1])
	

   #  column 2 (which happens to be of the second formant) and colour-coded
   # for each label-type
   dplot(dip.fdat[,2], dip.l)
	

   # put the legend bottom left
   dplot(dip.fdat[,2], dip.l, legend="bottomleft")
	

   # as above with no legend and averaged per category
   dplot(dip.fdat[,2], dip.l, legend=FALSE, average=TRUE)
	

   # both formants averaged
   dplot(dip.fdat[,1:2], dip.l, average=TRUE)
	

   # F2 only with linear-time normalisation
   dplot(dip.fdat[,2], dip.l, norm=TRUE)
	

   # linear time-normalisation, both formants and averaged
   dplot(dip.fdat[,1:2], dip.l, norm=TRUE, average=TRUE)
	

   # synchronise at the temporal midpoint before averaging, F2 only
   dplot(dip.fdat[,2], dip.l, offset=0.5, average=TRUE)
	

   # synchronise 60 ms before the diphthong offset
   dplot(dip.fdat[,2], dip.l, offset=dip.fdat$ftime[,2]-60, prop=FALSE)
	

   # as above averaged, no colour with linetype, 
# different plot symbols double line thickness in the range between +- 20 ms
   dplot(dip.fdat[,2], dip.l, offset=dip.fdat$ftime[,2]-60, prop=FALSE,
   average=TRUE, colour=FALSE, lty=TRUE, pch=1:3, lwd =2, type="b", xlim=c(-20, 20))




</code></pre>


</div>