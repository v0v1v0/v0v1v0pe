<div class="container">

<table style="width: 100%;"><tr>
<td>postInference.MHLS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Post-inference with lasso estimator</h2>

<h3>Description</h3>

<p>Provides confidence intervals for the set of active coefficients
of lasso using Metropolis-Hastings sampler.
</p>


<h3>Usage</h3>

<pre><code class="language-R">postInference.MHLS(X, Y, lbd, weights = rep(1, ncol(X)), tau = rep(1,
  ncol(X)), sig2.hat, alpha = 0.05, nChain = 10, method,
  niterPerChain = 500, parallel = FALSE, ncores = 2L,
  returnSamples = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>predictor matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbd</code></td>
<td>
<p>penalty term of lasso. By letting this argument be <code>"cv.1se"</code> or
<code>"cv.min"</code>, users can have the cross-validated lambda that gives either minimum
squared error or that is within 1 std error bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>weight vector with length equal to the number of coefficients.
Default is <code>rep(1, ncol(X))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>numeric vector. Standard deviation of proposal distribution
for each beta. Adjust the value to get relevant level of acceptance rate.
Default is <code>rep(1, ncol(X))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig2.hat</code></td>
<td>
<p>variance of error term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>confidence level for confidence interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nChain</code></td>
<td>
<p>the number of chains. For each chain, different plug-in beta will be generated
from its confidence region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Type of robust method. Users can choose either <code>"coeff"</code> or <code>"mu"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niterPerChain</code></td>
<td>
<p>the number of iterations per chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical. If <code>parallel = TRUE</code>, uses parallelization.
Default is <code>parallel = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>integer. The number of cores to use for parallelization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnSamples</code></td>
<td>
<p>logical. If <code>returnSamples = TRUE</code>, print Metropolis-Hastings samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>auxiliary <code>MHLS</code> arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function provides post-selection inference for the active coefficients selected by lasso.
Uses Metropolis-Hastings sampler with multiple chains to draw from the
distribution under a fixed active set and generates <code>(1-alpha)</code>
confidence interval for each active coefficients.
Set <code>returnSamples = TRUE</code> to check the Metropolis-Hastings samples.
Check the acceptance rate and adjust <code>tau</code> accordingly.
We recommend to set <code>nChain &gt;= 10</code> and <code>niterPerChain &gt;= 500</code>.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>MHsamples</code></td>
<td>
<p>a list of class MHLS.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confidenceInterval</code></td>
<td>
<p>(1-alpha) confidence interval
for each active coefficient.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">set.seed(123)
n &lt;- 6
p &lt;- 10
X &lt;- matrix(rnorm(n*p),n)
Y &lt;- X %*% rep(1,p) + rnorm(n)
sig2 &lt;- 1
lbd &lt;- .37
weights &lt;- rep(1,p)
parallel &lt;- (.Platform$OS.type != "windows")
postInference.MHLS(X = X, Y = Y, lbd = lbd, sig2.hat = 1, alpha = .05,
nChain = 3, niterPerChain = 20, method = "coeff", parallel = parallel)
postInference.MHLS(X = X, Y = Y, lbd = lbd, sig2.hat = 1, alpha = .05,
nChain = 3, niterPerChain = 20, method = "coeff", parallel = parallel, returnSamples = TRUE)
postInference.MHLS(X = X, Y = Y, lbd = lbd, sig2.hat = 1, alpha = .05,
nChain = 3, niterPerChain = 20, method = "mu", parallel = parallel)
postInference.MHLS(X = X, Y = Y, lbd = lbd, sig2.hat = 1, alpha = .05,
nChain = 3, niterPerChain = 20, method = "mu", parallel = parallel, returnSamples = TRUE)
</code></pre>


</div>