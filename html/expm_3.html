<div class="container">

<table style="width: 100%;"><tr>
<td>expm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Matrix Exponential</h2>

<h3>Description</h3>

<p>This function computes the exponential of a square matrix
<code class="reqn">A</code>, defined as the sum from <code class="reqn">r=0</code> to infinity of
<code class="reqn">A^r/r!</code>.
Several methods are provided. The Taylor series and Padé
approximation are very importantly combined with scaling and squaring.
</p>


<h3>Usage</h3>

<pre><code class="language-R">expm(x, method = c("Higham08.b", "Higham08",
                   "AlMohy-Hi09",
                   "Ward77", "PadeRBS", "Pade", "Taylor", "PadeO", "TaylorO",
                   "R_Eigen", "R_Pade", "R_Ward77", "hybrid_Eigen_Ward"),
     order = 8, trySym = TRUE, tol = .Machine$double.eps, do.sparseMsg = TRUE,
     preconditioning = c("2bal", "1bal", "buggy"))

.methComplex # those 'method' s which also work for complex (number) matrices
.methSparse  # those 'method' s which work with _sparseMatrix_ w/o coercion to dense

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a square matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p><code>"Higham08.b"</code>, <code>"Ward77"</code>, <code>"Pade"</code> or
<code>"Taylor"</code>, etc;
The default is now <code>"Higham08.b"</code> which uses Higham's 2008
algorithm with <em>additional</em> balancing preconditioning,
see <code>expm.Higham08</code>.
</p>
<p>The versions with "*O" call the
original Fortran code, whereas the first ones call the BLAS-using
and partly simplified newer code.<br><code>"R_Pade"</code> uses an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-code version of <code>"Pade"</code> for
didactical reasons, and<br><code>"R_Ward77"</code> uses an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> version of <code>"Ward77"</code>, still based
on LAPACK's <code>dgebal</code>, see <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> interface <code>dgebal</code>.
This has enabled us to diagnose and fix the bug in the original
octave implementation of <code>"Ward77"</code>.
<code>"R_Eigen"</code> tries to diagonalise the matrix <code>x</code>, if not possible,
<code>"R_Eigen"</code> raises an error. <code>"hybrid_Eigen_Ward"</code> method also
tries to diagonalise the matrix <code>x</code>, if not possible, it uses
<code>"Ward77"</code> algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>an integer, the order of approximation to be used, for
the <code>"Pade"</code>, incl <code>"R_Ward77"</code>, and <code>"Taylor"</code> methods.
The best value for this depends on 
machine precision (and slightly on <code>x</code>) but for the current
double precision arithmetic, one recommendation (and the Matlab
implementations) uses <code>order = 6</code> unconditionally;<br>
our default, <code>8</code>, is from Ward(1977, p.606)'s recommendation,
but also used for <code>"AlMohy-Hi09"</code> where a high order
<code>order=12</code> may be more appropriate (and slightly more expensive).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trySym</code></td>
<td>
<p>logical indicating if <code>method = "R_Eigen"</code> should use
<code>isSymmetric(x)</code> and take advantage for (almost)
symmetric matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>a given tolerance used to check if <code>x</code> is
computationally singular when <code>method = "hybrid_Eigen_Ward"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.sparseMsg</code></td>
<td>
<p>logical allowing a message about sparse to dense
coercion; setting it <code>FALSE</code> suppresses that message.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preconditioning</code></td>
<td>
<p>a string specifying which implementation of
Ward(1977) should be used when <code>method = "Ward77"</code>.

</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The exponential of a matrix is defined as the infinite Taylor series
</p>
<p style="text-align: center;"><code class="reqn">e^M = \sum_{k = 1}^\infty \frac{M^k}{k!}.</code>
</p>

<p>For the "Pade" and "Taylor" methods, there is an <code>"accuracy"</code>
attribute of the result.  It is an upper bound for the L2 norm of the
Cauchy error <code>expm(x, *, order + 10) - expm(x, *, order)</code>.
</p>
<p>Currently, mostly algorithms which are <em>“<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-code only”</em> accept <em>sparse</em>
matrices (see the
<code>"sparseMatrix"</code> class in package
<a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a>).  Their <code>method</code> names are available from <code>.methSparse</code>.
</p>
<p>Similarly only some of the algorithms are available for <code>complex</code> (number)
matrices; the corresponding <code>method</code>s are in <code>.methComplex</code>.
</p>


<h3>Value</h3>

<p>The matrix exponential of <code>x</code>.
</p>


<h3>Note</h3>

<p>For a good general discussion of the matrix exponential
problem, see Moler and van Loan (2003).
</p>


<h3>Author(s)</h3>

<p>The <code>"Ward77"</code> method:<br>
Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>, and Christophe
Dutang, based on code translated by Doug Bates and Martin Maechler
from the implementation of the corresponding Octave function
contributed by A. Scottedward Hodel <a href="mailto:A.S.Hodel@eng.auburn.edu">A.S.Hodel@eng.auburn.edu</a>.
</p>
<p>The <code>"PadeRBS"</code> method:<br>
Roger B. Sidje, see the EXPOKIT reference.
</p>
<p>The <code>"PadeO"</code> and  <code>"TaylorO"</code> methods:<br>
Marina Shapira (U Oxford, UK) and David Firth (U Warwick, UK);
</p>
<p>The <code>"Pade"</code> and  <code>"Taylor"</code> methods are slight
modifications of the "*O" ([O]riginal versions) methods,
by Martin Maechler, using BLAS and LINPACK where possible.
</p>
<p>The <code>"hybrid_Eigen_Ward"</code> method by Christophe Dutang is a C
translation of <code>"R_Eigen"</code> method by Martin Maechler.
</p>
<p>The <code>"Higham08"</code> and <code>"Higham08.b"</code> (current default) were
written by Michael Stadelmann, see <code>expm.Higham08</code>.
</p>
<p>The <code>"AlMohy-Hi09"</code> implementation (<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> code interfacing to
stand-alone C) was provided and donated by Drew Schmidt, U. Tennesse.
</p>


<h3>References</h3>

<p>Ward, R. C. (1977).  Numerical computation
of the matrix exponential with accuracy estimate.
<em>SIAM J. Num. Anal.</em> <b>14</b>, 600–610.
</p>
<p>Roger B. Sidje (1998).
EXPOKIT: Software package for computing matrix exponentials.
ACM - Transactions on Mathematical Software <b>24</b>(1), 130–156.
</p>
<p>Moler, C and van Loan, C (2003).  Nineteen dubious ways to compute
the exponential of a matrix, twenty-five years later.
<em>SIAM Review</em> <b>45</b>, 3–49.  At
<a href="https://doi.org/10.1137/S00361445024180">doi:10.1137/S00361445024180</a>
</p>
<p>Awad H. Al-Mohy and Nicholas J. Higham (2009)
A New Scaling and Squaring Algorithm for the Matrix Exponential.
<em>SIAM. J. Matrix Anal. &amp; Appl.</em>, <b>31</b>(3), 970–989.
<a href="https://doi.org/10.1137/S00361445024180">doi:10.1137/S00361445024180</a>
</p>


<h3>See Also</h3>

<p>The package vignette for details on the algorithms and calling the
function from external packages.
</p>
<p><code>expm.Higham08</code> for <code>"Higham08"</code>.
</p>
<p><code>expAtv(A,v,t)</code> computes <code class="reqn">e^{At} v</code> (for scalar
<code class="reqn">t</code> and <code class="reqn">n</code>-vector <code class="reqn">v</code>) <em>directly</em> and more
efficiently than computing <code class="reqn">e^{At}</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- matrix(c(-49, -64, 24, 31), 2, 2)
expm(x)
expm(x, method = "AlMohy-Hi09")
## ----------------------------
## Test case 1 from Ward (1977)
## ----------------------------
test1 &lt;- t(matrix(c(
    4, 2, 0,
    1, 4, 1,
    1, 1, 4), 3, 3))
expm(test1, method="Pade")
## Results on Power Mac G3 under Mac OS 10.2.8
##                    [,1]               [,2]               [,3]
## [1,] 147.86662244637000 183.76513864636857  71.79703239999643
## [2,] 127.78108552318250 183.76513864636877  91.88256932318409
## [3,] 127.78108552318204 163.67960172318047 111.96810624637124
## -- these agree with ward (1977, p608)

## Compare with the naive "R_Eigen" method:
try(
expm(test1, method="R_Eigen")
) ## platform depently, sometimes gives an error from solve
## or is accurate or one older result was
##                   [,1]                [,2]               [,3]
##[1,] 147.86662244637003  88.500223574029647 103.39983337000028
##[2,] 127.78108552318220 117.345806155250600  90.70416537273444
##[3,] 127.78108552318226  90.384173332156763 117.66579819582827
## -- hopelessly inaccurate in all but the first column.
##
## ----------------------------
## Test case 2 from Ward (1977)
## ----------------------------
test2 &lt;- t(matrix(c(
    29.87942128909879, .7815750847907159, -2.289519314033932,
    .7815750847907159, 25.72656945571064,  8.680737820540137,
   -2.289519314033932, 8.680737820540137,  34.39400925519054),
           3, 3))
expm(test2, method="Pade")
##                   [,1]               [,2]               [,3]
##[1,]   5496313853692357 -18231880972009844 -30475770808580828
##[2,] -18231880972009852  60605228702227024 101291842930256144
##[3,] -30475770808580840 101291842930256144 169294411240859072
## -- which agrees with Ward (1977) to 13 significant figures
expm(test2, method="R_Eigen")
##                   [,1]               [,2]               [,3]
##[1,]   5496313853692405 -18231880972009100 -30475770808580196
##[2,] -18231880972009160  60605228702221760 101291842930249376
##[3,] -30475770808580244 101291842930249200 169294411240850880
## -- in this case a very similar degree of accuracy.
##
## ----------------------------
## Test case 3 from Ward (1977)
## ----------------------------
test3 &lt;- t(matrix(c(
    -131, 19, 18,
    -390, 56, 54,
    -387, 57, 52), 3, 3))
expm(test3, method="Pade")
##                    [,1]                [,2]                [,3]
##[1,] -1.5096441587713636 0.36787943910439874 0.13533528117301735
##[2,] -5.6325707997970271 1.47151775847745725 0.40600584351567010
##[3,] -4.9349383260294299 1.10363831731417195 0.54134112675653534
## -- agrees to 10dp with Ward (1977), p608.
expm(test3, method="R_Eigen")
##                   [,1]               [,2]                [,3]
##[1,] -1.509644158796182 0.3678794391103086 0.13533528117547022
##[2,] -5.632570799902948 1.4715177585023838 0.40600584352641989
##[3,] -4.934938326098410 1.1036383173309319 0.54134112676302582
## -- in this case, a similar level of agreement with Ward (1977).
##
## ----------------------------
## Test case 4 from Ward (1977)
## ----------------------------
test4 &lt;-
    structure(c(0, 0, 0, 0, 0, 0, 0, 0, 0, 1e-10,
                1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 1, 0),
    .Dim = c(10, 10))
attributes(expm(test4, method="Pade"))
max(abs(expm(test4, method="Pade") - expm(test4, method="R_Eigen")))
##[1] 8.746826694186494e-08
## -- here mexp2 is accurate only to 7 d.p., whereas mexp
##    is correct to at least 14 d.p.
##
## Note that these results are achieved with the default
## settings order=8, method="Pade" -- accuracy could
## presumably be improved still further by some tuning
## of these settings.

##
## example of computationally singular matrix -&gt; is nil-potent -&gt; expm(m) = polynomial(m)
##
m &lt;- matrix(c(0,1,0,0), 2,2)
try(
expm(m, method="R_Eigen")
)
## error since m is computationally singular
(em &lt;- expm(m, method="hybrid"))
## hybrid use the Ward77 method
I2 &lt;- diag(2)
stopifnot(all.equal(I2 + m, expm(m)))

## Try all methods --------------------------------------
(meths &lt;- eval(formals(expm)$method)) # &gt;= 13 ..

all3 &lt;- sapply(meths, simplify = FALSE, function(mtd)
    tryCatch(expm(test3, method = mtd), error = conditionMessage))
## are all "equal" :
stopifnot(
    vapply(all3[-1], function(R) all.equal(all3[[1]], R, check.attributes=FALSE), NA))

all4 &lt;- sapply(meths, simplify = FALSE, function(mtd)
    tryCatch(expm(test4, method = mtd), error = conditionMessage))

### Try complex matrices --c--c--c--c--c--c--c--c--c--c--c--c--c--c--c
.methComplex
zm &lt;- m*(1+1i) # is also nilpotent :
stopifnot(zm %*% zm == 0, # is nilpotent already for ^2  ==&gt; expm() is linear %
          all.equal(I2 + zm, expm(zm)))

## ---&gt;&gt; more tests in ../tests/{ex,ex2,exact-ex}.R 
</code></pre>


</div>