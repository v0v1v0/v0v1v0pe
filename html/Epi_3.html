<div class="container">

<table style="width: 100%;"><tr>
<td>entry.Lexis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Time series and other methods for Lexis objects</h2>

<h3>Description</h3>

<p>Extract the entry time, exit time, status or duration of follow-up from a
<code>Lexis</code> object. Classify states.
</p>


<h3>Usage</h3>

<pre><code class="language-R">     entry(x, time.scale = NULL, by.id=FALSE)
      exit(x, time.scale = NULL, by.id=FALSE)
    status(x, at="exit"        , by.id=FALSE)
       dur(x,                    by.id=FALSE)
 transient(x)
 absorbing(x)
 preceding(x, states)
    before(x, states)
succeeding(x, states)
     after(x, states)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>Lexis</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.scale</code></td>
<td>
<p>a string or integer indicating the time scale. If
omitted, all times scales are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by.id</code></td>
<td>
<p>Logical, if <code>TRUE</code>, only one record per unique value
of <code>lex.id</code> is returned; either the first, the last, or for
<code>dur</code>, the sum of <code>lex.dur</code>. If <code>TRUE</code>, the returned
object have the <code>lex.id</code> as (row)names attribute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p>string indicating the time point(s) at which status is to be
measured. Possible values are "exit" or "entry".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>states</code></td>
<td>
<p>Character vector of states.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The <code>entry</code> and <code>exit</code> functions return a vector of
entry times and exit times, respectively, on the requested time
scale. If multiple time scales are requested, a matrix is
returned.
</p>
<p>The <code>status</code> function returns a vector giving the status at
"<code>at</code>" (either '<code>entry</code>' or '<code>exit</code>') and <code>dur</code>
returns a vector with the lengths of the follow-up intervals.
</p>
<p><code>entry</code>, <code>exit</code>, <code>status</code> and <code>dur</code> return vectors
of length <code>nrow(x)</code> if <code>by.id=FALSE</code>; if <code>by.id=TRUE</code> a
vector of length <code>length(unique(lex.id))</code>.
</p>
<p>The functions <code>transient</code> and <code>absorbing</code> return character
vectors of the transient, resp. absorbing states in <code>x</code>. These
are necessarily disjoint but the union may be a proper subset of
<code>levels(x)</code>, since the latter may have levels that are never
assumed by either <code>lex.Cst</code> or <code>lex.Xst</code>.
</p>
<p><code>preceding</code> returns a character vector with names of the states
of the Lexis object <code>x</code> from which one of the states in
<code>states</code> can be reached directly - the preceding
states. <code>before</code> is just a synonym for <code>preceding</code>.
</p>
<p><code>succeeding</code> returns a character vector with names of the states
of the Lexis object <code>x</code> that can be reached directly from one of
the states in <code>states</code>. <code>after</code> is just a synonym for
<code>succeeding</code>.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer &amp; Bendix Carstensen</p>


<h3>See Also</h3>

<p><code>Lexis</code></p>


</div>